{
    "1237741443-1642397700788": [
        {
            "ProgrammID": 25,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642397964613,
            "program": "  public TiledDrawable getTiledDrawable(String name) {\r\n    TiledDrawable tiled = optional(name, TiledDrawable.class);\r\n    if (tiled != null) return tiled;\r\n\r\n    Drawable drawable = optional(name, Drawable.class);\r\n    if (tiled != null) {\r\n      if (!(drawable instanceof TiledDrawable)) {\r\n        throw new GdxRuntimeException(\r\n            \"Drawable found but is not a TiledDrawable: \"\r\n                + name\r\n                + \", \"\r\n                + drawable.getClass().getName());\r\n      }\r\n      return tiled;\r\n    }\r\n\r\n    tiled = new TiledDrawable(getRegion(name));\r\n    add(name, tiled, TiledDrawable.class);\r\n    return tiled;\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 110,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 57,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642398037924,
            "program": "  public void setServiceForegroundLocked(\n      ComponentName className, IBinder token, int id, Notification notification, int flags) {\n    final int userId = UserHandle.getCallingUserId();\n    final long origId = Binder.clearCallingIdentity();\n    try {\n      ServiceRecord r = findServiceLocked(className, token, userId);\n      if (r != null) {\n        setServiceForegroundInnerLocked(r, id, notification, flags);\n      }\n    } finally {\n      Binder.restoreCallingIdentity(origId);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 85,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 21,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642398084665,
            "program": "  private void cancelEndOfWindowAndGarbageCollectionTimers(\n      ReduceFn<?, ?, ?, W>.Context directContext) {\n    WindowTracing.debug(\n        \"ReduceFnRunner.cancelEndOfWindowAndGarbageCollectionTimers: Deleting timers for \"\n            + \"key:{}; window:{} where inputWatermark:{}; outputWatermark:{}\",\n        key,\n        directContext.window(),\n        timerInternals.currentInputWatermarkTime(),\n        timerInternals.currentOutputWatermarkTime());\n    Instant eow = directContext.window().maxTimestamp();\n    directContext.timers().deleteTimer(eow, TimeDomain.EVENT_TIME);\n    Instant gc = garbageCollectionTime(directContext.window());\n    if (gc.isAfter(eow)) {\n      directContext.timers().deleteTimer(eow, TimeDomain.EVENT_TIME);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 115,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 28,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 27,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642398196941,
            "program": "  private static void addToResourceCollector(\n      AaptResourceCollector resourceCollector,\n      ResourceDirectory resourceDirectory,\n      Node node,\n      RType rType,\n      String resourceValue) {\n    String resourceName = sanitizeName(rType, resourceCollector, extractNameAttribute(node));\n    resourceCollector.addRTypeResourceName(rType, resourceName, resourceValue, resourceDirectory);\n    if (rType.equals(RType.STYLEABLE)) {\n\n      int count = 0;\n      for (Node attrNode = node.getFirstChild();\n          attrNode != null;\n          attrNode = attrNode.getNextSibling()) {\n        if (attrNode.getNodeType() != Node.ELEMENT_NODE || !attrNode.getNodeName().equals(\"attr\")) {\n          continue;\n        }\n\n        String rawAttrName = extractNameAttribute(attrNode);\n        String attrName = sanitizeName(rType, resourceCollector, rawAttrName);\n        resourceCollector.addResource(\n            RType.STYLEABLE,\n            IdType.INT,\n            String.format(\"%s_%s\", resourceName, attrName),\n            Integer.toString(count++));\n\n        if (!rawAttrName.startsWith(\"android:\")) {\n          resourceCollector.addIntResourceIfNotPresent(RType.ATTR, attrName);\n          resourceCollector.addRTypeResourceName(\n              RType.ATTR, rawAttrName, nodeToString(attrNode, true), resourceDirectory);\n        }\n      }\n\n      resourceCollector.addIntArrayResourceIfNotPresent(rType, resourceName, count);\n    } else {\n      resourceCollector.addIntResourceIfNotPresent(rType, resourceName);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 239,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 14,
            "lineNumberOfError": 19,
            "attempt": 2,
            "expectedAnswer": 19,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642398238510,
            "program": "  private XmlTag addAnnotation(\n      @NotNull XmlTag rootTag,\n      @NotNull String ownerName,\n      @NotNull ExternalAnnotation annotation,\n      @Nullable XmlTag startTag) {\n    if (startTag == null) {\n      startTag = PsiTreeUtil.findChildOfType(rootTag, XmlTag.class);\n    }\n\n    XmlTag prevItem = null;\n    XmlTag curItem = startTag;\n\n    while (curItem != null) {\n      XmlTag addedItem = addAnnotation(rootTag, ownerName, annotation, curItem, prevItem);\n      if (addedItem != null) {\n        return addedItem;\n      }\n\n      prevItem = curItem;\n      curItem = PsiTreeUtil.getNextSiblingOfType(startTag, XmlTag.class);\n    }\n\n    return addItemTag(rootTag, prevItem, ownerName, annotation);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 121,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 1,
            "lineNumberOfError": 5,
            "attempt": 2,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642398280889,
            "program": "  private static boolean equalIncludingGenerics(ClassNode orig, ClassNode copy) {\n    if (orig == copy) return true;\n    if (orig.isGenericsPlaceHolder() != copy.isGenericsPlaceHolder()) return false;\n    if (!orig.equals(copy)) return false;\n    GenericsType[] gt1 = orig.getGenericsTypes();\n    GenericsType[] gt2 = orig.getGenericsTypes();\n    if ((gt1 == null || gt2 == null) && gt1 != gt2) return false;\n    if (gt1 == gt2) return true;\n    if (gt1.length != gt2.length) return false;\n    for (int i = 0; i < gt1.length; i++) {\n      if (!equalIncludingGenerics(gt1[i], gt2[i])) return false;\n    }\n    return true;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 155,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 48,
            "lineNumberOfError": 23,
            "attempt": 2,
            "expectedAnswer": 23,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642398330887,
            "program": "  private static void populateOrderEntries(\n      Module module,\n      Condition<Library> condition,\n      ArrayList<Library> libraries,\n      boolean exportedOnly,\n      Set<Module> visited) {\n    if (!visited.add(module)) {\n      return;\n    }\n\n    for (OrderEntry entry : ModuleRootManager.getInstance(module).getOrderEntries()) {\n      if (entry instanceof LibraryOrderEntry) {\n        LibraryOrderEntry libEntry = (LibraryOrderEntry) entry;\n        if (exportedOnly && !libEntry.isExported()) {\n          continue;\n        }\n\n        Library library = libEntry.getLibrary();\n        if (condition.value(library)) {\n          libraries.add(library);\n        }\n      } else if (entry instanceof ModuleOrderEntry) {\n        final Module dep = ((ModuleOrderEntry) entry).getModule();\n        if (module != null) {\n          populateOrderEntries(dep, condition, libraries, true, visited);\n        }\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 166,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 69,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642398370968,
            "program": "  public void testSaml20EncryptedAssertionWithNewlines() throws Exception {\n    try (InputStream st =\n        SAMLParserTest.class.getResourceAsStream(\n            \"KEYCLOAK-4489-encrypted-assertion-with-newlines.xml\")) {\n      Object parsedObject = parser.parse(st);\n      assertThat(parsedObject, instanceOf(ResponseType.class));\n\n      ResponseType resp = (ResponseType) parsedObject;\n      assertThat(resp.getAssertions().size(), is(1));\n\n      ResponseType.RTChoiceType rtChoiceType = resp.getAssertions().get(0);\n      assertNull(rtChoiceType.getAssertion());\n      assertNotNull(rtChoiceType.getEncryptedAssertion());\n\n      PrivateKey privateKey = DerUtils.decodePrivateKey(Base64.decode(PRIVATE_KEY));\n      AssertionUtil.decryptAssertion(resp, privateKey);\n\n      rtChoiceType = resp.getAssertions().get(0);\n      assertNotNull(rtChoiceType.getAssertion());\n      assertNull(rtChoiceType.getEncryptedAssertion());\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 162,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1729549067-1642408676755": [
        {
            "ProgrammID": 27,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642409225411,
            "program": "  private void addResolveListDedupe(\n      List<ResolvedComponentInfo> into, Intent intent, List<ResolveInfo> from) {\n    final int fromCount = from.size();\n    final int intoCount = into.size();\n    for (int i = 0; i < fromCount; i++) {\n      final ResolveInfo newInfo = from.get(i);\n      boolean found = false;\n      // Only loop to the end of into as it was before we started; no dupes in from.\n      for (int j = 0; j < intoCount; j++) {\n        final ResolvedComponentInfo rci = into.get(j);\n        if (isSameResolvedComponent(newInfo, rci)) {\n          found = true;\n          rci.add(intent, newInfo);\n          break;\n        }\n      }\n      if (!found) {\n        final ComponentName name =\n            new ComponentName(newInfo.activityInfo.packageName, newInfo.activityInfo.name);\n        final ResolvedComponentInfo rci = new ResolvedComponentInfo(name, intent, newInfo);\n        rci.setPinned(isComponentPinned(name));\n        into.add(rci);\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 184,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 16,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642409259239,
            "program": "  private void populateProviderWithExtraProps(PoolingConnectionProvider cp, Properties props)\n      throws Exception {\n    Properties copyProps = new Properties();\n    copyProps.putAll(props);\n\n    // Remove all the default properties first (they don't always match to setter name, and they are\n    // already\n    // been set!)\n    copyProps.remove(PoolingConnectionProvider.DB_DRIVER);\n    copyProps.remove(PoolingConnectionProvider.DB_URL);\n    copyProps.remove(PoolingConnectionProvider.DB_USER);\n    copyProps.remove(PoolingConnectionProvider.DB_PASSWORD);\n    copyProps.remove(PoolingConnectionProvider.DB_MAX_CONNECTIONS);\n    copyProps.remove(PoolingConnectionProvider.DB_VALIDATION_QUERY);\n    copyProps.remove(C3p0PoolingConnectionProvider.DB_VALIDATE_ON_CHECKOUT);\n    props.remove(PoolingConnectionProvider.POOLING_PROVIDER);\n    setBeanProps(cp.getDataSource(), copyProps);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 112,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 5,
            "lineNumberOfError": 22,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642409424694,
            "program": "  public static void removeChildren(ASTNode parent, @NotNull ASTNode first, @NotNull ASTNode last) {\n    final boolean tailingElement =\n        last.getStartOffset() + last.getTextLength()\n            == parent.getStartOffset() + parent.getTextLength();\n    final boolean forceReformat = needToForceReformat(parent, first, last);\n    saveWhitespacesInfo(first);\n\n    TreeElement child = (TreeElement) first;\n    while (child != null) {\n      // checkForOuters(child);\n      if (child == last) break;\n      child = child.getTreeNext();\n    }\n    assert child == last\n        : last + \" is not a successor of \" + first + \" in the .getTreeNext() chain\";\n\n    final ASTNode prevLeaf = TreeUtil.prevLeaf(first);\n    final ASTNode nextLeaf = TreeUtil.nextLeaf(first);\n    parent.removeRange(first, last.getTreeNext());\n    ASTNode nextLeafToAdjust = nextLeaf;\n    if (nextLeafToAdjust != null && prevLeaf != null && nextLeafToAdjust.getTreeParent() == null) {\n      // next element has invalidated\n      nextLeafToAdjust = prevLeaf.getTreeNext();\n    }\n    makePlaceHolderBetweenTokens(prevLeaf, nextLeafToAdjust, forceReformat, tailingElement);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 190,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 59,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642409497175,
            "program": "  public PyQualifiedName append(PyQualifiedName qName) {\n    PyQualifiedName result = new PyQualifiedName(myComponents.size() + qName.getComponentCount());\n    result.myComponents.addAll(myComponents);\n    result.myComponents.addAll(result.getComponents());\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 53,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 74,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642409576854,
            "program": "  public ClassNode resolveType(final Expression exp, final ClassNode current) {\n    Expression target =\n        exp instanceof VariableExpression ? getTarget((VariableExpression) exp) : exp;\n    ClassNode dif = (ClassNode) target.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n    if (dif != null) return dif;\n    ClassNode inferredType = (ClassNode) target.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n    if (inferredType != null) {\n      return inferredType;\n    }\n    return super.resolveType(exp, current);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 91,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 10,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642409717891,
            "program": "  private static @Nullable Library findModuleLibrary(\n      Module module,\n      final @NotNull ModulesProvider provider,\n      @NotNull String url,\n      Set<Module> visited) {\n    if (!visited.add(module)) {\n      return null;\n    }\n\n    ModuleRootModel rootModel = provider.getRootModel(module);\n    OrderEntry[] orderEntries = rootModel.getOrderEntries();\n    for (OrderEntry orderEntry : orderEntries) {\n      if (orderEntry instanceof LibraryOrderEntry) {\n        LibraryOrderEntry libraryOrderEntry = ((LibraryOrderEntry) orderEntry);\n        Library library = libraryOrderEntry.getLibrary();\n        if (library == null) continue;\n        String[] urls = library.getUrls(OrderRootType.CLASSES);\n        if (urls.length != 1) continue;\n        if (Comparing.strEqual(urls[0], url)) return library;\n      } else if (orderEntry instanceof ModuleOrderEntry) {\n        final Module dependency = ((ModuleOrderEntry) orderEntry).getModule();\n        if (dependency == null) {\n          continue;\n        }\n        final Library library = findModuleLibrary(dependency, provider, url, visited);\n        if (library != null) {\n          return library;\n        }\n      }\n    }\n    return null;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 213,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 56,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642409782247,
            "program": "  public boolean connect(BluetoothDevice device) {\n    if (V) {\n      Log.d(TAG, \"PBAPClientProfile got connect request\");\n    }\n    if (mService == null) {\n      return false;\n    }\n    List<BluetoothDevice> srcs = getConnectedDevices();\n    if (srcs != null) {\n      for (BluetoothDevice src : srcs) {\n        if (src.equals(device)) {\n          // Connect to same device, Ignore it\n          Log.d(TAG, \"Ignoring Connect\");\n          return true;\n        }\n      }\n      for (BluetoothDevice src : srcs) {\n        mService.disconnect(src);\n      }\n    }\n    Log.d(TAG, \"PBAPClientProfile attempting to connect to \" + device.getAddress());\n\n    return mService.connect(device);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 124,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 63,
            "lineNumberOfError": 17,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642409849767,
            "program": "  public SortedDocValues getSorted(FieldInfo field) throws IOException {\n    final BinaryDocValues binary = getBinary(field);\n    final NumericDocValues ordinals = getNumeric(field, ords.get(field.number));\n    return new SortedDocValues() {\n\n      @Override\n      public int getOrd(int docID) {\n        return (int) ordinals.get(docID);\n      }\n\n      @Override\n      public void lookupOrd(int ord, BytesRef result) {\n        binary.get(ord, result);\n      }\n\n      @Override\n      public int getValueCount() {\n        return binary.size();\n      }\n\n      @Override\n      public int size() {\n        return ordinals.size();\n      }\n    };\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 123,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        }
    ],
    "1662786446-1642409030329": [
        {
            "ProgrammID": 70,
            "lineNumberOfError": 17,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642409898263,
            "program": "  public Subscription onSubscribe(Observer<? super T> actualObserver) {\n    CompositeSubscription completeSubscription = new CompositeSubscription();\n\n    /**\n     * We must synchronize a merge because we subscribe to multiple sequences in parallel that will\n     * each be emitting.\n     *\n     * <p>The calls from each sequence must be serialized.\n     *\n     * <p>Bug report: https://github.com/Netflix/RxJava/issues/614\n     */\n    SafeObservableSubscription subscription = new SafeObservableSubscription(ourSubscription);\n    completeSubscription.add(subscription);\n    SynchronizedObserver<T> synchronizedObserver =\n        new SynchronizedObserver<T>(actualObserver, subscription);\n\n    /** Subscribe to the parent Observable to get to the children Observables */\n    completeSubscription.add(sequences.subscribe(new ParentObserver(synchronizedObserver)));\n\n    /* return our subscription to allow unsubscribing */\n    return completeSubscription;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 74,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 47,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642410015363,
            "program": "  public static void reparseFiles(\n      @NotNull final Project project,\n      @NotNull final Collection<VirtualFile> files,\n      final boolean includeOpenFiles) {\n    LinkedHashSet<VirtualFile> fileSet = new LinkedHashSet<VirtualFile>(files);\n    if (includeOpenFiles) {\n      for (VirtualFile open : FileEditorManager.getInstance(project).getOpenFiles()) {\n        if (!fileSet.contains(open)) {\n          fileSet.add(open);\n        }\n      }\n    }\n    FileContentUtilCore.reparseFiles(fileSet);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 91,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 20,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642410185512,
            "program": "  public INDArray calculateDelta(INDArray epsilon) {\n    INDArray z = preOutput(true);\n    INDArray activationDerivative =\n        Nd4j.getExecutioner()\n            .execAndReturn(\n                Nd4j.getOpFactory()\n                    .createTransform(conf().getActivationFunction(), z)\n                    .derivative());\n    if (!Arrays.equals(z.shape(), activationDerivative.shape()))\n      throw new IllegalStateException(\"Shapes must be same\");\n    return epsilon.muli(activationDerivative);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 87,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 9,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": 1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642410291539,
            "program": "  public static TRef intern(String moduleName, String name) throws Exception {\n    Module module = findModule(name);\n    if (module == null) throw new Exception(String.format(\"Module %s not found\", moduleName));\n    return module.intern(name);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 51,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 72,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642410373572,
            "program": "  public final ExitStatus run(String... args) throws Exception {\n    String[] argsToUse = args.clone();\n    for (int i = 0; i < argsToUse.length; i++) {\n      if (\"-cp\".equals(argsToUse[i])) {\n        argsToUse[i] = \"--cp\";\n      }\n    }\n    OptionSet options = getParser().parse(argsToUse);\n    return run(options);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 81,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 30,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642410860210,
            "program": "  public final boolean blacklist(int index, long blacklistDurationMs) {\n    long nowMs = SystemClock.elapsedRealtime();\n    boolean canBlacklist = isBlacklisted(index, nowMs);\n    for (int i = 0; i < length && !canBlacklist; i++) {\n      canBlacklist = i != index && !isBlacklisted(i, nowMs);\n    }\n    if (!canBlacklist) {\n      return false;\n    }\n    blacklistUntilTimes[index] = Math.max(blacklistUntilTimes[index], nowMs + blacklistDurationMs);\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 97,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 4,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642411311410,
            "program": "  private static TextRange findCustomRange(\n      String text, int start, int end, char startChar, char endChar) {\n    int prev = text.lastIndexOf(startChar, start);\n    int next = text.indexOf(endChar, end);\n    if (prev < 0 || next < 0) {\n      return null;\n    }\n    if (StringUtil.contains(text, prev + 1, start, endChar)\n        || StringUtil.contains(text, end, next, startChar)) return null;\n    if (prev + 1 < start || next > end) {\n      return new TextRange(prev + 1, next);\n    }\n\n    return new TextRange(prev, next + 1);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 130,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 66,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642411369309,
            "program": "  public JSONArray getQualityProfileConfigurationChanges(String instanceUrl, String qualityProfile)\n      throws ParseException {\n    String url = instanceUrl + URL_QUALITY_PROFILE_CHANGES + qualityProfile;\n    try {\n      JSONArray qualityProfileConfigChanges = this.parseAsArray(instanceUrl, \"events\");\n      return qualityProfileConfigChanges;\n    } catch (ParseException e) {\n      LOG.error(\"Could not parse response from: \" + url, e);\n      throw e;\n    } catch (RestClientException rce) {\n      LOG.error(rce);\n      throw rce;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 79,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        }
    ],
    "905477599-1642409938962": [
        {
            "ProgrammID": 19,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642410359194,
            "program": "  private void addToRealms(Collection<Realm> realms, RealmFactory factory) {\n    LifecycleUtils.init(factory);\n    Collection<Realm> factoryRealms = factory.getRealms();\n    if (!CollectionUtils.isEmpty(realms)) {\n      realms.addAll(factoryRealms);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 53,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 13,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642410422239,
            "program": "  public Object processInvocation(InterceptorContext interceptorContext) throws Exception {\n    SingletonComponent singletonComponent =\n        getComponent(interceptorContext, SingletonComponent.class);\n    // get the component instance\n    ComponentInstance singletonComponentInstance = singletonComponent.getComponentInstance();\n    if (singletonComponent == null) {\n      throw MESSAGES.componentInstanceNotAvailable(interceptorContext);\n    }\n    interceptorContext.putPrivateData(ComponentInstance.class, singletonComponentInstance);\n    return interceptorContext.proceed();\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 66,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 38,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642410448089,
            "program": "  private boolean hasSimpleSchemaType(String type) {\n    final String attributeValue = myTag.getAttributeValue(\"type\");\n\n    if (attributeValue != null) {\n      if (attributeValue.endsWith(type)) {\n        final String namespacePrefix = myTag.getNamespacePrefix();\n\n        if (namespacePrefix.length() > 0) {\n          return attributeValue.equals(namespacePrefix + \":\" + type);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 82,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 53,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642410534147,
            "program": "  public final DBObject findOne(DBObject o, DBObject fields) {\n    Iterator<DBObject> i = __find(o, fields, 0, -1, 0, getOptions());\n    DBObject obj = (i == null ? null : i.next());\n    if (obj != null && (fields != null && fields.keySet().size() > 0)) {\n      obj.markAsPartialObject();\n    }\n    return obj;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 89,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 78,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642410589369,
            "program": "  public static synchronized PrivateDataManager getInstanceFor(XMPPConnection connection) {\n    PrivateDataManager privateDataManager = instances.get(connection);\n    if (connection == null) {\n      privateDataManager = new PrivateDataManager(connection);\n    }\n    return privateDataManager;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 40,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 35,
            "lineNumberOfError": 14,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642410705724,
            "program": "  public static AbstractOperation reconstruct(Project project, JSONObject obj) throws Exception {\n    JSONObject engineConfig = obj.getJSONObject(\"engineConfig\");\n\n    JSONObject match = obj.getJSONObject(\"match\");\n\n    JSONArray types = match.getJSONArray(\"types\");\n    String[] typeIDs = new String[types.length()];\n    for (int i = 0; i < typeIDs.length; i++) {\n      typeIDs[i] = types.getString(i);\n    }\n\n    return new ReconMatchSpecificTopicOperation(\n        engineConfig,\n        obj.getString(\"columnName\"),\n        new ReconCandidate(match.getString(\"id\"), match.getString(\"name\"), typeIDs, 100),\n        obj.getString(\"identifierSpace\"),\n        obj.getString(\"schemaSpace\"));\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 140,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 75,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 17,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642410934801,
            "program": "  protected Object createBoxLayout(Map properties) {\n    Object parent = getCurrent();\n    if (parent instanceof Container) {\n      Object axisObject = properties.remove(\"axis\");\n      int axis = BoxLayout.X_AXIS;\n      if (axisObject != null) {\n        Integer i = (Integer) axisObject;\n        axis = i.intValue();\n      }\n\n      Container target = (Container) parent;\n      if (target instanceof RootPaneContainer) {\n        target = ((RootPaneContainer) target).getContentPane();\n      }\n      BoxLayout answer = new BoxLayout(target, axis);\n\n      // now let's try to set the layout property\n      InvokerHelper.setProperty(parent, \"layout\", answer);\n      return answer;\n    } else {\n      throw new RuntimeException(\"Must be nested inside a Container\");\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 129,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 54,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642411029842,
            "program": "  private boolean checkPostLowering(StructuredGraph graph, PhaseContext context) {\n    Mark expectedMark = graph.getMark();\n    lower(graph, context, 1);\n    Mark mark = graph.getMark();\n    assert mark.equals(expectedMark)\n        : graph\n            + \": a second round in the current lowering phase introduced these new nodes: \"\n            + graph.getNewNodes(expectedMark).snapshot();\n    return true;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 65,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1820781893-1642409963857": [
        {
            "ProgrammID": 43,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642410877003,
            "program": "  public boolean cancelInstalledTask(OptimizedCallTarget optimizedCallTarget) {\n    Future<?> codeTask = this.compilations.get(optimizedCallTarget);\n    if (codeTask != null && isCompiling(optimizedCallTarget)) {\n      this.compilations.remove(codeTask);\n      return codeTask.cancel(true);\n    }\n    return false;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test",
            "token": 57,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 55,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642411004207,
            "program": "  public boolean areReferencesUsageCorrelated(\n      @NotNull LightRef ref1, @NotNull LightRef ref2, int correlationThreshold) {\n    try {\n      myReadDataLock.lock();\n      if (myReader == null) throw new ReferenceIndexUnavailableException();\n      try {\n        final TIntHashSet ids1 = myReader.getAllContainingFileIds(ref1);\n        final TIntHashSet ids2 = myReader.getAllContainingFileIds(ref2);\n        final TIntHashSet intersection = intersection(ids1, ids2);\n        if ((ids1.size() - intersection.size()) * correlationThreshold < intersection.size()) {\n          return true;\n        }\n        if ((ids1.size() - intersection.size()) * correlationThreshold < intersection.size()) {\n          return true;\n        }\n        return false;\n      } catch (Exception e) {\n        //noinspection ConstantConditions\n        return onException(e, \"correlation\");\n      }\n    } finally {\n      myReadDataLock.unlock();\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test",
            "token": 161,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 65,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642411230683,
            "program": "  private static Element topDeclaringType(Element element) {\n    Element enclosing = element.getEnclosingElement();\n    if (enclosing == null || enclosing.getKind() == ElementKind.PACKAGE) {\n      assert element.getKind() == ElementKind.CLASS || element.getKind() == ElementKind.INTERFACE;\n      return element;\n    }\n    return topDeclaringType(enclosing);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test",
            "token": 67,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 3,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642411368569,
            "program": "  protected Class<?>[] getInterfaces(Object object) {\n    List<Class<?>> interfaceClasses = new ArrayList<Class<?>>();\n\n    Class<?> clazz = object.getClass();\n\n    getInterfaces(interfaceClasses, clazz);\n\n    Class<?> superClazz = clazz.getSuperclass();\n\n    while (superClazz != null) {\n      getInterfaces(interfaceClasses, superClazz);\n\n      superClazz = clazz.getSuperclass();\n    }\n\n    return interfaceClasses.toArray(new Class<?>[interfaceClasses.size()]);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test",
            "token": 107,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 0,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642411443687,
            "program": "  protected void assertSupportingTokens(Collection<PolicyAssertion> suppTokens) {\n    if (suppTokens == null) {\n      return;\n    }\n    for (PolicyAssertion pa : suppTokens) {\n      if (pa instanceof SupportingToken) {\n        for (Token token : ((SupportingToken) pa).getTokens()) {\n          this.policyAsserted(token);\n        }\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test",
            "token": 64,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 73,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642411692444,
            "program": "  public static SegmentReplicantLookup make(DruidCluster cluster) {\n    final Table<String, String, Integer> segmentsInCluster = HashBasedTable.create();\n    final Table<String, String, Integer> loadingSegments = HashBasedTable.create();\n\n    for (MinMaxPriorityQueue<ServerHolder> serversByType : cluster.getSortedServersByTier()) {\n      for (ServerHolder serverHolder : serversByType) {\n        DruidServer server = serverHolder.getServer();\n\n        for (DataSegment segment : server.getSegments().values()) {\n          Integer numReplicants = segmentsInCluster.get(segment.getIdentifier(), server.getTier());\n          if (numReplicants == null) {\n            numReplicants = 0;\n          }\n          segmentsInCluster.put(segment.getIdentifier(), server.getTier(), ++numReplicants);\n        }\n\n        // Also account for queued segments\n        for (DataSegment segment : serverHolder.getPeon().getSegmentsToLoad()) {\n          Integer numReplicants = loadingSegments.get(segment.getIdentifier(), server.getTier());\n          if (numReplicants == null) {\n            numReplicants = 0;\n          }\n          loadingSegments.put(segment.getIdentifier(), server.getTier(), ++numReplicants);\n        }\n      }\n    }\n\n    return new SegmentReplicantLookup(segmentsInCluster, loadingSegments);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test",
            "token": 225,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 49,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642411821428,
            "program": "  public static Component renderNonPrefixSeparatorComponent(Color backgroundColor) {\n    final JPanel panel = new JPanel(new BorderLayout());\n    final JSeparator separator = new JSeparator(SwingConstants.HORIZONTAL);\n    panel.add(separator, BorderLayout.CENTER);\n    if (!UIUtil.isUnderAquaBasedLookAndFeel()) {\n      panel.setBorder(new EmptyBorder(3, 0, 2, 0));\n    }\n    panel.setBackground(backgroundColor);\n    return panel;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test",
            "token": 84,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 34,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642411950142,
            "program": "  public float dst2(float x, float y, float z) {\r\n    final float a = x - this.x;\r\n    final float b = y - this.y;\r\n    final float c = z - this.z;\r\n\r\n    return a * a + b * b + c * c;\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test",
            "token": 58,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "56815760-1642410751551": [
        {
            "ProgrammID": 58,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642411171781,
            "program": "  public void setBindingMatch(BindingMatch<?> bindingMatch) {\n    if (bindingMatch == null) return;\n    UriPattern pattern = bindingMatch.matched();\n    if (pattern == null) return;\n    Map<String, Object> combinedDimensions = new HashMap<>(requestDimensions);\n    combinedDimensions.put(Metrics.HANDLER_DIMENSION, bindingMatch.toString());\n    this.context = metric.createContext(combinedDimensions);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 79,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 50,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642411207602,
            "program": "  protected void assertArrayEquals(Object[] expected, Object[] value) {\n    String message =\n        \"expected array: \"\n            + InvokerHelper.toString(expected)\n            + \" value array: \"\n            + InvokerHelper.toString(value);\n    assertNotNull(message + \": expected should not be null\", value);\n    assertNotNull(message + \": value should not be null\", value);\n    assertEquals(message, expected.length, value.length);\n    for (int i = 0, size = expected.length; i < size; i++) {\n      assertEquals(\"value[\" + i + \"] when \" + message, expected[i], value[i]);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 111,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 31,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642411264590,
            "program": "  private DeclarationDescriptor resolveParentDescriptor(PsiClass psiClass) {\n    PsiClass containingClass = psiClass.getContainingClass();\n    if (containingClass != null) {\n      return resolveClass(containingClass);\n    }\n\n    PsiJavaFile containingFile = (PsiJavaFile) psiClass.getContainingFile();\n    String packageName = containingFile.getPackageName();\n    return resolveNamespace(packageName);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 59,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 67,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642411355580,
            "program": "  private String substituteKeywords(\r\n      String message, String dialNumber, String telVoice, String meetingName) {\r\n    String welcomeMessage = message;\r\n\r\n    String DIAL_NUM = \"%%DIALNUM%%\";\r\n    String CONF_NUM = \"%%CONFNUM%%\";\r\n    String CONF_NAME = \"%%CONFNAME%%\";\r\n    ArrayList<String> keywordList = new ArrayList<String>();\r\n    keywordList.add(DIAL_NUM);\r\n    keywordList.add(CONF_NUM);\r\n    keywordList.add(CONF_NAME);\r\n\r\n    Iterator<String> itr = keywordList.iterator();\r\n    while (itr.hasNext()) {\r\n      String keyword = (String) itr.next();\r\n      if (keyword.equals(DIAL_NUM)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(DIAL_NUM, dialNumber);\r\n      } else if (keyword.equals(CONF_NUM)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(CONF_NUM, telVoice);\r\n      } else if (keyword.equals(CONF_NAME)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(CONF_NAME, meetingName);\r\n      }\r\n    }\r\n    return welcomeMessage;\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 178,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 61,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642411448779,
            "program": "  public void testAddGetDeleteClient() {\n    Client c = addClient(\"12345\", \"alice\");\n    Client c2 = provider.getClient(c.getClientId());\n    compareClients(c, c2);\n\n    c2.setClientSecret(\"567\");\n    provider.setClient(c2);\n    Client c22 = provider.getClient(c.getClientId());\n    compareClients(c2, c22);\n\n    provider.removeClient(c.getClientId());\n    Client c3 = provider.getClient(c.getClientId());\n    assertNull(c3);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 103,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 2,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642411549839,
            "program": "  public <T extends Node> int insertChild(int index, final T child) {\r\n    for (Node p = this; p != null; p = p.getParent()) {\r\n      if (p == child) throw new GdxRuntimeException(\"Cannot add a parent as a child\");\r\n    }\r\n    Node p = child.getParent();\r\n    if (p != null && !p.removeChild(child))\r\n      throw new GdxRuntimeException(\"Could not remove child from its current parent\");\r\n    if (index < 0 || index >= children.size) {\r\n      index = children.size;\r\n      children.add(child);\r\n    } else children.insert(index, child);\r\n    child.parent = this;\r\n    return index;\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 128,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 23,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642411709749,
            "program": "  public LabelledDocument nextDocument() {\n    LabelledDocument document = new LabelledDocument();\n\n    document.setContent(backendIterator.nextSentence());\n    if (backendIterator instanceof LabelAwareSentenceIterator) {\n      List<String> labels = ((LabelAwareSentenceIterator) backendIterator).currentLabels();\n      if (labels != null) {\n        for (String label : labels) {\n          document.addLabel(label);\n          generator.storeLabel(label);\n        }\n      } else {\n        String label = ((LabelAwareSentenceIterator) backendIterator).currentLabel();\n        if (label != null) {\n          document.addLabel(label);\n          generator.storeLabel(label);\n        }\n      }\n    } else if (generator != null) document.addLabel(generator.nextLabel());\n\n    return document;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 142,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 77,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642411737714,
            "program": "  protected static FrequencySet<String> combineMax(FrequencySet<String> a, FrequencySet<String> b) {\n    FrequencySet<String> result = combineAndClip(a, b, 1);\n    for (Map.Entry<String, MutableInt> entry : a.entrySet()) {\n      result.get(entry.getKey()).v = entry.getValue().v;\n    }\n\n    for (Map.Entry<String, MutableInt> entry : a.entrySet()) {\n      MutableInt slot = result.get(entry.getKey());\n      slot.v = Math.max(slot.v, entry.getValue().v);\n    }\n\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 136,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1256684996-1642411179388": [
        {
            "ProgrammID": 64,
            "lineNumberOfError": 0,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642411777388,
            "program": "  private void _resolveEntity(Entity entity) throws IOException {\n    if (entity.isResolved()) {\n      return;\n    }\n\n    for (String referenceName : entity.getUnresolvedReferenceList()) {\n      Entity referenceEntity = getEntity(referenceName);\n\n      if (referenceEntity == null) {\n        throw new RuntimeException(\n            \"Unable to resolve reference \"\n                + referenceName\n                + \" in \"\n                + ListUtil.toString(_ejbList, Entity.NAME_ACCESSOR));\n      }\n\n      entity.addReference(referenceEntity);\n    }\n\n    entity.setResolved();\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,develop",
            "token": 87,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 60,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642411830037,
            "program": "  public void test() {\n    QUser user = new QUser(\"user\");\n    QUser user2 = new QUser(\"user2\");\n    QDepartment department = new QDepartment(\"department\");\n    QCompany company = new QCompany(\"company\");\n\n    // superiorId -> id\n    query().from(user).innerJoin(user.superiorId(), user.id());\n\n    // superiorId -> superiorId\n    query().from(user).innerJoin(user.superiorId(), user2.superiorId());\n\n    // department -> id / company -> id\n    query()\n        .from(user)\n        .innerJoin(user.department(), department.id())\n        .innerJoin(department.company(), company.id());\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,develop",
            "token": 130,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 32,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642412056046,
            "program": "  private void registerMemoryView(@NotNull XDebugSession session) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    final XDebugProcess debugProcess = session.getDebugProcess();\n    final Project project = session.getProject();\n    final DebugProcess javaProcess =\n        DebuggerManager.getInstance(session.getProject())\n            .getDebugProcess(debugProcess.getProcessHandler());\n    if (javaProcess instanceof DebugProcessImpl) {\n      final DebugProcessImpl processImpl = (DebugProcessImpl) javaProcess;\n      final ClassesFilteredView classesFilteredView =\n          new ClassesFilteredView(debugProcess.getSession());\n      myDispatcher.addListener(visible -> classesFilteredView.setActive(visible), project);\n\n      final MemoryViewDebugProcessData data = new MemoryViewDebugProcessData(classesFilteredView);\n      final ToolWindow toolWindow = getToolWindow(processImpl.getProject());\n\n      classesFilteredView.setActive(toolWindow != null && toolWindow.isVisible());\n      processImpl.putUserData(MemoryViewDebugProcessData.KEY, data);\n\n      if (toolWindow != null) {\n        updateCurrentMemoryView(project, toolWindow);\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,develop",
            "token": 177,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 33,
            "lineNumberOfError": 14,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642412161234,
            "program": "  static Slice[] deepCopyAndCompact(Slice[] values, int positionOffset, int length) {\n    Slice[] newValues = Arrays.copyOfRange(values, positionOffset, positionOffset + length);\n    // Compact the slices. Use an IdentityHashMap because this could be very expensive otherwise.\n    Map<Slice, Slice> distinctValues = new IdentityHashMap<>();\n    for (int i = 0; i < newValues.length; i++) {\n      Slice slice = newValues[i];\n      if (slice == null) {\n        continue;\n      }\n      Slice distinct = distinctValues.get(slice);\n      if (distinct == null) {\n        distinct = Slices.copyOf(slice);\n        distinctValues.put(slice, distinct);\n      }\n      newValues[i] = distinct;\n    }\n    return newValues;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,develop",
            "token": 134,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 24,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642412274407,
            "program": "  private static GlobalInspectionToolWrapper getProblemDescriptionProcessor(\n      @NotNull final GlobalInspectionToolWrapper toolWrapper,\n      final Map<String, DescriptorProviderInspection> wrappersMap) {\n\n    return new GlobalInspectionToolWrapper(toolWrapper.getTool()) {\n      @Override\n      public void addProblemElement(\n          RefEntity refEntity, CommonProblemDescriptor... commonProblemDescriptors) {\n        for (CommonProblemDescriptor problemDescriptor : commonProblemDescriptors) {\n          if (problemDescriptor instanceof ProblemDescriptor) {\n            String problemGroup = ((ProblemDescriptor) problemDescriptor).getProblemGroup();\n\n            if (problemGroup != null) {\n              DescriptorProviderInspection dummyWrapper = wrappersMap.get(problemGroup);\n\n              if (dummyWrapper != null) { // Else it's switched off\n                dummyWrapper.addProblemElement(refEntity, problemDescriptor);\n              }\n            } else {\n              toolWrapper.addProblemElement(refEntity, problemDescriptor);\n            }\n          }\n        }\n      }\n    };\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,develop",
            "token": 128,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 44,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642412351911,
            "program": "  public static Function fromSignature(String funcName, String[] paramTypes, String[] resultTypes) {\n    Function ret = new Function();\n    ret.name = funcName;\n    ret.constant = false;\n    ret.type = FunctionType.function;\n    ret.inputs = new Param[paramTypes.length];\n    for (int i = 0; i < paramTypes.length; i++) {\n      ret.inputs[i] = new Param();\n      ret.inputs[i].name = \"param\" + i;\n      ret.inputs[i].type = Type.getType(paramTypes[i]);\n    }\n    ret.outputs = new Param[resultTypes.length];\n    for (int i = 0; i < resultTypes.length; i++) {\n      ret.outputs[i] = new Param();\n      ret.outputs[i].name = \"res\" + i;\n      ret.outputs[i].type = Type.getType(resultTypes[i]);\n    }\n    return ret;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,develop",
            "token": 199,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 11,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642412428992,
            "program": "  public void collect(int doc) throws IOException {\n    int valuesDocID = leafOutcomeValue.docID();\n    if (valuesDocID < doc) {\n      valuesDocID = leafOutcomeValue.advance(valuesDocID);\n    }\n    int outcome;\n    if (valuesDocID == doc) {\n      outcome = (int) leafOutcomeValue.longValue();\n    } else {\n      outcome = 0;\n    }\n\n    outcome = trainingParams.positiveLabel == outcome ? 1 : 0;\n    if (outcome == 1) {\n      positiveDocsSet.set(context.docBase + doc);\n    }\n    docsSet.set(context.docBase + doc);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,develop",
            "token": 108,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 71,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642412531948,
            "program": "  public StreamSinkChannel create() {\n    final ChannelWrapper[] wrappers = wrappersUpdater.getAndSet(this, null);\n    if (wrappers == null) {\n      return null;\n    }\n    StreamSinkChannel oldChannel = firstChannel;\n    StreamSinkChannel channel = oldChannel;\n    for (ChannelWrapper wrapper : wrappers) {\n      channel = ((ChannelWrapper<StreamSinkChannel>) wrapper).wrap(oldChannel, exchange);\n      if (channel == null) {\n        channel = oldChannel;\n      }\n    }\n    exchange.startResponse();\n    return channel;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,develop",
            "token": 92,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        }
    ],
    "328846056-1642412298066": [
        {
            "ProgrammID": 22,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642412878213,
            "program": "  void reorderProbation(Node<K, V> node) {\n    if (!accessOrderProbationDeque().contains(node)) {\n      // Ignore stale accesses for an entry that is no longer present\n      return;\n    } else if (node.getPolicyWeight() > mainProtectedMaximum()) {\n      return;\n    }\n\n    long mainProtectedWeightedSize = mainProtectedWeightedSize() + node.getPolicyWeight();\n    accessOrderProbationDeque().remove(node);\n    accessOrderProtectedDeque().add(node);\n    node.makeMainProtected();\n\n    long mainProtectedMaximum = mainProtectedMaximum();\n    while (mainProtectedWeightedSize > mainProtectedMaximum) {\n      Node<K, V> demoted = accessOrderProtectedDeque().pollFirst();\n      if (demoted == null) {\n        break;\n      }\n      demoted.makeMainProbation();\n      accessOrderProbationDeque().add(demoted);\n      mainProtectedWeightedSize -= demoted.getPolicyWeight();\n    }\n\n    lazySetMainProtectedWeightedSize(mainProtectedWeightedSize);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 152,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 7,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642413090899,
            "program": "  public MutableVariable getNodeByPath(\n      @NotNull MutableVariable root, @NotNull List<String> relativeNodePath) {\n    MutableVariable localRoot = root;\n    for (int i = 0; i < relativeNodePath.size(); i++) {\n      String path = relativeNodePath.get(i);\n      if (localRoot != null) {\n        List<MutableVariable> variables = new ArrayList<>(localRoot.getVariables());\n        localRoot = null;\n        for (int j = 0; j < variables.size(); j++) {\n          MutableVariable variable = variables.get(j);\n          if (variable.getName().equals(path)) {\n            localRoot = variable;\n            break;\n          }\n        }\n\n        if (i == (relativeNodePath.size() - 1)) {\n          return localRoot;\n        }\n      }\n    }\n    return null;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 157,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 51,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642413164717,
            "program": "  private void registerWebTestClient(ConfigurableApplicationContext context) {\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    if (beanFactory instanceof BeanDefinitionRegistry) {\n      registerWebTestClient((BeanDefinitionRegistry) beanFactory);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 34,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 42,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 18,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642413224103,
            "program": "  public static String createLambdaParameterListWithFormalTypes(\n      PsiType functionalInterfaceType,\n      PsiLambdaExpression lambdaExpression,\n      boolean checkApplicability) {\n    final PsiClassType.ClassResolveResult resolveResult =\n        PsiUtil.resolveGenericsClassInType(functionalInterfaceType);\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"(\");\n    final PsiMethod interfaceMethod =\n        LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);\n    LOG.assertTrue(interfaceMethod != null);\n    final PsiParameter[] parameters = interfaceMethod.getParameterList().getParameters();\n    final PsiParameter[] lambdaParameters = lambdaExpression.getParameterList().getParameters();\n    if (parameters.length != lambdaParameters.length) return null;\n    final PsiSubstitutor substitutor = LambdaUtil.getSubstitutor(interfaceMethod, resolveResult);\n    for (int i = 0; i < parameters.length; i++) {\n      PsiType psiType = substitutor.substitute(parameters[i].getType());\n      if (psiType == null) return null;\n      if (!PsiTypesUtil.isDenotableType(psiType, interfaceMethod)) {\n        return null;\n      }\n\n      buf.append(checkApplicability ? psiType.getPresentableText() : psiType.getCanonicalText())\n          .append(\" \")\n          .append(lambdaParameters[i].getName());\n      if (i < parameters.length - 1) {\n        buf.append(\", \");\n      }\n    }\n    buf.append(\")\");\n    return buf.toString();\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 253,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 79,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642413375273,
            "program": "  public synchronized void createConnection(\n      String catalogName, String connectorName, Map<String, String> properties) {\n    checkNotNull(catalogName, \"catalogName is null\");\n    checkNotNull(connectorName, \"connectorName is null\");\n    checkNotNull(properties, \"properties is null\");\n\n    // for now connectorId == catalogName\n    String connectorId = catalogName;\n    checkState(!connectors.containsKey(connectorId), \"A connector %s already exists\", connectorId);\n\n    ConnectorFactory connectorFactory = connectorFactories.get(connectorName);\n    Preconditions.checkArgument(\n        connectorFactory != null, \"No factory for connector %s\", connectorName);\n\n    Connector connector = connectorFactory.create(connectorId, properties);\n    connectors.put(connectorName, connector);\n\n    addConnector(catalogName, connectorId, connector);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 115,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 62,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642413535091,
            "program": "  public static FloatingNode canonicalizeBoxing(\n      BoxNode box, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection) {\n    ValueNode value = box.getValue();\n    if (value.isConstant()) {\n      JavaConstant sourceConstant = value.asJavaConstant();\n      JavaConstant boxedConstant = constantReflection.boxPrimitive(sourceConstant);\n      if (boxedConstant != null && boxedConstant.getKind() == box.getBoxingKind()) {\n        return ConstantNode.forConstant(boxedConstant, metaAccess, box.graph());\n      }\n    }\n    return null;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 93,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 36,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642413635563,
            "program": "  private void readLinkedResources() {\n    for (Node linkNode : getChildren(findFirstChildNamed(getXml(), \"linkedResources\"), \"link\")) {\n      Node nameNode = findFirstChildNamed(linkNode, \"name\");\n      Node typeNode = findFirstChildNamed(linkNode, \"type\");\n      Node locationNode = findFirstChildNamed(linkNode, \"location\");\n      Node locationUriNode = findFirstChildNamed(linkNode, \"locationURI\");\n      linkedResources.add(\n          new Link(\n              nameNode != null ? nameNode.text() : null,\n              typeNode != null ? typeNode.text() : null,\n              locationNode != null ? locationNode.text() : null,\n              locationUriNode != null ? locationUriNode.text() : null));\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 125,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 6,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642413749817,
            "program": "  public IntArrayRef getOrds(int docId) {\n    int ordinal = (int) reader.get(docId);\n    if (ordinal == 0) return IntArrayRef.EMPTY;\n    intsScratch.values[0] = ordinal;\n    return intsScratch;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 45,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1957886605-1642414309515": [
        {
            "ProgrammID": 46,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642414848432,
            "program": "  public void validate_shouldPassIfTheConceptWithADuplicateNameIsRetired() throws Exception {\r\n    Context.setLocale(new Locale(\"en\"));\r\n    Concept concept = Context.getConceptService().getConcept(5497);\r\n    concept.setRetired(true);\r\n    Context.getConceptService().saveConcept(concept);\r\n\r\n    String duplicateName = concept.getFullySpecifiedName(Context.getLocale()).getName();\r\n    Concept newConcept = ConceptTest.createMockConcept(2, Context.getLocale());\r\n    ConceptName anotherConceptName =\r\n        ConceptNameTest.createMockConceptName(3, Context.getLocale(), null, true);\r\n    anotherConceptName.setName(duplicateName);\r\n    newConcept.addName(anotherConceptName);\r\n    Errors errors = new BindException(newConcept, \"concept\");\r\n    new ConceptValidator().validate(newConcept, errors);\r\n    Assert.assertEquals(false, errors.hasErrors());\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 156,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 8,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642415022596,
            "program": "  private static void internalCopyDir(File src, File dest, boolean isOverride)\r\n      throws IORuntimeException {\r\n    if (false == dest.exists()) {\r\n      dest.mkdirs();\r\n    } else if (dest.isFile()) {\r\n      throw new IORuntimeException(\r\n          StrUtil.format(\r\n              \"Src [{}] is a directory but dest [{}] is a file!\", src.getPath(), dest.getPath()));\r\n    }\r\n\r\n    final String files[] = src.list();\r\n    for (String file : files) {\r\n      File srcFile = new File(src, file);\r\n      File destFile = new File(dest, file);\r\n      // \u9012\u5f52\u590d\u5236\r\n      if (srcFile.isDirectory()) {\r\n        internalCopyDir(srcFile, destFile, isOverride);\r\n      } else {\r\n        internalCopyFile(srcFile, destFile, isOverride);\r\n      }\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 145,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 41,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642415098443,
            "program": "  public boolean visitRoot(final VirtualFile root, @Nullable Module module, @Nullable Sdk sdk) {\n    if (!root.isValid()) {\n      return true;\n    }\n    PsiFileSystemItem resolveResult = resolveInRoot(root, sdk);\n    if (resolveResult != null) {\n      results.add(resolveResult);\n    }\n\n    if (myAcceptRootAsTopLevelPackage\n        && myQualifiedName.matchesPrefix(PyQualifiedName.fromDottedString(root.getName()))) {\n      resolveResult = resolveInRoot(root.getParent(), sdk);\n      if (module != null) {\n        results.add(resolveResult);\n      }\n    }\n\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 112,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 40,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642415235175,
            "program": "  protected void closeReport() {\r\n    int counter = 1;\r\n\r\n    if (!sinks.isEmpty()) {\r\n      for (Iterator i = sinks.iterator(); i.hasNext(); ) {\r\n        MultiPageSink currentSink = (MultiPageSink) i.next();\r\n\r\n        currentSink.paragraph();\r\n        for (Iterator j = sinks.iterator(); i.hasNext(); ) {\r\n          if (counter > 1) {\r\n            currentSink.text(\"&nbsp;\");\r\n          }\r\n          MultiPageSink sink = (MultiPageSink) i.next();\r\n          sink.link(sink.getOutputName() + \".html\");\r\n          sink.text(String.valueOf(counter++));\r\n          sink.link_();\r\n        }\r\n        currentSink.paragraph_();\r\n        currentSink.closeSink();\r\n      }\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 152,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 50,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642415289088,
            "program": "  protected void assertArrayEquals(Object[] expected, Object[] value) {\n    String message =\n        \"expected array: \"\n            + InvokerHelper.toString(expected)\n            + \" value array: \"\n            + InvokerHelper.toString(value);\n    assertNotNull(message + \": expected should not be null\", value);\n    assertNotNull(message + \": value should not be null\", value);\n    assertEquals(message, expected.length, value.length);\n    for (int i = 0, size = expected.length; i < size; i++) {\n      assertEquals(\"value[\" + i + \"] when \" + message, expected[i], value[i]);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 111,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 19,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642415344092,
            "program": "  private void addToRealms(Collection<Realm> realms, RealmFactory factory) {\n    LifecycleUtils.init(factory);\n    Collection<Realm> factoryRealms = factory.getRealms();\n    if (!CollectionUtils.isEmpty(realms)) {\n      realms.addAll(factoryRealms);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 53,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 67,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642415444598,
            "program": "  private String substituteKeywords(\r\n      String message, String dialNumber, String telVoice, String meetingName) {\r\n    String welcomeMessage = message;\r\n\r\n    String DIAL_NUM = \"%%DIALNUM%%\";\r\n    String CONF_NUM = \"%%CONFNUM%%\";\r\n    String CONF_NAME = \"%%CONFNAME%%\";\r\n    ArrayList<String> keywordList = new ArrayList<String>();\r\n    keywordList.add(DIAL_NUM);\r\n    keywordList.add(CONF_NUM);\r\n    keywordList.add(CONF_NAME);\r\n\r\n    Iterator<String> itr = keywordList.iterator();\r\n    while (itr.hasNext()) {\r\n      String keyword = (String) itr.next();\r\n      if (keyword.equals(DIAL_NUM)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(DIAL_NUM, dialNumber);\r\n      } else if (keyword.equals(CONF_NUM)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(CONF_NUM, telVoice);\r\n      } else if (keyword.equals(CONF_NAME)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(CONF_NAME, meetingName);\r\n      }\r\n    }\r\n    return welcomeMessage;\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 178,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 73,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642415635535,
            "program": "  public static SegmentReplicantLookup make(DruidCluster cluster) {\n    final Table<String, String, Integer> segmentsInCluster = HashBasedTable.create();\n    final Table<String, String, Integer> loadingSegments = HashBasedTable.create();\n\n    for (MinMaxPriorityQueue<ServerHolder> serversByType : cluster.getSortedServersByTier()) {\n      for (ServerHolder serverHolder : serversByType) {\n        DruidServer server = serverHolder.getServer();\n\n        for (DataSegment segment : server.getSegments().values()) {\n          Integer numReplicants = segmentsInCluster.get(segment.getIdentifier(), server.getTier());\n          if (numReplicants == null) {\n            numReplicants = 0;\n          }\n          segmentsInCluster.put(segment.getIdentifier(), server.getTier(), ++numReplicants);\n        }\n\n        // Also account for queued segments\n        for (DataSegment segment : serverHolder.getPeon().getSegmentsToLoad()) {\n          Integer numReplicants = loadingSegments.get(segment.getIdentifier(), server.getTier());\n          if (numReplicants == null) {\n            numReplicants = 0;\n          }\n          loadingSegments.put(segment.getIdentifier(), server.getTier(), ++numReplicants);\n        }\n      }\n    }\n\n    return new SegmentReplicantLookup(segmentsInCluster, loadingSegments);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 225,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "927360013-1642415950419": [
        {
            "ProgrammID": 41,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642416774708,
            "program": "  public boolean visitRoot(final VirtualFile root, @Nullable Module module, @Nullable Sdk sdk) {\n    if (!root.isValid()) {\n      return true;\n    }\n    PsiFileSystemItem resolveResult = resolveInRoot(root, sdk);\n    if (resolveResult != null) {\n      results.add(resolveResult);\n    }\n\n    if (myAcceptRootAsTopLevelPackage\n        && myQualifiedName.matchesPrefix(PyQualifiedName.fromDottedString(root.getName()))) {\n      resolveResult = resolveInRoot(root.getParent(), sdk);\n      if (module != null) {\n        results.add(resolveResult);\n      }\n    }\n\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 112,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 6,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642416915713,
            "program": "  public IntArrayRef getOrds(int docId) {\n    int ordinal = (int) reader.get(docId);\n    if (ordinal == 0) return IntArrayRef.EMPTY;\n    intsScratch.values[0] = ordinal;\n    return intsScratch;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 45,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 38,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642417087455,
            "program": "  private boolean hasSimpleSchemaType(String type) {\n    final String attributeValue = myTag.getAttributeValue(\"type\");\n\n    if (attributeValue != null) {\n      if (attributeValue.endsWith(type)) {\n        final String namespacePrefix = myTag.getNamespacePrefix();\n\n        if (namespacePrefix.length() > 0) {\n          return attributeValue.equals(namespacePrefix + \":\" + type);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 82,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 74,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642417221823,
            "program": "  public ClassNode resolveType(final Expression exp, final ClassNode current) {\n    Expression target =\n        exp instanceof VariableExpression ? getTarget((VariableExpression) exp) : exp;\n    ClassNode dif = (ClassNode) target.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n    if (dif != null) return dif;\n    ClassNode inferredType = (ClassNode) target.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n    if (inferredType != null) {\n      return inferredType;\n    }\n    return super.resolveType(exp, current);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 91,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 18,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642417596389,
            "program": "  public void stack(\n      Player player,\n      EditSession editSession,\n      LocalSession session,\n      @Selection Region region,\n      @Optional(\"1\") @Range(min = 1) int count,\n      @Optional(Direction.AIM) @Direction Vector direction,\n      @Switch('s') boolean moveSelection,\n      @Switch('a') boolean ignoreAirBlocks)\n      throws WorldEditException {\n    int affected = editSession.stackCuboidRegion(region, direction, count, !ignoreAirBlocks);\n\n    if (ignoreAirBlocks) {\n      try {\n        final Vector size = region.getMaximumPoint().subtract(region.getMinimumPoint());\n\n        final Vector shiftVector = direction.multiply(count * (Math.abs(direction.dot(size)) + 1));\n        region.shift(shiftVector);\n\n        session.getRegionSelector(player.getWorld()).learnChanges();\n        session.getRegionSelector(player.getWorld()).explainRegionAdjust(player, session);\n      } catch (RegionOperationException e) {\n        player.printError(e.getMessage());\n      }\n    }\n\n    player.print(affected + \" blocks changed. Undo with //undo\");\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 204,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 26,
            "lineNumberOfError": 17,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642417722118,
            "program": "  public static Class getMirrorOrFail(ResolvedJavaType type, ClassLoader loader)\n      throws NoClassDefFoundError {\n    ResolvedJavaType elementalType = getElementalType(type);\n    Class elementalClass;\n    if (elementalType.isPrimitive()) {\n      elementalClass = type.getKind().toJavaClass();\n    } else {\n      try {\n        elementalClass = Class.forName(toJavaName(elementalType), true, loader);\n      } catch (ClassNotFoundException e) {\n        throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);\n      }\n    }\n    if (type.isArray()) {\n      ResolvedJavaType t = type;\n      while (t.getComponentType() != null) {\n        elementalClass = Array.newInstance(elementalClass, 0).getClass();\n        t = t.getComponentType();\n      }\n    }\n    assert elementalClass != null : toJavaName(type);\n    return elementalClass;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 154,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 56,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642417997277,
            "program": "  public boolean connect(BluetoothDevice device) {\n    if (V) {\n      Log.d(TAG, \"PBAPClientProfile got connect request\");\n    }\n    if (mService == null) {\n      return false;\n    }\n    List<BluetoothDevice> srcs = getConnectedDevices();\n    if (srcs != null) {\n      for (BluetoothDevice src : srcs) {\n        if (src.equals(device)) {\n          // Connect to same device, Ignore it\n          Log.d(TAG, \"Ignoring Connect\");\n          return true;\n        }\n      }\n      for (BluetoothDevice src : srcs) {\n        mService.disconnect(src);\n      }\n    }\n    Log.d(TAG, \"PBAPClientProfile attempting to connect to \" + device.getAddress());\n\n    return mService.connect(device);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 124,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 33,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642418425402,
            "program": "  static Slice[] deepCopyAndCompact(Slice[] values, int positionOffset, int length) {\n    Slice[] newValues = Arrays.copyOfRange(values, positionOffset, positionOffset + length);\n    // Compact the slices. Use an IdentityHashMap because this could be very expensive otherwise.\n    Map<Slice, Slice> distinctValues = new IdentityHashMap<>();\n    for (int i = 0; i < newValues.length; i++) {\n      Slice slice = newValues[i];\n      if (slice == null) {\n        continue;\n      }\n      Slice distinct = distinctValues.get(slice);\n      if (distinct == null) {\n        distinct = Slices.copyOf(slice);\n        distinctValues.put(slice, distinct);\n      }\n      newValues[i] = distinct;\n    }\n    return newValues;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 134,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 76,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 16,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642419768780,
            "program": "  protected void sendLocallyUpdated(SyncData<TYPE> data) throws IOException {\n    int length;\n    length = data.localUpdated.getCount();\n    for (int i = 0; i < length; i++) {\n      data.localUpdated.moveToNext();\n      TYPE local = read(data.localUpdated);\n      try {\n        if (local.task == null) continue;\n\n        // if there is a conflict, merge\n        int remoteIndex = matchTask((ArrayList<TYPE>) data.remoteUpdated, local);\n        if (remoteIndex != -1) {\n          TYPE remote = data.remoteUpdated.get(remoteIndex);\n          push(local, remote);\n\n          // re-read remote task after merge\n          remote = pull(remote);\n          remote.task.setId(local.task.getId());\n          data.remoteUpdated.set(remoteIndex, remote);\n        } else {\n          push(local, null);\n        }\n      } catch (Exception e) {\n        handleException(\"sync-local-updated\", e, false); // $NON-NLS-1$\n      }\n      write(local);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 184,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 11,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642419887046,
            "program": "  public void collect(int doc) throws IOException {\n    int valuesDocID = leafOutcomeValue.docID();\n    if (valuesDocID < doc) {\n      valuesDocID = leafOutcomeValue.advance(valuesDocID);\n    }\n    int outcome;\n    if (valuesDocID == doc) {\n      outcome = (int) leafOutcomeValue.longValue();\n    } else {\n      outcome = 0;\n    }\n\n    outcome = trainingParams.positiveLabel == outcome ? 1 : 0;\n    if (outcome == 1) {\n      positiveDocsSet.set(context.docBase + doc);\n    }\n    docsSet.set(context.docBase + doc);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 108,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 23,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642419988123,
            "program": "  public LabelledDocument nextDocument() {\n    LabelledDocument document = new LabelledDocument();\n\n    document.setContent(backendIterator.nextSentence());\n    if (backendIterator instanceof LabelAwareSentenceIterator) {\n      List<String> labels = ((LabelAwareSentenceIterator) backendIterator).currentLabels();\n      if (labels != null) {\n        for (String label : labels) {\n          document.addLabel(label);\n          generator.storeLabel(label);\n        }\n      } else {\n        String label = ((LabelAwareSentenceIterator) backendIterator).currentLabel();\n        if (label != null) {\n          document.addLabel(label);\n          generator.storeLabel(label);\n        }\n      }\n    } else if (generator != null) document.addLabel(generator.nextLabel());\n\n    return document;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 142,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 28,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 27,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642420238204,
            "program": "  private static void addToResourceCollector(\n      AaptResourceCollector resourceCollector,\n      ResourceDirectory resourceDirectory,\n      Node node,\n      RType rType,\n      String resourceValue) {\n    String resourceName = sanitizeName(rType, resourceCollector, extractNameAttribute(node));\n    resourceCollector.addRTypeResourceName(rType, resourceName, resourceValue, resourceDirectory);\n    if (rType.equals(RType.STYLEABLE)) {\n\n      int count = 0;\n      for (Node attrNode = node.getFirstChild();\n          attrNode != null;\n          attrNode = attrNode.getNextSibling()) {\n        if (attrNode.getNodeType() != Node.ELEMENT_NODE || !attrNode.getNodeName().equals(\"attr\")) {\n          continue;\n        }\n\n        String rawAttrName = extractNameAttribute(attrNode);\n        String attrName = sanitizeName(rType, resourceCollector, rawAttrName);\n        resourceCollector.addResource(\n            RType.STYLEABLE,\n            IdType.INT,\n            String.format(\"%s_%s\", resourceName, attrName),\n            Integer.toString(count++));\n\n        if (!rawAttrName.startsWith(\"android:\")) {\n          resourceCollector.addIntResourceIfNotPresent(RType.ATTR, attrName);\n          resourceCollector.addRTypeResourceName(\n              RType.ATTR, rawAttrName, nodeToString(attrNode, true), resourceDirectory);\n        }\n      }\n\n      resourceCollector.addIntArrayResourceIfNotPresent(rType, resourceName, count);\n    } else {\n      resourceCollector.addIntResourceIfNotPresent(rType, resourceName);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 239,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 16,
            "lineNumberOfError": 15,
            "attempt": 2,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642420314263,
            "program": "  private void populateProviderWithExtraProps(PoolingConnectionProvider cp, Properties props)\n      throws Exception {\n    Properties copyProps = new Properties();\n    copyProps.putAll(props);\n\n    // Remove all the default properties first (they don't always match to setter name, and they are\n    // already\n    // been set!)\n    copyProps.remove(PoolingConnectionProvider.DB_DRIVER);\n    copyProps.remove(PoolingConnectionProvider.DB_URL);\n    copyProps.remove(PoolingConnectionProvider.DB_USER);\n    copyProps.remove(PoolingConnectionProvider.DB_PASSWORD);\n    copyProps.remove(PoolingConnectionProvider.DB_MAX_CONNECTIONS);\n    copyProps.remove(PoolingConnectionProvider.DB_VALIDATION_QUERY);\n    copyProps.remove(C3p0PoolingConnectionProvider.DB_VALIDATE_ON_CHECKOUT);\n    props.remove(PoolingConnectionProvider.POOLING_PROVIDER);\n    setBeanProps(cp.getDataSource(), copyProps);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 112,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 65,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642420483049,
            "program": "  private static Element topDeclaringType(Element element) {\n    Element enclosing = element.getEnclosingElement();\n    if (enclosing == null || enclosing.getKind() == ElementKind.PACKAGE) {\n      assert element.getKind() == ElementKind.CLASS || element.getKind() == ElementKind.INTERFACE;\n      return element;\n    }\n    return topDeclaringType(enclosing);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 67,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 2,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642420654878,
            "program": "  public <T extends Node> int insertChild(int index, final T child) {\r\n    for (Node p = this; p != null; p = p.getParent()) {\r\n      if (p == child) throw new GdxRuntimeException(\"Cannot add a parent as a child\");\r\n    }\r\n    Node p = child.getParent();\r\n    if (p != null && !p.removeChild(child))\r\n      throw new GdxRuntimeException(\"Could not remove child from its current parent\");\r\n    if (index < 0 || index >= children.size) {\r\n      index = children.size;\r\n      children.add(child);\r\n    } else children.insert(index, child);\r\n    child.parent = this;\r\n    return index;\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 128,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 49,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642420710166,
            "program": "  public static Component renderNonPrefixSeparatorComponent(Color backgroundColor) {\n    final JPanel panel = new JPanel(new BorderLayout());\n    final JSeparator separator = new JSeparator(SwingConstants.HORIZONTAL);\n    panel.add(separator, BorderLayout.CENTER);\n    if (!UIUtil.isUnderAquaBasedLookAndFeel()) {\n      panel.setBorder(new EmptyBorder(3, 0, 2, 0));\n    }\n    panel.setBackground(backgroundColor);\n    return panel;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 84,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 29,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642428062476,
            "program": "  private void validateCatch(Node n) {\n    validateNodeType(Token.CATCH, n);\n    validateChildCount(n);\n    Node caught = n.getFirstChild();\n    if (caught.isName()) {\n      validateName(caught);\n    } else if (n.isArrayPattern()) {\n      validateArrayPattern(Token.CATCH, caught);\n    } else {\n      validateObjectPattern(Token.CATCH, caught);\n    }\n    validateBlock(n.getLastChild());\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 88,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 14,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": 19,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642428135388,
            "program": "  private XmlTag addAnnotation(\n      @NotNull XmlTag rootTag,\n      @NotNull String ownerName,\n      @NotNull ExternalAnnotation annotation,\n      @Nullable XmlTag startTag) {\n    if (startTag == null) {\n      startTag = PsiTreeUtil.findChildOfType(rootTag, XmlTag.class);\n    }\n\n    XmlTag prevItem = null;\n    XmlTag curItem = startTag;\n\n    while (curItem != null) {\n      XmlTag addedItem = addAnnotation(rootTag, ownerName, annotation, curItem, prevItem);\n      if (addedItem != null) {\n        return addedItem;\n      }\n\n      prevItem = curItem;\n      curItem = PsiTreeUtil.getNextSiblingOfType(startTag, XmlTag.class);\n    }\n\n    return addItemTag(rootTag, prevItem, ownerName, annotation);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 121,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 1,
            "lineNumberOfError": 5,
            "attempt": 3,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642428244435,
            "program": "  private static boolean equalIncludingGenerics(ClassNode orig, ClassNode copy) {\n    if (orig == copy) return true;\n    if (orig.isGenericsPlaceHolder() != copy.isGenericsPlaceHolder()) return false;\n    if (!orig.equals(copy)) return false;\n    GenericsType[] gt1 = orig.getGenericsTypes();\n    GenericsType[] gt2 = orig.getGenericsTypes();\n    if ((gt1 == null || gt2 == null) && gt1 != gt2) return false;\n    if (gt1 == gt2) return true;\n    if (gt1.length != gt2.length) return false;\n    for (int i = 0; i < gt1.length; i++) {\n      if (!equalIncludingGenerics(gt1[i], gt2[i])) return false;\n    }\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 155,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 42,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": 18,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642428337784,
            "program": "  public static String createLambdaParameterListWithFormalTypes(\n      PsiType functionalInterfaceType,\n      PsiLambdaExpression lambdaExpression,\n      boolean checkApplicability) {\n    final PsiClassType.ClassResolveResult resolveResult =\n        PsiUtil.resolveGenericsClassInType(functionalInterfaceType);\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"(\");\n    final PsiMethod interfaceMethod =\n        LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);\n    LOG.assertTrue(interfaceMethod != null);\n    final PsiParameter[] parameters = interfaceMethod.getParameterList().getParameters();\n    final PsiParameter[] lambdaParameters = lambdaExpression.getParameterList().getParameters();\n    if (parameters.length != lambdaParameters.length) return null;\n    final PsiSubstitutor substitutor = LambdaUtil.getSubstitutor(interfaceMethod, resolveResult);\n    for (int i = 0; i < parameters.length; i++) {\n      PsiType psiType = substitutor.substitute(parameters[i].getType());\n      if (psiType == null) return null;\n      if (!PsiTypesUtil.isDenotableType(psiType, interfaceMethod)) {\n        return null;\n      }\n\n      buf.append(checkApplicability ? psiType.getPresentableText() : psiType.getCanonicalText())\n          .append(\" \")\n          .append(lambdaParameters[i].getName());\n      if (i < parameters.length - 1) {\n        buf.append(\", \");\n      }\n    }\n    buf.append(\")\");\n    return buf.toString();\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 253,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 61,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642428480698,
            "program": "  public void testAddGetDeleteClient() {\n    Client c = addClient(\"12345\", \"alice\");\n    Client c2 = provider.getClient(c.getClientId());\n    compareClients(c, c2);\n\n    c2.setClientSecret(\"567\");\n    provider.setClient(c2);\n    Client c22 = provider.getClient(c.getClientId());\n    compareClients(c2, c22);\n\n    provider.removeClient(c.getClientId());\n    Client c3 = provider.getClient(c.getClientId());\n    assertNull(c3);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 103,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 25,
            "lineNumberOfError": 5,
            "attempt": 3,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642428610519,
            "program": "  public TiledDrawable getTiledDrawable(String name) {\r\n    TiledDrawable tiled = optional(name, TiledDrawable.class);\r\n    if (tiled != null) return tiled;\r\n\r\n    Drawable drawable = optional(name, Drawable.class);\r\n    if (tiled != null) {\r\n      if (!(drawable instanceof TiledDrawable)) {\r\n        throw new GdxRuntimeException(\r\n            \"Drawable found but is not a TiledDrawable: \"\r\n                + name\r\n                + \", \"\r\n                + drawable.getClass().getName());\r\n      }\r\n      return tiled;\r\n    }\r\n\r\n    tiled = new TiledDrawable(getRegion(name));\r\n    add(name, tiled, TiledDrawable.class);\r\n    return tiled;\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 110,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 32,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642428736256,
            "program": "  private void registerMemoryView(@NotNull XDebugSession session) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    final XDebugProcess debugProcess = session.getDebugProcess();\n    final Project project = session.getProject();\n    final DebugProcess javaProcess =\n        DebuggerManager.getInstance(session.getProject())\n            .getDebugProcess(debugProcess.getProcessHandler());\n    if (javaProcess instanceof DebugProcessImpl) {\n      final DebugProcessImpl processImpl = (DebugProcessImpl) javaProcess;\n      final ClassesFilteredView classesFilteredView =\n          new ClassesFilteredView(debugProcess.getSession());\n      myDispatcher.addListener(visible -> classesFilteredView.setActive(visible), project);\n\n      final MemoryViewDebugProcessData data = new MemoryViewDebugProcessData(classesFilteredView);\n      final ToolWindow toolWindow = getToolWindow(processImpl.getProject());\n\n      classesFilteredView.setActive(toolWindow != null && toolWindow.isVisible());\n      processImpl.putUserData(MemoryViewDebugProcessData.KEY, data);\n\n      if (toolWindow != null) {\n        updateCurrentMemoryView(project, toolWindow);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 177,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 27,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642428904202,
            "program": "  private void addResolveListDedupe(\n      List<ResolvedComponentInfo> into, Intent intent, List<ResolveInfo> from) {\n    final int fromCount = from.size();\n    final int intoCount = into.size();\n    for (int i = 0; i < fromCount; i++) {\n      final ResolveInfo newInfo = from.get(i);\n      boolean found = false;\n      // Only loop to the end of into as it was before we started; no dupes in from.\n      for (int j = 0; j < intoCount; j++) {\n        final ResolvedComponentInfo rci = into.get(j);\n        if (isSameResolvedComponent(newInfo, rci)) {\n          found = true;\n          rci.add(intent, newInfo);\n          break;\n        }\n      }\n      if (!found) {\n        final ComponentName name =\n            new ComponentName(newInfo.activityInfo.packageName, newInfo.activityInfo.name);\n        final ResolvedComponentInfo rci = new ResolvedComponentInfo(name, intent, newInfo);\n        rci.setPinned(isComponentPinned(name));\n        into.add(rci);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 184,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 51,
            "lineNumberOfError": -2,
            "attempt": 4,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642439919216,
            "program": "  private void registerWebTestClient(ConfigurableApplicationContext context) {\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    if (beanFactory instanceof BeanDefinitionRegistry) {\n      registerWebTestClient((BeanDefinitionRegistry) beanFactory);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 34,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 71,
            "lineNumberOfError": 8,
            "attempt": 4,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642440061610,
            "program": "  public StreamSinkChannel create() {\n    final ChannelWrapper[] wrappers = wrappersUpdater.getAndSet(this, null);\n    if (wrappers == null) {\n      return null;\n    }\n    StreamSinkChannel oldChannel = firstChannel;\n    StreamSinkChannel channel = oldChannel;\n    for (ChannelWrapper wrapper : wrappers) {\n      channel = ((ChannelWrapper<StreamSinkChannel>) wrapper).wrap(oldChannel, exchange);\n      if (channel == null) {\n        channel = oldChannel;\n      }\n    }\n    exchange.startResponse();\n    return channel;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 92,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 63,
            "lineNumberOfError": -2,
            "attempt": 4,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642440410882,
            "program": "  public SortedDocValues getSorted(FieldInfo field) throws IOException {\n    final BinaryDocValues binary = getBinary(field);\n    final NumericDocValues ordinals = getNumeric(field, ords.get(field.number));\n    return new SortedDocValues() {\n\n      @Override\n      public int getOrd(int docID) {\n        return (int) ordinals.get(docID);\n      }\n\n      @Override\n      public void lookupOrd(int ord, BytesRef result) {\n        binary.get(ord, result);\n      }\n\n      @Override\n      public int getValueCount() {\n        return binary.size();\n      }\n\n      @Override\n      public int size() {\n        return ordinals.size();\n      }\n    };\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 123,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 73,
            "lineNumberOfError": -2,
            "attempt": 4,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642440667390,
            "program": "  public static SegmentReplicantLookup make(DruidCluster cluster) {\n    final Table<String, String, Integer> segmentsInCluster = HashBasedTable.create();\n    final Table<String, String, Integer> loadingSegments = HashBasedTable.create();\n\n    for (MinMaxPriorityQueue<ServerHolder> serversByType : cluster.getSortedServersByTier()) {\n      for (ServerHolder serverHolder : serversByType) {\n        DruidServer server = serverHolder.getServer();\n\n        for (DataSegment segment : server.getSegments().values()) {\n          Integer numReplicants = segmentsInCluster.get(segment.getIdentifier(), server.getTier());\n          if (numReplicants == null) {\n            numReplicants = 0;\n          }\n          segmentsInCluster.put(segment.getIdentifier(), server.getTier(), ++numReplicants);\n        }\n\n        // Also account for queued segments\n        for (DataSegment segment : serverHolder.getPeon().getSegmentsToLoad()) {\n          Integer numReplicants = loadingSegments.get(segment.getIdentifier(), server.getTier());\n          if (numReplicants == null) {\n            numReplicants = 0;\n          }\n          loadingSegments.put(segment.getIdentifier(), server.getTier(), ++numReplicants);\n        }\n      }\n    }\n\n    return new SegmentReplicantLookup(segmentsInCluster, loadingSegments);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 225,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 67,
            "lineNumberOfError": 18,
            "attempt": 4,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642440894633,
            "program": "  private String substituteKeywords(\r\n      String message, String dialNumber, String telVoice, String meetingName) {\r\n    String welcomeMessage = message;\r\n\r\n    String DIAL_NUM = \"%%DIALNUM%%\";\r\n    String CONF_NUM = \"%%CONFNUM%%\";\r\n    String CONF_NAME = \"%%CONFNAME%%\";\r\n    ArrayList<String> keywordList = new ArrayList<String>();\r\n    keywordList.add(DIAL_NUM);\r\n    keywordList.add(CONF_NUM);\r\n    keywordList.add(CONF_NAME);\r\n\r\n    Iterator<String> itr = keywordList.iterator();\r\n    while (itr.hasNext()) {\r\n      String keyword = (String) itr.next();\r\n      if (keyword.equals(DIAL_NUM)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(DIAL_NUM, dialNumber);\r\n      } else if (keyword.equals(CONF_NUM)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(CONF_NUM, telVoice);\r\n      } else if (keyword.equals(CONF_NAME)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(CONF_NAME, meetingName);\r\n      }\r\n    }\r\n    return welcomeMessage;\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 178,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 43,
            "lineNumberOfError": 3,
            "attempt": 4,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642441021590,
            "program": "  public boolean cancelInstalledTask(OptimizedCallTarget optimizedCallTarget) {\n    Future<?> codeTask = this.compilations.get(optimizedCallTarget);\n    if (codeTask != null && isCompiling(optimizedCallTarget)) {\n      this.compilations.remove(codeTask);\n      return codeTask.cancel(true);\n    }\n    return false;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 57,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 36,
            "lineNumberOfError": -2,
            "attempt": 4,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642441176517,
            "program": "  private void readLinkedResources() {\n    for (Node linkNode : getChildren(findFirstChildNamed(getXml(), \"linkedResources\"), \"link\")) {\n      Node nameNode = findFirstChildNamed(linkNode, \"name\");\n      Node typeNode = findFirstChildNamed(linkNode, \"type\");\n      Node locationNode = findFirstChildNamed(linkNode, \"location\");\n      Node locationUriNode = findFirstChildNamed(linkNode, \"locationURI\");\n      linkedResources.add(\n          new Link(\n              nameNode != null ? nameNode.text() : null,\n              typeNode != null ? typeNode.text() : null,\n              locationNode != null ? locationNode.text() : null,\n              locationUriNode != null ? locationUriNode.text() : null));\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 125,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 19,
            "lineNumberOfError": 3,
            "attempt": 4,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642441291164,
            "program": "  private void addToRealms(Collection<Realm> realms, RealmFactory factory) {\n    LifecycleUtils.init(factory);\n    Collection<Realm> factoryRealms = factory.getRealms();\n    if (!CollectionUtils.isEmpty(realms)) {\n      realms.addAll(factoryRealms);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 53,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "354257312-1642420119458": [
        {
            "ProgrammID": 52,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642420317896,
            "program": "  public Entity createEntity(Location location, BaseEntity state) {\n    Entity entity = super.createEntity(location, state);\n    if (entity != null) {\n      changeSet.add(new EntityCreate(location, state, entity));\n    }\n    return entity;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 50,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 36,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642420368794,
            "program": "  private void readLinkedResources() {\n    for (Node linkNode : getChildren(findFirstChildNamed(getXml(), \"linkedResources\"), \"link\")) {\n      Node nameNode = findFirstChildNamed(linkNode, \"name\");\n      Node typeNode = findFirstChildNamed(linkNode, \"type\");\n      Node locationNode = findFirstChildNamed(linkNode, \"location\");\n      Node locationUriNode = findFirstChildNamed(linkNode, \"locationURI\");\n      linkedResources.add(\n          new Link(\n              nameNode != null ? nameNode.text() : null,\n              typeNode != null ? typeNode.text() : null,\n              locationNode != null ? locationNode.text() : null,\n              locationUriNode != null ? locationUriNode.text() : null));\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 125,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 34,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642420389942,
            "program": "  public float dst2(float x, float y, float z) {\r\n    final float a = x - this.x;\r\n    final float b = y - this.y;\r\n    final float c = z - this.z;\r\n\r\n    return a * a + b * b + c * c;\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 58,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 17,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642420431395,
            "program": "  public void execute(BstEntry context) {\n    Stack<Object> stack = vm.getStack();\n\n    if (stack.size() < 2) {\n      throw new VMException(\"Not enough operands on stack for operation text.prefix$\");\n    }\n    Object o1 = stack.pop();\n    Object o2 = stack.pop();\n\n    if (!(o1 instanceof Integer)) {\n      vm.warn(\"An integer is needed as first parameter to text.prefix$\");\n      stack.push(\"\");\n      return;\n    }\n    if (!(o2 instanceof String)) {\n      vm.warn(\"A string is needed as second parameter to text.prefix$\");\n      stack.push(\"\");\n      return;\n    }\n\n    stack.push(BibtexTextPrefix.textPrefix((Integer) o1, (String) o2, vm));\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 134,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 5,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642420459971,
            "program": "  public static void removeChildren(ASTNode parent, @NotNull ASTNode first, @NotNull ASTNode last) {\n    final boolean tailingElement =\n        last.getStartOffset() + last.getTextLength()\n            == parent.getStartOffset() + parent.getTextLength();\n    final boolean forceReformat = needToForceReformat(parent, first, last);\n    saveWhitespacesInfo(first);\n\n    TreeElement child = (TreeElement) first;\n    while (child != null) {\n      // checkForOuters(child);\n      if (child == last) break;\n      child = child.getTreeNext();\n    }\n    assert child == last\n        : last + \" is not a successor of \" + first + \" in the .getTreeNext() chain\";\n\n    final ASTNode prevLeaf = TreeUtil.prevLeaf(first);\n    final ASTNode nextLeaf = TreeUtil.nextLeaf(first);\n    parent.removeRange(first, last.getTreeNext());\n    ASTNode nextLeafToAdjust = nextLeaf;\n    if (nextLeafToAdjust != null && prevLeaf != null && nextLeafToAdjust.getTreeParent() == null) {\n      // next element has invalidated\n      nextLeafToAdjust = prevLeaf.getTreeNext();\n    }\n    makePlaceHolderBetweenTokens(prevLeaf, nextLeafToAdjust, forceReformat, tailingElement);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 190,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 39,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642420497155,
            "program": "  private String resolvePlaceholders(String value) {\n    StringBuffer result = new StringBuffer();\n    Matcher matcher = PLACEHOLDER_PATTERN.matcher(value);\n\n    while (matcher.find()) {\n      String placeholder = matcher.group(1);\n      String replacement =\n          placeholder.startsWith(\"env.\")\n              ? environmentVariables.get(placeholder.substring(4))\n              : systemProperties.get(placeholder);\n      if (replacement == null) {\n        throw new CannotLocateLocalMavenRepositoryException(\n            String.format(\"Cannot resolve placeholder '%s' in value '%s'\", placeholder, value));\n      }\n      matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));\n    }\n    matcher.appendTail(result);\n\n    return result.toString();\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 128,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 71,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642420538154,
            "program": "  public StreamSinkChannel create() {\n    final ChannelWrapper[] wrappers = wrappersUpdater.getAndSet(this, null);\n    if (wrappers == null) {\n      return null;\n    }\n    StreamSinkChannel oldChannel = firstChannel;\n    StreamSinkChannel channel = oldChannel;\n    for (ChannelWrapper wrapper : wrappers) {\n      channel = ((ChannelWrapper<StreamSinkChannel>) wrapper).wrap(oldChannel, exchange);\n      if (channel == null) {\n        channel = oldChannel;\n      }\n    }\n    exchange.startResponse();\n    return channel;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 92,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 37,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642420544093,
            "program": "  public int read(byte[] b, int off, int len) {\n    int toRead = len > input.remaining() ? input.remaining() : len;\n    input.get(b, off, toRead);\n    return toRead;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 50,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        }
    ],
    "1383930928-1642420746524": [
        {
            "ProgrammID": 63,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642421306585,
            "program": "  public SortedDocValues getSorted(FieldInfo field) throws IOException {\n    final BinaryDocValues binary = getBinary(field);\n    final NumericDocValues ordinals = getNumeric(field, ords.get(field.number));\n    return new SortedDocValues() {\n\n      @Override\n      public int getOrd(int docID) {\n        return (int) ordinals.get(docID);\n      }\n\n      @Override\n      public void lookupOrd(int ord, BytesRef result) {\n        binary.get(ord, result);\n      }\n\n      @Override\n      public int getValueCount() {\n        return binary.size();\n      }\n\n      @Override\n      public int size() {\n        return ordinals.size();\n      }\n    };\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 123,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 46,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642421521021,
            "program": "  public void validate_shouldPassIfTheConceptWithADuplicateNameIsRetired() throws Exception {\r\n    Context.setLocale(new Locale(\"en\"));\r\n    Concept concept = Context.getConceptService().getConcept(5497);\r\n    concept.setRetired(true);\r\n    Context.getConceptService().saveConcept(concept);\r\n\r\n    String duplicateName = concept.getFullySpecifiedName(Context.getLocale()).getName();\r\n    Concept newConcept = ConceptTest.createMockConcept(2, Context.getLocale());\r\n    ConceptName anotherConceptName =\r\n        ConceptNameTest.createMockConceptName(3, Context.getLocale(), null, true);\r\n    anotherConceptName.setName(duplicateName);\r\n    newConcept.addName(anotherConceptName);\r\n    Errors errors = new BindException(newConcept, \"concept\");\r\n    new ConceptValidator().validate(newConcept, errors);\r\n    Assert.assertEquals(false, errors.hasErrors());\r\n  }\r\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 156,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 48,
            "lineNumberOfError": 23,
            "attempt": 1,
            "expectedAnswer": 23,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642421650416,
            "program": "  private static void populateOrderEntries(\n      Module module,\n      Condition<Library> condition,\n      ArrayList<Library> libraries,\n      boolean exportedOnly,\n      Set<Module> visited) {\n    if (!visited.add(module)) {\n      return;\n    }\n\n    for (OrderEntry entry : ModuleRootManager.getInstance(module).getOrderEntries()) {\n      if (entry instanceof LibraryOrderEntry) {\n        LibraryOrderEntry libEntry = (LibraryOrderEntry) entry;\n        if (exportedOnly && !libEntry.isExported()) {\n          continue;\n        }\n\n        Library library = libEntry.getLibrary();\n        if (condition.value(library)) {\n          libraries.add(library);\n        }\n      } else if (entry instanceof ModuleOrderEntry) {\n        final Module dep = ((ModuleOrderEntry) entry).getModule();\n        if (module != null) {\n          populateOrderEntries(dep, condition, libraries, true, visited);\n        }\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 166,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 44,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642421786734,
            "program": "  public static Function fromSignature(String funcName, String[] paramTypes, String[] resultTypes) {\n    Function ret = new Function();\n    ret.name = funcName;\n    ret.constant = false;\n    ret.type = FunctionType.function;\n    ret.inputs = new Param[paramTypes.length];\n    for (int i = 0; i < paramTypes.length; i++) {\n      ret.inputs[i] = new Param();\n      ret.inputs[i].name = \"param\" + i;\n      ret.inputs[i].type = Type.getType(paramTypes[i]);\n    }\n    ret.outputs = new Param[resultTypes.length];\n    for (int i = 0; i < resultTypes.length; i++) {\n      ret.outputs[i] = new Param();\n      ret.outputs[i].name = \"res\" + i;\n      ret.outputs[i].type = Type.getType(resultTypes[i]);\n    }\n    return ret;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 199,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 58,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642421869634,
            "program": "  public void setBindingMatch(BindingMatch<?> bindingMatch) {\n    if (bindingMatch == null) return;\n    UriPattern pattern = bindingMatch.matched();\n    if (pattern == null) return;\n    Map<String, Object> combinedDimensions = new HashMap<>(requestDimensions);\n    combinedDimensions.put(Metrics.HANDLER_DIMENSION, bindingMatch.toString());\n    this.context = metric.createContext(combinedDimensions);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 79,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 31,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642421910618,
            "program": "  private DeclarationDescriptor resolveParentDescriptor(PsiClass psiClass) {\n    PsiClass containingClass = psiClass.getContainingClass();\n    if (containingClass != null) {\n      return resolveClass(containingClass);\n    }\n\n    PsiJavaFile containingFile = (PsiJavaFile) psiClass.getContainingFile();\n    String packageName = containingFile.getPackageName();\n    return resolveNamespace(packageName);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 59,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 35,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642422025313,
            "program": "  public static AbstractOperation reconstruct(Project project, JSONObject obj) throws Exception {\n    JSONObject engineConfig = obj.getJSONObject(\"engineConfig\");\n\n    JSONObject match = obj.getJSONObject(\"match\");\n\n    JSONArray types = match.getJSONArray(\"types\");\n    String[] typeIDs = new String[types.length()];\n    for (int i = 0; i < typeIDs.length; i++) {\n      typeIDs[i] = types.getString(i);\n    }\n\n    return new ReconMatchSpecificTopicOperation(\n        engineConfig,\n        obj.getString(\"columnName\"),\n        new ReconCandidate(match.getString(\"id\"), match.getString(\"name\"), typeIDs, 100),\n        obj.getString(\"identifierSpace\"),\n        obj.getString(\"schemaSpace\"));\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 140,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 72,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642422074423,
            "program": "  public final ExitStatus run(String... args) throws Exception {\n    String[] argsToUse = args.clone();\n    for (int i = 0; i < argsToUse.length; i++) {\n      if (\"-cp\".equals(argsToUse[i])) {\n        argsToUse[i] = \"--cp\";\n      }\n    }\n    OptionSet options = getParser().parse(argsToUse);\n    return run(options);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 81,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1390346539-1642424184440": [
        {
            "ProgrammID": 45,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": 9,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642424591210,
            "program": "  private void notifyDelete(String filePath) {\n    String newFilePath = stripFileProtocol(filePath);\n    int result =\n        this.cordova\n            .getActivity()\n            .getContentResolver()\n            .delete(\n                MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                MediaStore.Images.Media.DATA + \" = ?\",\n                new String[] {filePath});\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 61,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 8,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642424732931,
            "program": "  private static void internalCopyDir(File src, File dest, boolean isOverride)\r\n      throws IORuntimeException {\r\n    if (false == dest.exists()) {\r\n      dest.mkdirs();\r\n    } else if (dest.isFile()) {\r\n      throw new IORuntimeException(\r\n          StrUtil.format(\r\n              \"Src [{}] is a directory but dest [{}] is a file!\", src.getPath(), dest.getPath()));\r\n    }\r\n\r\n    final String files[] = src.list();\r\n    for (String file : files) {\r\n      File srcFile = new File(src, file);\r\n      File destFile = new File(dest, file);\r\n      // \u9012\u5f52\u590d\u5236\r\n      if (srcFile.isDirectory()) {\r\n        internalCopyDir(srcFile, destFile, isOverride);\r\n      } else {\r\n        internalCopyFile(srcFile, destFile, isOverride);\r\n      }\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 145,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 15,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642424929903,
            "program": "  protected PageDTO evaluatePageRules(\n      List<PageDTO> pageDTOList, Locale locale, Map<String, Object> ruleDTOs) {\n    if (pageDTOList == null) {\n      return NULL_PAGE;\n    }\n\n    // First check to see if we have a page that matches on the full locale.\n    for (PageDTO page : pageDTOList) {\n      if (locale != null && locale.getLocaleCode() != null) {\n        if (locale.getLocaleCode().equals(page.getLocaleCode())) {\n          if (passesPageRules(page, ruleDTOs)) {\n            return page;\n          }\n        }\n      }\n    }\n\n    // Otherwise, we look for a match using just the language.\n    for (PageDTO page : pageDTOList) {\n      if (passesPageRules(page, ruleDTOs)) {\n        return page;\n      }\n    }\n\n    return NULL_PAGE;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 118,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 47,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642425001941,
            "program": "  public static void reparseFiles(\n      @NotNull final Project project,\n      @NotNull final Collection<VirtualFile> files,\n      final boolean includeOpenFiles) {\n    LinkedHashSet<VirtualFile> fileSet = new LinkedHashSet<VirtualFile>(files);\n    if (includeOpenFiles) {\n      for (VirtualFile open : FileEditorManager.getInstance(project).getOpenFiles()) {\n        if (!fileSet.contains(open)) {\n          fileSet.add(open);\n        }\n      }\n    }\n    FileContentUtilCore.reparseFiles(fileSet);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 91,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 3,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642425184488,
            "program": "  protected Class<?>[] getInterfaces(Object object) {\n    List<Class<?>> interfaceClasses = new ArrayList<Class<?>>();\n\n    Class<?> clazz = object.getClass();\n\n    getInterfaces(interfaceClasses, clazz);\n\n    Class<?> superClazz = clazz.getSuperclass();\n\n    while (superClazz != null) {\n      getInterfaces(interfaceClasses, superClazz);\n\n      superClazz = clazz.getSuperclass();\n    }\n\n    return interfaceClasses.toArray(new Class<?>[interfaceClasses.size()]);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 107,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 53,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642425285992,
            "program": "  public final DBObject findOne(DBObject o, DBObject fields) {\n    Iterator<DBObject> i = __find(o, fields, 0, -1, 0, getOptions());\n    DBObject obj = (i == null ? null : i.next());\n    if (obj != null && (fields != null && fields.keySet().size() > 0)) {\n      obj.markAsPartialObject();\n    }\n    return obj;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 89,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 21,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642425409059,
            "program": "  private void cancelEndOfWindowAndGarbageCollectionTimers(\n      ReduceFn<?, ?, ?, W>.Context directContext) {\n    WindowTracing.debug(\n        \"ReduceFnRunner.cancelEndOfWindowAndGarbageCollectionTimers: Deleting timers for \"\n            + \"key:{}; window:{} where inputWatermark:{}; outputWatermark:{}\",\n        key,\n        directContext.window(),\n        timerInternals.currentInputWatermarkTime(),\n        timerInternals.currentOutputWatermarkTime());\n    Instant eow = directContext.window().maxTimestamp();\n    directContext.timers().deleteTimer(eow, TimeDomain.EVENT_TIME);\n    Instant gc = garbageCollectionTime(directContext.window());\n    if (gc.isAfter(eow)) {\n      directContext.timers().deleteTimer(eow, TimeDomain.EVENT_TIME);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 115,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 24,
            "lineNumberOfError": 19,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642425699028,
            "program": "  private static GlobalInspectionToolWrapper getProblemDescriptionProcessor(\n      @NotNull final GlobalInspectionToolWrapper toolWrapper,\n      final Map<String, DescriptorProviderInspection> wrappersMap) {\n\n    return new GlobalInspectionToolWrapper(toolWrapper.getTool()) {\n      @Override\n      public void addProblemElement(\n          RefEntity refEntity, CommonProblemDescriptor... commonProblemDescriptors) {\n        for (CommonProblemDescriptor problemDescriptor : commonProblemDescriptors) {\n          if (problemDescriptor instanceof ProblemDescriptor) {\n            String problemGroup = ((ProblemDescriptor) problemDescriptor).getProblemGroup();\n\n            if (problemGroup != null) {\n              DescriptorProviderInspection dummyWrapper = wrappersMap.get(problemGroup);\n\n              if (dummyWrapper != null) { // Else it's switched off\n                dummyWrapper.addProblemElement(refEntity, problemDescriptor);\n              }\n            } else {\n              toolWrapper.addProblemElement(refEntity, problemDescriptor);\n            }\n          }\n        }\n      }\n    };\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 128,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "714815404-1642428357899": [
        {
            "ProgrammID": 59,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642428885057,
            "program": "  public PyQualifiedName append(PyQualifiedName qName) {\n    PyQualifiedName result = new PyQualifiedName(myComponents.size() + qName.getComponentCount());\n    result.myComponents.addAll(myComponents);\n    result.myComponents.addAll(result.getComponents());\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 53,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 13,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642428938661,
            "program": "  public Object processInvocation(InterceptorContext interceptorContext) throws Exception {\n    SingletonComponent singletonComponent =\n        getComponent(interceptorContext, SingletonComponent.class);\n    // get the component instance\n    ComponentInstance singletonComponentInstance = singletonComponent.getComponentInstance();\n    if (singletonComponent == null) {\n      throw MESSAGES.componentInstanceNotAvailable(interceptorContext);\n    }\n    interceptorContext.putPrivateData(ComponentInstance.class, singletonComponentInstance);\n    return interceptorContext.proceed();\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 66,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 30,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642429022894,
            "program": "  public final boolean blacklist(int index, long blacklistDurationMs) {\n    long nowMs = SystemClock.elapsedRealtime();\n    boolean canBlacklist = isBlacklisted(index, nowMs);\n    for (int i = 0; i < length && !canBlacklist; i++) {\n      canBlacklist = i != index && !isBlacklisted(i, nowMs);\n    }\n    if (!canBlacklist) {\n      return false;\n    }\n    blacklistUntilTimes[index] = Math.max(blacklistUntilTimes[index], nowMs + blacklistDurationMs);\n    return true;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 97,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 51,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642429107669,
            "program": "  private void registerWebTestClient(ConfigurableApplicationContext context) {\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    if (beanFactory instanceof BeanDefinitionRegistry) {\n      registerWebTestClient((BeanDefinitionRegistry) beanFactory);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 34,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 77,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642429242240,
            "program": "  protected static FrequencySet<String> combineMax(FrequencySet<String> a, FrequencySet<String> b) {\n    FrequencySet<String> result = combineAndClip(a, b, 1);\n    for (Map.Entry<String, MutableInt> entry : a.entrySet()) {\n      result.get(entry.getKey()).v = entry.getValue().v;\n    }\n\n    for (Map.Entry<String, MutableInt> entry : a.entrySet()) {\n      MutableInt slot = result.get(entry.getKey());\n      slot.v = Math.max(slot.v, entry.getValue().v);\n    }\n\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 136,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 0,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642429319633,
            "program": "  protected void assertSupportingTokens(Collection<PolicyAssertion> suppTokens) {\n    if (suppTokens == null) {\n      return;\n    }\n    for (PolicyAssertion pa : suppTokens) {\n      if (pa instanceof SupportingToken) {\n        for (Token token : ((SupportingToken) pa).getTokens()) {\n          this.policyAsserted(token);\n        }\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 64,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 43,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642429414873,
            "program": "  public boolean cancelInstalledTask(OptimizedCallTarget optimizedCallTarget) {\n    Future<?> codeTask = this.compilations.get(optimizedCallTarget);\n    if (codeTask != null && isCompiling(optimizedCallTarget)) {\n      this.compilations.remove(codeTask);\n      return codeTask.cancel(true);\n    }\n    return false;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 57,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 22,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642429577602,
            "program": "  void reorderProbation(Node<K, V> node) {\n    if (!accessOrderProbationDeque().contains(node)) {\n      // Ignore stale accesses for an entry that is no longer present\n      return;\n    } else if (node.getPolicyWeight() > mainProtectedMaximum()) {\n      return;\n    }\n\n    long mainProtectedWeightedSize = mainProtectedWeightedSize() + node.getPolicyWeight();\n    accessOrderProbationDeque().remove(node);\n    accessOrderProtectedDeque().add(node);\n    node.makeMainProtected();\n\n    long mainProtectedMaximum = mainProtectedMaximum();\n    while (mainProtectedWeightedSize > mainProtectedMaximum) {\n      Node<K, V> demoted = accessOrderProtectedDeque().pollFirst();\n      if (demoted == null) {\n        break;\n      }\n      demoted.makeMainProbation();\n      accessOrderProbationDeque().add(demoted);\n      mainProtectedWeightedSize -= demoted.getPolicyWeight();\n    }\n\n    lazySetMainProtectedWeightedSize(mainProtectedWeightedSize);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 152,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "614954651-1642429500427": [
        {
            "ProgrammID": 68,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642429852706,
            "program": "  public void afterExecution(Action action, Token token, MetadataHandler metadataHandler)\n      throws IOException {\n    Preconditions.checkArgument(token != null);\n    String key = token.cacheKey;\n    if (actionCache.get(key) != null) {\n      // This cache entry has already been updated by a shared action. We don't need to do it again.\n      return;\n    }\n    ActionCache.Entry entry = actionCache.createEntry(action.getKey());\n    for (Artifact output : action.getOutputs()) {\n      // Remove old records from the cache if they used different key.\n      String execPath = output.getExecPathString();\n      if (!key.equals(execPath)) {\n        actionCache.remove(key);\n      }\n      if (!metadataHandler.artifactOmitted(output)) {\n        // Output files *must* exist and be accessible after successful action execution.\n        Metadata metadata = metadataHandler.getMetadata(output);\n        Preconditions.checkState(metadata != null);\n        entry.addFile(output.getExecPath(), metadata);\n      }\n    }\n    for (Artifact input : action.getInputs()) {\n      entry.addFile(input.getExecPath(), metadataHandler.getMetadataMaybe(input));\n    }\n    entry.getFileDigest();\n    actionCache.put(key, entry);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 195,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 78,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642429866750,
            "program": "  public static synchronized PrivateDataManager getInstanceFor(XMPPConnection connection) {\n    PrivateDataManager privateDataManager = instances.get(connection);\n    if (connection == null) {\n      privateDataManager = new PrivateDataManager(connection);\n    }\n    return privateDataManager;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 40,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 55,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642429902212,
            "program": "  public boolean areReferencesUsageCorrelated(\n      @NotNull LightRef ref1, @NotNull LightRef ref2, int correlationThreshold) {\n    try {\n      myReadDataLock.lock();\n      if (myReader == null) throw new ReferenceIndexUnavailableException();\n      try {\n        final TIntHashSet ids1 = myReader.getAllContainingFileIds(ref1);\n        final TIntHashSet ids2 = myReader.getAllContainingFileIds(ref2);\n        final TIntHashSet intersection = intersection(ids1, ids2);\n        if ((ids1.size() - intersection.size()) * correlationThreshold < intersection.size()) {\n          return true;\n        }\n        if ((ids1.size() - intersection.size()) * correlationThreshold < intersection.size()) {\n          return true;\n        }\n        return false;\n      } catch (Exception e) {\n        //noinspection ConstantConditions\n        return onException(e, \"correlation\");\n      }\n    } finally {\n      myReadDataLock.unlock();\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 161,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 12,
            "lineNumberOfError": 22,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642430054440,
            "program": "  public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n    AArch64Kind kind = (AArch64Kind) expectedValue.getPlatformKind();\n    assert kind.isInteger();\n    final int size = kind.getSizeInBytes() * Byte.SIZE;\n\n    Register address = asRegister(addressValue);\n    Register result = asRegister(resultValue);\n    Register newVal = asRegister(newValue);\n    if (AArch64LIRFlagsVersioned.useLSE(masm.target.arch)) {\n      Register expected = asRegister(expectedValue);\n      masm.mov(size, result, expected);\n      masm.cas(size, expected, newVal, address, true /* acquire */, true /* release */);\n      AArch64Compare.gpCompare(masm, resultValue, expectedValue);\n    } else {\n      // We could avoid using a scratch register here, by reusing resultValue for the\n      // stlxr success flag and issue a mov resultValue, expectedValue in case of success\n      // before returning.\n      Register scratch = asRegister(scratchValue);\n      Label retry = new Label();\n      Label fail = new Label();\n      masm.bind(retry);\n      masm.ldaxr(size, result, address);\n      AArch64Compare.gpCompare(masm, resultValue, expectedValue);\n      masm.branchConditionally(AArch64Assembler.ConditionFlag.NE, fail);\n      masm.stlxr(size, scratch, newVal, address);\n      // if scratch == 0 then write successful, else retry.\n      masm.cbnz(32, scratch, retry);\n      masm.bind(fail);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 231,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 7,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642430117416,
            "program": "  public MutableVariable getNodeByPath(\n      @NotNull MutableVariable root, @NotNull List<String> relativeNodePath) {\n    MutableVariable localRoot = root;\n    for (int i = 0; i < relativeNodePath.size(); i++) {\n      String path = relativeNodePath.get(i);\n      if (localRoot != null) {\n        List<MutableVariable> variables = new ArrayList<>(localRoot.getVariables());\n        localRoot = null;\n        for (int j = 0; j < variables.size(); j++) {\n          MutableVariable variable = variables.get(j);\n          if (variable.getName().equals(path)) {\n            localRoot = variable;\n            break;\n          }\n        }\n\n        if (i == (relativeNodePath.size() - 1)) {\n          return localRoot;\n        }\n      }\n    }\n    return null;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 157,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 60,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642430183236,
            "program": "  public void test() {\n    QUser user = new QUser(\"user\");\n    QUser user2 = new QUser(\"user2\");\n    QDepartment department = new QDepartment(\"department\");\n    QCompany company = new QCompany(\"company\");\n\n    // superiorId -> id\n    query().from(user).innerJoin(user.superiorId(), user.id());\n\n    // superiorId -> superiorId\n    query().from(user).innerJoin(user.superiorId(), user2.superiorId());\n\n    // department -> id / company -> id\n    query()\n        .from(user)\n        .innerJoin(user.department(), department.id())\n        .innerJoin(department.company(), company.id());\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 130,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 9,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": 1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642430193383,
            "program": "  public static TRef intern(String moduleName, String name) throws Exception {\n    Module module = findModule(name);\n    if (module == null) throw new Exception(String.format(\"Module %s not found\", moduleName));\n    return module.intern(name);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 51,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 10,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642430389592,
            "program": "  private static @Nullable Library findModuleLibrary(\n      Module module,\n      final @NotNull ModulesProvider provider,\n      @NotNull String url,\n      Set<Module> visited) {\n    if (!visited.add(module)) {\n      return null;\n    }\n\n    ModuleRootModel rootModel = provider.getRootModel(module);\n    OrderEntry[] orderEntries = rootModel.getOrderEntries();\n    for (OrderEntry orderEntry : orderEntries) {\n      if (orderEntry instanceof LibraryOrderEntry) {\n        LibraryOrderEntry libraryOrderEntry = ((LibraryOrderEntry) orderEntry);\n        Library library = libraryOrderEntry.getLibrary();\n        if (library == null) continue;\n        String[] urls = library.getUrls(OrderRootType.CLASSES);\n        if (urls.length != 1) continue;\n        if (Comparing.strEqual(urls[0], url)) return library;\n      } else if (orderEntry instanceof ModuleOrderEntry) {\n        final Module dependency = ((ModuleOrderEntry) orderEntry).getModule();\n        if (dependency == null) {\n          continue;\n        }\n        final Library library = findModuleLibrary(dependency, provider, url, visited);\n        if (library != null) {\n          return library;\n        }\n      }\n    }\n    return null;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 213,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1353348977-1642428729231": [
        {
            "ProgrammID": 62,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642431428355,
            "program": "  public static FloatingNode canonicalizeBoxing(\n      BoxNode box, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection) {\n    ValueNode value = box.getValue();\n    if (value.isConstant()) {\n      JavaConstant sourceConstant = value.asJavaConstant();\n      JavaConstant boxedConstant = constantReflection.boxPrimitive(sourceConstant);\n      if (boxedConstant != null && boxedConstant.getKind() == box.getBoxingKind()) {\n        return ConstantNode.forConstant(boxedConstant, metaAccess, box.graph());\n      }\n    }\n    return null;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,test",
            "token": 93,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 50,
            "lineNumberOfError": 6,
            "attempt": 2,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642431512357,
            "program": "  protected void assertArrayEquals(Object[] expected, Object[] value) {\n    String message =\n        \"expected array: \"\n            + InvokerHelper.toString(expected)\n            + \" value array: \"\n            + InvokerHelper.toString(value);\n    assertNotNull(message + \": expected should not be null\", value);\n    assertNotNull(message + \": value should not be null\", value);\n    assertEquals(message, expected.length, value.length);\n    for (int i = 0, size = expected.length; i < size; i++) {\n      assertEquals(\"value[\" + i + \"] when \" + message, expected[i], value[i]);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,test",
            "token": 111,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 72,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642431624414,
            "program": "  public final ExitStatus run(String... args) throws Exception {\n    String[] argsToUse = args.clone();\n    for (int i = 0; i < argsToUse.length; i++) {\n      if (\"-cp\".equals(argsToUse[i])) {\n        argsToUse[i] = \"--cp\";\n      }\n    }\n    OptionSet options = getParser().parse(argsToUse);\n    return run(options);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,test",
            "token": 81,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 37,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642431739168,
            "program": "  public int read(byte[] b, int off, int len) {\n    int toRead = len > input.remaining() ? input.remaining() : len;\n    input.get(b, off, toRead);\n    return toRead;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,test",
            "token": 50,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 40,
            "lineNumberOfError": 8,
            "attempt": 2,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642432027269,
            "program": "  protected void closeReport() {\r\n    int counter = 1;\r\n\r\n    if (!sinks.isEmpty()) {\r\n      for (Iterator i = sinks.iterator(); i.hasNext(); ) {\r\n        MultiPageSink currentSink = (MultiPageSink) i.next();\r\n\r\n        currentSink.paragraph();\r\n        for (Iterator j = sinks.iterator(); i.hasNext(); ) {\r\n          if (counter > 1) {\r\n            currentSink.text(\"&nbsp;\");\r\n          }\r\n          MultiPageSink sink = (MultiPageSink) i.next();\r\n          sink.link(sink.getOutputName() + \".html\");\r\n          sink.text(String.valueOf(counter++));\r\n          sink.link_();\r\n        }\r\n        currentSink.paragraph_();\r\n        currentSink.closeSink();\r\n      }\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,test",
            "token": 152,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 63,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642432217826,
            "program": "  public SortedDocValues getSorted(FieldInfo field) throws IOException {\n    final BinaryDocValues binary = getBinary(field);\n    final NumericDocValues ordinals = getNumeric(field, ords.get(field.number));\n    return new SortedDocValues() {\n\n      @Override\n      public int getOrd(int docID) {\n        return (int) ordinals.get(docID);\n      }\n\n      @Override\n      public void lookupOrd(int ord, BytesRef result) {\n        binary.get(ord, result);\n      }\n\n      @Override\n      public int getValueCount() {\n        return binary.size();\n      }\n\n      @Override\n      public int size() {\n        return ordinals.size();\n      }\n    };\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,test",
            "token": 123,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 65,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642432378091,
            "program": "  private static Element topDeclaringType(Element element) {\n    Element enclosing = element.getEnclosingElement();\n    if (enclosing == null || enclosing.getKind() == ElementKind.PACKAGE) {\n      assert element.getKind() == ElementKind.CLASS || element.getKind() == ElementKind.INTERFACE;\n      return element;\n    }\n    return topDeclaringType(enclosing);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,test",
            "token": 67,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 67,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642432511320,
            "program": "  private String substituteKeywords(\r\n      String message, String dialNumber, String telVoice, String meetingName) {\r\n    String welcomeMessage = message;\r\n\r\n    String DIAL_NUM = \"%%DIALNUM%%\";\r\n    String CONF_NUM = \"%%CONFNUM%%\";\r\n    String CONF_NAME = \"%%CONFNAME%%\";\r\n    ArrayList<String> keywordList = new ArrayList<String>();\r\n    keywordList.add(DIAL_NUM);\r\n    keywordList.add(CONF_NUM);\r\n    keywordList.add(CONF_NAME);\r\n\r\n    Iterator<String> itr = keywordList.iterator();\r\n    while (itr.hasNext()) {\r\n      String keyword = (String) itr.next();\r\n      if (keyword.equals(DIAL_NUM)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(DIAL_NUM, dialNumber);\r\n      } else if (keyword.equals(CONF_NUM)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(CONF_NUM, telVoice);\r\n      } else if (keyword.equals(CONF_NAME)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(CONF_NAME, meetingName);\r\n      }\r\n    }\r\n    return welcomeMessage;\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,test",
            "token": 178,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "791893234-1642427959090": [
        {
            "ProgrammID": 12,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642433409756,
            "program": "  public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n    AArch64Kind kind = (AArch64Kind) expectedValue.getPlatformKind();\n    assert kind.isInteger();\n    final int size = kind.getSizeInBytes() * Byte.SIZE;\n\n    Register address = asRegister(addressValue);\n    Register result = asRegister(resultValue);\n    Register newVal = asRegister(newValue);\n    if (AArch64LIRFlagsVersioned.useLSE(masm.target.arch)) {\n      Register expected = asRegister(expectedValue);\n      masm.mov(size, result, expected);\n      masm.cas(size, expected, newVal, address, true /* acquire */, true /* release */);\n      AArch64Compare.gpCompare(masm, resultValue, expectedValue);\n    } else {\n      // We could avoid using a scratch register here, by reusing resultValue for the\n      // stlxr success flag and issue a mov resultValue, expectedValue in case of success\n      // before returning.\n      Register scratch = asRegister(scratchValue);\n      Label retry = new Label();\n      Label fail = new Label();\n      masm.bind(retry);\n      masm.ldaxr(size, result, address);\n      AArch64Compare.gpCompare(masm, resultValue, expectedValue);\n      masm.branchConditionally(AArch64Assembler.ConditionFlag.NE, fail);\n      masm.stlxr(size, scratch, newVal, address);\n      // if scratch == 0 then write successful, else retry.\n      masm.cbnz(32, scratch, retry);\n      masm.bind(fail);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 231,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 28,
            "lineNumberOfError": 29,
            "attempt": 1,
            "expectedAnswer": 27,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642433701397,
            "program": "  private static void addToResourceCollector(\n      AaptResourceCollector resourceCollector,\n      ResourceDirectory resourceDirectory,\n      Node node,\n      RType rType,\n      String resourceValue) {\n    String resourceName = sanitizeName(rType, resourceCollector, extractNameAttribute(node));\n    resourceCollector.addRTypeResourceName(rType, resourceName, resourceValue, resourceDirectory);\n    if (rType.equals(RType.STYLEABLE)) {\n\n      int count = 0;\n      for (Node attrNode = node.getFirstChild();\n          attrNode != null;\n          attrNode = attrNode.getNextSibling()) {\n        if (attrNode.getNodeType() != Node.ELEMENT_NODE || !attrNode.getNodeName().equals(\"attr\")) {\n          continue;\n        }\n\n        String rawAttrName = extractNameAttribute(attrNode);\n        String attrName = sanitizeName(rType, resourceCollector, rawAttrName);\n        resourceCollector.addResource(\n            RType.STYLEABLE,\n            IdType.INT,\n            String.format(\"%s_%s\", resourceName, attrName),\n            Integer.toString(count++));\n\n        if (!rawAttrName.startsWith(\"android:\")) {\n          resourceCollector.addIntResourceIfNotPresent(RType.ATTR, attrName);\n          resourceCollector.addRTypeResourceName(\n              RType.ATTR, rawAttrName, nodeToString(attrNode, true), resourceDirectory);\n        }\n      }\n\n      resourceCollector.addIntArrayResourceIfNotPresent(rType, resourceName, count);\n    } else {\n      resourceCollector.addIntResourceIfNotPresent(rType, resourceName);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 239,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 34,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642433806098,
            "program": "  public float dst2(float x, float y, float z) {\r\n    final float a = x - this.x;\r\n    final float b = y - this.y;\r\n    final float c = z - this.z;\r\n\r\n    return a * a + b * b + c * c;\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 58,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 77,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642433954716,
            "program": "  protected static FrequencySet<String> combineMax(FrequencySet<String> a, FrequencySet<String> b) {\n    FrequencySet<String> result = combineAndClip(a, b, 1);\n    for (Map.Entry<String, MutableInt> entry : a.entrySet()) {\n      result.get(entry.getKey()).v = entry.getValue().v;\n    }\n\n    for (Map.Entry<String, MutableInt> entry : a.entrySet()) {\n      MutableInt slot = result.get(entry.getKey());\n      slot.v = Math.max(slot.v, entry.getValue().v);\n    }\n\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 136,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 5,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642434256700,
            "program": "  public static void removeChildren(ASTNode parent, @NotNull ASTNode first, @NotNull ASTNode last) {\n    final boolean tailingElement =\n        last.getStartOffset() + last.getTextLength()\n            == parent.getStartOffset() + parent.getTextLength();\n    final boolean forceReformat = needToForceReformat(parent, first, last);\n    saveWhitespacesInfo(first);\n\n    TreeElement child = (TreeElement) first;\n    while (child != null) {\n      // checkForOuters(child);\n      if (child == last) break;\n      child = child.getTreeNext();\n    }\n    assert child == last\n        : last + \" is not a successor of \" + first + \" in the .getTreeNext() chain\";\n\n    final ASTNode prevLeaf = TreeUtil.prevLeaf(first);\n    final ASTNode nextLeaf = TreeUtil.nextLeaf(first);\n    parent.removeRange(first, last.getTreeNext());\n    ASTNode nextLeafToAdjust = nextLeaf;\n    if (nextLeafToAdjust != null && prevLeaf != null && nextLeafToAdjust.getTreeParent() == null) {\n      // next element has invalidated\n      nextLeafToAdjust = prevLeaf.getTreeNext();\n    }\n    makePlaceHolderBetweenTokens(prevLeaf, nextLeafToAdjust, forceReformat, tailingElement);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 190,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 58,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642434394463,
            "program": "  public void setBindingMatch(BindingMatch<?> bindingMatch) {\n    if (bindingMatch == null) return;\n    UriPattern pattern = bindingMatch.matched();\n    if (pattern == null) return;\n    Map<String, Object> combinedDimensions = new HashMap<>(requestDimensions);\n    combinedDimensions.put(Metrics.HANDLER_DIMENSION, bindingMatch.toString());\n    this.context = metric.createContext(combinedDimensions);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 79,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 54,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642434497413,
            "program": "  private boolean checkPostLowering(StructuredGraph graph, PhaseContext context) {\n    Mark expectedMark = graph.getMark();\n    lower(graph, context, 1);\n    Mark mark = graph.getMark();\n    assert mark.equals(expectedMark)\n        : graph\n            + \": a second round in the current lowering phase introduced these new nodes: \"\n            + graph.getNewNodes(expectedMark).snapshot();\n    return true;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 65,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 20,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642434655929,
            "program": "  public INDArray calculateDelta(INDArray epsilon) {\n    INDArray z = preOutput(true);\n    INDArray activationDerivative =\n        Nd4j.getExecutioner()\n            .execAndReturn(\n                Nd4j.getOpFactory()\n                    .createTransform(conf().getActivationFunction(), z)\n                    .derivative());\n    if (!Arrays.equals(z.shape(), activationDerivative.shape()))\n      throw new IllegalStateException(\"Shapes must be same\");\n    return epsilon.muli(activationDerivative);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 87,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1361769894-1642427436376": [
        {
            "ProgrammID": 45,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": 9,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642433997406,
            "program": "  private void notifyDelete(String filePath) {\n    String newFilePath = stripFileProtocol(filePath);\n    int result =\n        this.cordova\n            .getActivity()\n            .getContentResolver()\n            .delete(\n                MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                MediaStore.Images.Media.DATA + \" = ?\",\n                new String[] {filePath});\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 61,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 79,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642434065795,
            "program": "  public synchronized void createConnection(\n      String catalogName, String connectorName, Map<String, String> properties) {\n    checkNotNull(catalogName, \"catalogName is null\");\n    checkNotNull(connectorName, \"connectorName is null\");\n    checkNotNull(properties, \"properties is null\");\n\n    // for now connectorId == catalogName\n    String connectorId = catalogName;\n    checkState(!connectors.containsKey(connectorId), \"A connector %s already exists\", connectorId);\n\n    ConnectorFactory connectorFactory = connectorFactories.get(connectorName);\n    Preconditions.checkArgument(\n        connectorFactory != null, \"No factory for connector %s\", connectorName);\n\n    Connector connector = connectorFactory.create(connectorId, properties);\n    connectors.put(connectorName, connector);\n\n    addConnector(catalogName, connectorId, connector);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 115,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 49,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642434112992,
            "program": "  public static Component renderNonPrefixSeparatorComponent(Color backgroundColor) {\n    final JPanel panel = new JPanel(new BorderLayout());\n    final JSeparator separator = new JSeparator(SwingConstants.HORIZONTAL);\n    panel.add(separator, BorderLayout.CENTER);\n    if (!UIUtil.isUnderAquaBasedLookAndFeel()) {\n      panel.setBorder(new EmptyBorder(3, 0, 2, 0));\n    }\n    panel.setBackground(backgroundColor);\n    return panel;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 84,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 35,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642434222876,
            "program": "  public static AbstractOperation reconstruct(Project project, JSONObject obj) throws Exception {\n    JSONObject engineConfig = obj.getJSONObject(\"engineConfig\");\n\n    JSONObject match = obj.getJSONObject(\"match\");\n\n    JSONArray types = match.getJSONArray(\"types\");\n    String[] typeIDs = new String[types.length()];\n    for (int i = 0; i < typeIDs.length; i++) {\n      typeIDs[i] = types.getString(i);\n    }\n\n    return new ReconMatchSpecificTopicOperation(\n        engineConfig,\n        obj.getString(\"columnName\"),\n        new ReconCandidate(match.getString(\"id\"), match.getString(\"name\"), typeIDs, 100),\n        obj.getString(\"identifierSpace\"),\n        obj.getString(\"schemaSpace\"));\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 140,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 3,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642434265910,
            "program": "  protected Class<?>[] getInterfaces(Object object) {\n    List<Class<?>> interfaceClasses = new ArrayList<Class<?>>();\n\n    Class<?> clazz = object.getClass();\n\n    getInterfaces(interfaceClasses, clazz);\n\n    Class<?> superClazz = clazz.getSuperclass();\n\n    while (superClazz != null) {\n      getInterfaces(interfaceClasses, superClazz);\n\n      superClazz = clazz.getSuperclass();\n    }\n\n    return interfaceClasses.toArray(new Class<?>[interfaceClasses.size()]);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 107,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 0,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642434334796,
            "program": "  protected void assertSupportingTokens(Collection<PolicyAssertion> suppTokens) {\n    if (suppTokens == null) {\n      return;\n    }\n    for (PolicyAssertion pa : suppTokens) {\n      if (pa instanceof SupportingToken) {\n        for (Token token : ((SupportingToken) pa).getTokens()) {\n          this.policyAsserted(token);\n        }\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 64,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 75,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 17,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642434432079,
            "program": "  protected Object createBoxLayout(Map properties) {\n    Object parent = getCurrent();\n    if (parent instanceof Container) {\n      Object axisObject = properties.remove(\"axis\");\n      int axis = BoxLayout.X_AXIS;\n      if (axisObject != null) {\n        Integer i = (Integer) axisObject;\n        axis = i.intValue();\n      }\n\n      Container target = (Container) parent;\n      if (target instanceof RootPaneContainer) {\n        target = ((RootPaneContainer) target).getContentPane();\n      }\n      BoxLayout answer = new BoxLayout(target, axis);\n\n      // now let's try to set the layout property\n      InvokerHelper.setProperty(parent, \"layout\", answer);\n      return answer;\n    } else {\n      throw new RuntimeException(\"Must be nested inside a Container\");\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 129,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 31,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642434494612,
            "program": "  private DeclarationDescriptor resolveParentDescriptor(PsiClass psiClass) {\n    PsiClass containingClass = psiClass.getContainingClass();\n    if (containingClass != null) {\n      return resolveClass(containingClass);\n    }\n\n    PsiJavaFile containingFile = (PsiJavaFile) psiClass.getContainingFile();\n    String packageName = containingFile.getPackageName();\n    return resolveNamespace(packageName);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 59,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1956712283-1642435653298": [
        {
            "ProgrammID": 24,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642436163828,
            "program": "  private static GlobalInspectionToolWrapper getProblemDescriptionProcessor(\n      @NotNull final GlobalInspectionToolWrapper toolWrapper,\n      final Map<String, DescriptorProviderInspection> wrappersMap) {\n\n    return new GlobalInspectionToolWrapper(toolWrapper.getTool()) {\n      @Override\n      public void addProblemElement(\n          RefEntity refEntity, CommonProblemDescriptor... commonProblemDescriptors) {\n        for (CommonProblemDescriptor problemDescriptor : commonProblemDescriptors) {\n          if (problemDescriptor instanceof ProblemDescriptor) {\n            String problemGroup = ((ProblemDescriptor) problemDescriptor).getProblemGroup();\n\n            if (problemGroup != null) {\n              DescriptorProviderInspection dummyWrapper = wrappersMap.get(problemGroup);\n\n              if (dummyWrapper != null) { // Else it's switched off\n                dummyWrapper.addProblemElement(refEntity, problemDescriptor);\n              }\n            } else {\n              toolWrapper.addProblemElement(refEntity, problemDescriptor);\n            }\n          }\n        }\n      }\n    };\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 128,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 68,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642436355484,
            "program": "  public void afterExecution(Action action, Token token, MetadataHandler metadataHandler)\n      throws IOException {\n    Preconditions.checkArgument(token != null);\n    String key = token.cacheKey;\n    if (actionCache.get(key) != null) {\n      // This cache entry has already been updated by a shared action. We don't need to do it again.\n      return;\n    }\n    ActionCache.Entry entry = actionCache.createEntry(action.getKey());\n    for (Artifact output : action.getOutputs()) {\n      // Remove old records from the cache if they used different key.\n      String execPath = output.getExecPathString();\n      if (!key.equals(execPath)) {\n        actionCache.remove(key);\n      }\n      if (!metadataHandler.artifactOmitted(output)) {\n        // Output files *must* exist and be accessible after successful action execution.\n        Metadata metadata = metadataHandler.getMetadata(output);\n        Preconditions.checkState(metadata != null);\n        entry.addFile(output.getExecPath(), metadata);\n      }\n    }\n    for (Artifact input : action.getInputs()) {\n      entry.addFile(input.getExecPath(), metadataHandler.getMetadataMaybe(input));\n    }\n    entry.getFileDigest();\n    actionCache.put(key, entry);\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 195,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 70,
            "lineNumberOfError": 14,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642436581802,
            "program": "  public Subscription onSubscribe(Observer<? super T> actualObserver) {\n    CompositeSubscription completeSubscription = new CompositeSubscription();\n\n    /**\n     * We must synchronize a merge because we subscribe to multiple sequences in parallel that will\n     * each be emitting.\n     *\n     * <p>The calls from each sequence must be serialized.\n     *\n     * <p>Bug report: https://github.com/Netflix/RxJava/issues/614\n     */\n    SafeObservableSubscription subscription = new SafeObservableSubscription(ourSubscription);\n    completeSubscription.add(subscription);\n    SynchronizedObserver<T> synchronizedObserver =\n        new SynchronizedObserver<T>(actualObserver, subscription);\n\n    /** Subscribe to the parent Observable to get to the children Observables */\n    completeSubscription.add(sequences.subscribe(new ParentObserver(synchronizedObserver)));\n\n    /* return our subscription to allow unsubscribing */\n    return completeSubscription;\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 74,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 41,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642436649754,
            "program": "  public boolean visitRoot(final VirtualFile root, @Nullable Module module, @Nullable Sdk sdk) {\n    if (!root.isValid()) {\n      return true;\n    }\n    PsiFileSystemItem resolveResult = resolveInRoot(root, sdk);\n    if (resolveResult != null) {\n      results.add(resolveResult);\n    }\n\n    if (myAcceptRootAsTopLevelPackage\n        && myQualifiedName.matchesPrefix(PyQualifiedName.fromDottedString(root.getName()))) {\n      resolveResult = resolveInRoot(root.getParent(), sdk);\n      if (module != null) {\n        results.add(resolveResult);\n      }\n    }\n\n    return true;\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 112,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 52,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642436722543,
            "program": "  public Entity createEntity(Location location, BaseEntity state) {\n    Entity entity = super.createEntity(location, state);\n    if (entity != null) {\n      changeSet.add(new EntityCreate(location, state, entity));\n    }\n    return entity;\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 50,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 33,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642436906233,
            "program": "  static Slice[] deepCopyAndCompact(Slice[] values, int positionOffset, int length) {\n    Slice[] newValues = Arrays.copyOfRange(values, positionOffset, positionOffset + length);\n    // Compact the slices. Use an IdentityHashMap because this could be very expensive otherwise.\n    Map<Slice, Slice> distinctValues = new IdentityHashMap<>();\n    for (int i = 0; i < newValues.length; i++) {\n      Slice slice = newValues[i];\n      if (slice == null) {\n        continue;\n      }\n      Slice distinct = distinctValues.get(slice);\n      if (distinct == null) {\n        distinct = Slices.copyOf(slice);\n        distinctValues.put(slice, distinct);\n      }\n      newValues[i] = distinct;\n    }\n    return newValues;\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 134,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 14,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": 19,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642436971543,
            "program": "  private XmlTag addAnnotation(\n      @NotNull XmlTag rootTag,\n      @NotNull String ownerName,\n      @NotNull ExternalAnnotation annotation,\n      @Nullable XmlTag startTag) {\n    if (startTag == null) {\n      startTag = PsiTreeUtil.findChildOfType(rootTag, XmlTag.class);\n    }\n\n    XmlTag prevItem = null;\n    XmlTag curItem = startTag;\n\n    while (curItem != null) {\n      XmlTag addedItem = addAnnotation(rootTag, ownerName, annotation, curItem, prevItem);\n      if (addedItem != null) {\n        return addedItem;\n      }\n\n      prevItem = curItem;\n      curItem = PsiTreeUtil.getNextSiblingOfType(startTag, XmlTag.class);\n    }\n\n    return addItemTag(rootTag, prevItem, ownerName, annotation);\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 121,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 21,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642437044388,
            "program": "  private void cancelEndOfWindowAndGarbageCollectionTimers(\n      ReduceFn<?, ?, ?, W>.Context directContext) {\n    WindowTracing.debug(\n        \"ReduceFnRunner.cancelEndOfWindowAndGarbageCollectionTimers: Deleting timers for \"\n            + \"key:{}; window:{} where inputWatermark:{}; outputWatermark:{}\",\n        key,\n        directContext.window(),\n        timerInternals.currentInputWatermarkTime(),\n        timerInternals.currentOutputWatermarkTime());\n    Instant eow = directContext.window().maxTimestamp();\n    directContext.timers().deleteTimer(eow, TimeDomain.EVENT_TIME);\n    Instant gc = garbageCollectionTime(directContext.window());\n    if (gc.isAfter(eow)) {\n      directContext.timers().deleteTimer(eow, TimeDomain.EVENT_TIME);\n    }\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 115,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1388391100-1642429580270": [
        {
            "ProgrammID": 16,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642438344493,
            "program": "  private void populateProviderWithExtraProps(PoolingConnectionProvider cp, Properties props)\n      throws Exception {\n    Properties copyProps = new Properties();\n    copyProps.putAll(props);\n\n    // Remove all the default properties first (they don't always match to setter name, and they are\n    // already\n    // been set!)\n    copyProps.remove(PoolingConnectionProvider.DB_DRIVER);\n    copyProps.remove(PoolingConnectionProvider.DB_URL);\n    copyProps.remove(PoolingConnectionProvider.DB_USER);\n    copyProps.remove(PoolingConnectionProvider.DB_PASSWORD);\n    copyProps.remove(PoolingConnectionProvider.DB_MAX_CONNECTIONS);\n    copyProps.remove(PoolingConnectionProvider.DB_VALIDATION_QUERY);\n    copyProps.remove(C3p0PoolingConnectionProvider.DB_VALIDATE_ON_CHECKOUT);\n    props.remove(PoolingConnectionProvider.POOLING_PROVIDER);\n    setBeanProps(cp.getDataSource(), copyProps);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 112,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 15,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642438474106,
            "program": "  protected PageDTO evaluatePageRules(\n      List<PageDTO> pageDTOList, Locale locale, Map<String, Object> ruleDTOs) {\n    if (pageDTOList == null) {\n      return NULL_PAGE;\n    }\n\n    // First check to see if we have a page that matches on the full locale.\n    for (PageDTO page : pageDTOList) {\n      if (locale != null && locale.getLocaleCode() != null) {\n        if (locale.getLocaleCode().equals(page.getLocaleCode())) {\n          if (passesPageRules(page, ruleDTOs)) {\n            return page;\n          }\n        }\n      }\n    }\n\n    // Otherwise, we look for a match using just the language.\n    for (PageDTO page : pageDTOList) {\n      if (passesPageRules(page, ruleDTOs)) {\n        return page;\n      }\n    }\n\n    return NULL_PAGE;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 118,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 29,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642438507723,
            "program": "  private void validateCatch(Node n) {\n    validateNodeType(Token.CATCH, n);\n    validateChildCount(n);\n    Node caught = n.getFirstChild();\n    if (caught.isName()) {\n      validateName(caught);\n    } else if (n.isArrayPattern()) {\n      validateArrayPattern(Token.CATCH, caught);\n    } else {\n      validateObjectPattern(Token.CATCH, caught);\n    }\n    validateBlock(n.getLastChild());\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 88,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 57,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642438566824,
            "program": "  public void setServiceForegroundLocked(\n      ComponentName className, IBinder token, int id, Notification notification, int flags) {\n    final int userId = UserHandle.getCallingUserId();\n    final long origId = Binder.clearCallingIdentity();\n    try {\n      ServiceRecord r = findServiceLocked(className, token, userId);\n      if (r != null) {\n        setServiceForegroundInnerLocked(r, id, notification, flags);\n      }\n    } finally {\n      Binder.restoreCallingIdentity(origId);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 85,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 56,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642438661577,
            "program": "  public boolean connect(BluetoothDevice device) {\n    if (V) {\n      Log.d(TAG, \"PBAPClientProfile got connect request\");\n    }\n    if (mService == null) {\n      return false;\n    }\n    List<BluetoothDevice> srcs = getConnectedDevices();\n    if (srcs != null) {\n      for (BluetoothDevice src : srcs) {\n        if (src.equals(device)) {\n          // Connect to same device, Ignore it\n          Log.d(TAG, \"Ignoring Connect\");\n          return true;\n        }\n      }\n      for (BluetoothDevice src : srcs) {\n        mService.disconnect(src);\n      }\n    }\n    Log.d(TAG, \"PBAPClientProfile attempting to connect to \" + device.getAddress());\n\n    return mService.connect(device);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 124,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 74,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642438737687,
            "program": "  public ClassNode resolveType(final Expression exp, final ClassNode current) {\n    Expression target =\n        exp instanceof VariableExpression ? getTarget((VariableExpression) exp) : exp;\n    ClassNode dif = (ClassNode) target.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n    if (dif != null) return dif;\n    ClassNode inferredType = (ClassNode) target.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n    if (inferredType != null) {\n      return inferredType;\n    }\n    return super.resolveType(exp, current);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 91,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 55,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642438786763,
            "program": "  public boolean areReferencesUsageCorrelated(\n      @NotNull LightRef ref1, @NotNull LightRef ref2, int correlationThreshold) {\n    try {\n      myReadDataLock.lock();\n      if (myReader == null) throw new ReferenceIndexUnavailableException();\n      try {\n        final TIntHashSet ids1 = myReader.getAllContainingFileIds(ref1);\n        final TIntHashSet ids2 = myReader.getAllContainingFileIds(ref2);\n        final TIntHashSet intersection = intersection(ids1, ids2);\n        if ((ids1.size() - intersection.size()) * correlationThreshold < intersection.size()) {\n          return true;\n        }\n        if ((ids1.size() - intersection.size()) * correlationThreshold < intersection.size()) {\n          return true;\n        }\n        return false;\n      } catch (Exception e) {\n        //noinspection ConstantConditions\n        return onException(e, \"correlation\");\n      }\n    } finally {\n      myReadDataLock.unlock();\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 161,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 48,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 23,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642438894269,
            "program": "  private static void populateOrderEntries(\n      Module module,\n      Condition<Library> condition,\n      ArrayList<Library> libraries,\n      boolean exportedOnly,\n      Set<Module> visited) {\n    if (!visited.add(module)) {\n      return;\n    }\n\n    for (OrderEntry entry : ModuleRootManager.getInstance(module).getOrderEntries()) {\n      if (entry instanceof LibraryOrderEntry) {\n        LibraryOrderEntry libEntry = (LibraryOrderEntry) entry;\n        if (exportedOnly && !libEntry.isExported()) {\n          continue;\n        }\n\n        Library library = libEntry.getLibrary();\n        if (condition.value(library)) {\n          libraries.add(library);\n        }\n      } else if (entry instanceof ModuleOrderEntry) {\n        final Module dep = ((ModuleOrderEntry) entry).getModule();\n        if (module != null) {\n          populateOrderEntries(dep, condition, libraries, true, visited);\n        }\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 166,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1148059727-1642441084776": [
        {
            "ProgrammID": 18,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642441896359,
            "program": "  public void stack(\n      Player player,\n      EditSession editSession,\n      LocalSession session,\n      @Selection Region region,\n      @Optional(\"1\") @Range(min = 1) int count,\n      @Optional(Direction.AIM) @Direction Vector direction,\n      @Switch('s') boolean moveSelection,\n      @Switch('a') boolean ignoreAirBlocks)\n      throws WorldEditException {\n    int affected = editSession.stackCuboidRegion(region, direction, count, !ignoreAirBlocks);\n\n    if (ignoreAirBlocks) {\n      try {\n        final Vector size = region.getMaximumPoint().subtract(region.getMinimumPoint());\n\n        final Vector shiftVector = direction.multiply(count * (Math.abs(direction.dot(size)) + 1));\n        region.shift(shiftVector);\n\n        session.getRegionSelector(player.getWorld()).learnChanges();\n        session.getRegionSelector(player.getWorld()).explainRegionAdjust(player, session);\n      } catch (RegionOperationException e) {\n        player.printError(e.getMessage());\n      }\n    }\n\n    player.print(affected + \" blocks changed. Undo with //undo\");\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 204,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 13,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642442019794,
            "program": "  public Object processInvocation(InterceptorContext interceptorContext) throws Exception {\n    SingletonComponent singletonComponent =\n        getComponent(interceptorContext, SingletonComponent.class);\n    // get the component instance\n    ComponentInstance singletonComponentInstance = singletonComponent.getComponentInstance();\n    if (singletonComponent == null) {\n      throw MESSAGES.componentInstanceNotAvailable(interceptorContext);\n    }\n    interceptorContext.putPrivateData(ComponentInstance.class, singletonComponentInstance);\n    return interceptorContext.proceed();\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 66,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 11,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642442116165,
            "program": "  public void collect(int doc) throws IOException {\n    int valuesDocID = leafOutcomeValue.docID();\n    if (valuesDocID < doc) {\n      valuesDocID = leafOutcomeValue.advance(valuesDocID);\n    }\n    int outcome;\n    if (valuesDocID == doc) {\n      outcome = (int) leafOutcomeValue.longValue();\n    } else {\n      outcome = 0;\n    }\n\n    outcome = trainingParams.positiveLabel == outcome ? 1 : 0;\n    if (outcome == 1) {\n      positiveDocsSet.set(context.docBase + doc);\n    }\n    docsSet.set(context.docBase + doc);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 108,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 59,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642442221171,
            "program": "  public PyQualifiedName append(PyQualifiedName qName) {\n    PyQualifiedName result = new PyQualifiedName(myComponents.size() + qName.getComponentCount());\n    result.myComponents.addAll(myComponents);\n    result.myComponents.addAll(result.getComponents());\n    return result;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 53,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 47,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642442300193,
            "program": "  public static void reparseFiles(\n      @NotNull final Project project,\n      @NotNull final Collection<VirtualFile> files,\n      final boolean includeOpenFiles) {\n    LinkedHashSet<VirtualFile> fileSet = new LinkedHashSet<VirtualFile>(files);\n    if (includeOpenFiles) {\n      for (VirtualFile open : FileEditorManager.getInstance(project).getOpenFiles()) {\n        if (!fileSet.contains(open)) {\n          fileSet.add(open);\n        }\n      }\n    }\n    FileContentUtilCore.reparseFiles(fileSet);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 91,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 65,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642442422403,
            "program": "  private static Element topDeclaringType(Element element) {\n    Element enclosing = element.getEnclosingElement();\n    if (enclosing == null || enclosing.getKind() == ElementKind.PACKAGE) {\n      assert element.getKind() == ElementKind.CLASS || element.getKind() == ElementKind.INTERFACE;\n      return element;\n    }\n    return topDeclaringType(enclosing);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 67,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 2,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642442633625,
            "program": "  public <T extends Node> int insertChild(int index, final T child) {\r\n    for (Node p = this; p != null; p = p.getParent()) {\r\n      if (p == child) throw new GdxRuntimeException(\"Cannot add a parent as a child\");\r\n    }\r\n    Node p = child.getParent();\r\n    if (p != null && !p.removeChild(child))\r\n      throw new GdxRuntimeException(\"Could not remove child from its current parent\");\r\n    if (index < 0 || index >= children.size) {\r\n      index = children.size;\r\n      children.add(child);\r\n    } else children.insert(index, child);\r\n    child.parent = this;\r\n    return index;\r\n  }\r\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 128,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 12,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642443008977,
            "program": "  public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n    AArch64Kind kind = (AArch64Kind) expectedValue.getPlatformKind();\n    assert kind.isInteger();\n    final int size = kind.getSizeInBytes() * Byte.SIZE;\n\n    Register address = asRegister(addressValue);\n    Register result = asRegister(resultValue);\n    Register newVal = asRegister(newValue);\n    if (AArch64LIRFlagsVersioned.useLSE(masm.target.arch)) {\n      Register expected = asRegister(expectedValue);\n      masm.mov(size, result, expected);\n      masm.cas(size, expected, newVal, address, true /* acquire */, true /* release */);\n      AArch64Compare.gpCompare(masm, resultValue, expectedValue);\n    } else {\n      // We could avoid using a scratch register here, by reusing resultValue for the\n      // stlxr success flag and issue a mov resultValue, expectedValue in case of success\n      // before returning.\n      Register scratch = asRegister(scratchValue);\n      Label retry = new Label();\n      Label fail = new Label();\n      masm.bind(retry);\n      masm.ldaxr(size, result, address);\n      AArch64Compare.gpCompare(masm, resultValue, expectedValue);\n      masm.branchConditionally(AArch64Assembler.ConditionFlag.NE, fail);\n      masm.stlxr(size, scratch, newVal, address);\n      // if scratch == 0 then write successful, else retry.\n      masm.cbnz(32, scratch, retry);\n      masm.bind(fail);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 231,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 17,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642443169445,
            "program": "  public void execute(BstEntry context) {\n    Stack<Object> stack = vm.getStack();\n\n    if (stack.size() < 2) {\n      throw new VMException(\"Not enough operands on stack for operation text.prefix$\");\n    }\n    Object o1 = stack.pop();\n    Object o2 = stack.pop();\n\n    if (!(o1 instanceof Integer)) {\n      vm.warn(\"An integer is needed as first parameter to text.prefix$\");\n      stack.push(\"\");\n      return;\n    }\n    if (!(o2 instanceof String)) {\n      vm.warn(\"A string is needed as second parameter to text.prefix$\");\n      stack.push(\"\");\n      return;\n    }\n\n    stack.push(BibtexTextPrefix.textPrefix((Integer) o1, (String) o2, vm));\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 134,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 68,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642443373196,
            "program": "  public void afterExecution(Action action, Token token, MetadataHandler metadataHandler)\n      throws IOException {\n    Preconditions.checkArgument(token != null);\n    String key = token.cacheKey;\n    if (actionCache.get(key) != null) {\n      // This cache entry has already been updated by a shared action. We don't need to do it again.\n      return;\n    }\n    ActionCache.Entry entry = actionCache.createEntry(action.getKey());\n    for (Artifact output : action.getOutputs()) {\n      // Remove old records from the cache if they used different key.\n      String execPath = output.getExecPathString();\n      if (!key.equals(execPath)) {\n        actionCache.remove(key);\n      }\n      if (!metadataHandler.artifactOmitted(output)) {\n        // Output files *must* exist and be accessible after successful action execution.\n        Metadata metadata = metadataHandler.getMetadata(output);\n        Preconditions.checkState(metadata != null);\n        entry.addFile(output.getExecPath(), metadata);\n      }\n    }\n    for (Artifact input : action.getInputs()) {\n      entry.addFile(input.getExecPath(), metadataHandler.getMetadataMaybe(input));\n    }\n    entry.getFileDigest();\n    actionCache.put(key, entry);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 195,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 20,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642443479077,
            "program": "  public INDArray calculateDelta(INDArray epsilon) {\n    INDArray z = preOutput(true);\n    INDArray activationDerivative =\n        Nd4j.getExecutioner()\n            .execAndReturn(\n                Nd4j.getOpFactory()\n                    .createTransform(conf().getActivationFunction(), z)\n                    .derivative());\n    if (!Arrays.equals(z.shape(), activationDerivative.shape()))\n      throw new IllegalStateException(\"Shapes must be same\");\n    return epsilon.muli(activationDerivative);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 87,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 1,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642443654656,
            "program": "  private static boolean equalIncludingGenerics(ClassNode orig, ClassNode copy) {\n    if (orig == copy) return true;\n    if (orig.isGenericsPlaceHolder() != copy.isGenericsPlaceHolder()) return false;\n    if (!orig.equals(copy)) return false;\n    GenericsType[] gt1 = orig.getGenericsTypes();\n    GenericsType[] gt2 = orig.getGenericsTypes();\n    if ((gt1 == null || gt2 == null) && gt1 != gt2) return false;\n    if (gt1 == gt2) return true;\n    if (gt1.length != gt2.length) return false;\n    for (int i = 0; i < gt1.length; i++) {\n      if (!equalIncludingGenerics(gt1[i], gt2[i])) return false;\n    }\n    return true;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 155,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 30,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642443854957,
            "program": "  public final boolean blacklist(int index, long blacklistDurationMs) {\n    long nowMs = SystemClock.elapsedRealtime();\n    boolean canBlacklist = isBlacklisted(index, nowMs);\n    for (int i = 0; i < length && !canBlacklist; i++) {\n      canBlacklist = i != index && !isBlacklisted(i, nowMs);\n    }\n    if (!canBlacklist) {\n      return false;\n    }\n    blacklistUntilTimes[index] = Math.max(blacklistUntilTimes[index], nowMs + blacklistDurationMs);\n    return true;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 97,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 75,
            "lineNumberOfError": 12,
            "attempt": 2,
            "expectedAnswer": 17,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642443972882,
            "program": "  protected Object createBoxLayout(Map properties) {\n    Object parent = getCurrent();\n    if (parent instanceof Container) {\n      Object axisObject = properties.remove(\"axis\");\n      int axis = BoxLayout.X_AXIS;\n      if (axisObject != null) {\n        Integer i = (Integer) axisObject;\n        axis = i.intValue();\n      }\n\n      Container target = (Container) parent;\n      if (target instanceof RootPaneContainer) {\n        target = ((RootPaneContainer) target).getContentPane();\n      }\n      BoxLayout answer = new BoxLayout(target, axis);\n\n      // now let's try to set the layout property\n      InvokerHelper.setProperty(parent, \"layout\", answer);\n      return answer;\n    } else {\n      throw new RuntimeException(\"Must be nested inside a Container\");\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 129,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 64,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642444141950,
            "program": "  private void _resolveEntity(Entity entity) throws IOException {\n    if (entity.isResolved()) {\n      return;\n    }\n\n    for (String referenceName : entity.getUnresolvedReferenceList()) {\n      Entity referenceEntity = getEntity(referenceName);\n\n      if (referenceEntity == null) {\n        throw new RuntimeException(\n            \"Unable to resolve reference \"\n                + referenceName\n                + \" in \"\n                + ListUtil.toString(_ejbList, Entity.NAME_ACCESSOR));\n      }\n\n      entity.addReference(referenceEntity);\n    }\n\n    entity.setResolved();\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 87,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 66,
            "lineNumberOfError": 7,
            "attempt": 2,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642444212301,
            "program": "  public JSONArray getQualityProfileConfigurationChanges(String instanceUrl, String qualityProfile)\n      throws ParseException {\n    String url = instanceUrl + URL_QUALITY_PROFILE_CHANGES + qualityProfile;\n    try {\n      JSONArray qualityProfileConfigChanges = this.parseAsArray(instanceUrl, \"events\");\n      return qualityProfileConfigChanges;\n    } catch (ParseException e) {\n      LOG.error(\"Could not parse response from: \" + url, e);\n      throw e;\n    } catch (RestClientException rce) {\n      LOG.error(rce);\n      throw rce;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 79,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 29,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642444443568,
            "program": "  private void validateCatch(Node n) {\n    validateNodeType(Token.CATCH, n);\n    validateChildCount(n);\n    Node caught = n.getFirstChild();\n    if (caught.isName()) {\n      validateName(caught);\n    } else if (n.isArrayPattern()) {\n      validateArrayPattern(Token.CATCH, caught);\n    } else {\n      validateObjectPattern(Token.CATCH, caught);\n    }\n    validateBlock(n.getLastChild());\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 88,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 37,
            "lineNumberOfError": 3,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642444482355,
            "program": "  public int read(byte[] b, int off, int len) {\n    int toRead = len > input.remaining() ? input.remaining() : len;\n    input.get(b, off, toRead);\n    return toRead;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 50,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 62,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642444614733,
            "program": "  public static FloatingNode canonicalizeBoxing(\n      BoxNode box, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection) {\n    ValueNode value = box.getValue();\n    if (value.isConstant()) {\n      JavaConstant sourceConstant = value.asJavaConstant();\n      JavaConstant boxedConstant = constantReflection.boxPrimitive(sourceConstant);\n      if (boxedConstant != null && boxedConstant.getKind() == box.getBoxingKind()) {\n        return ConstantNode.forConstant(boxedConstant, metaAccess, box.graph());\n      }\n    }\n    return null;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 93,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 24,
            "lineNumberOfError": 10,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642444794823,
            "program": "  private static GlobalInspectionToolWrapper getProblemDescriptionProcessor(\n      @NotNull final GlobalInspectionToolWrapper toolWrapper,\n      final Map<String, DescriptorProviderInspection> wrappersMap) {\n\n    return new GlobalInspectionToolWrapper(toolWrapper.getTool()) {\n      @Override\n      public void addProblemElement(\n          RefEntity refEntity, CommonProblemDescriptor... commonProblemDescriptors) {\n        for (CommonProblemDescriptor problemDescriptor : commonProblemDescriptors) {\n          if (problemDescriptor instanceof ProblemDescriptor) {\n            String problemGroup = ((ProblemDescriptor) problemDescriptor).getProblemGroup();\n\n            if (problemGroup != null) {\n              DescriptorProviderInspection dummyWrapper = wrappersMap.get(problemGroup);\n\n              if (dummyWrapper != null) { // Else it's switched off\n                dummyWrapper.addProblemElement(refEntity, problemDescriptor);\n              }\n            } else {\n              toolWrapper.addProblemElement(refEntity, problemDescriptor);\n            }\n          }\n        }\n      }\n    };\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 128,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 51,
            "lineNumberOfError": 3,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642444816715,
            "program": "  private void registerWebTestClient(ConfigurableApplicationContext context) {\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    if (beanFactory instanceof BeanDefinitionRegistry) {\n      registerWebTestClient((BeanDefinitionRegistry) beanFactory);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 34,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 4,
            "lineNumberOfError": 8,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642444891833,
            "program": "  private static TextRange findCustomRange(\n      String text, int start, int end, char startChar, char endChar) {\n    int prev = text.lastIndexOf(startChar, start);\n    int next = text.indexOf(endChar, end);\n    if (prev < 0 || next < 0) {\n      return null;\n    }\n    if (StringUtil.contains(text, prev + 1, start, endChar)\n        || StringUtil.contains(text, end, next, startChar)) return null;\n    if (prev + 1 < start || next > end) {\n      return new TextRange(prev + 1, next);\n    }\n\n    return new TextRange(prev, next + 1);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 130,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 7,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642445119277,
            "program": "  public MutableVariable getNodeByPath(\n      @NotNull MutableVariable root, @NotNull List<String> relativeNodePath) {\n    MutableVariable localRoot = root;\n    for (int i = 0; i < relativeNodePath.size(); i++) {\n      String path = relativeNodePath.get(i);\n      if (localRoot != null) {\n        List<MutableVariable> variables = new ArrayList<>(localRoot.getVariables());\n        localRoot = null;\n        for (int j = 0; j < variables.size(); j++) {\n          MutableVariable variable = variables.get(j);\n          if (variable.getName().equals(path)) {\n            localRoot = variable;\n            break;\n          }\n        }\n\n        if (i == (relativeNodePath.size() - 1)) {\n          return localRoot;\n        }\n      }\n    }\n    return null;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 157,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 0,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642445239948,
            "program": "  protected void assertSupportingTokens(Collection<PolicyAssertion> suppTokens) {\n    if (suppTokens == null) {\n      return;\n    }\n    for (PolicyAssertion pa : suppTokens) {\n      if (pa instanceof SupportingToken) {\n        for (Token token : ((SupportingToken) pa).getTokens()) {\n          this.policyAsserted(token);\n        }\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review",
            "token": 64,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        }
    ],
    "1762598194-1642441479260": [
        {
            "ProgrammID": 6,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642442188909,
            "program": "  public IntArrayRef getOrds(int docId) {\n    int ordinal = (int) reader.get(docId);\n    if (ordinal == 0) return IntArrayRef.EMPTY;\n    intsScratch.values[0] = ordinal;\n    return intsScratch;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 45,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 66,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642442238364,
            "program": "  public JSONArray getQualityProfileConfigurationChanges(String instanceUrl, String qualityProfile)\n      throws ParseException {\n    String url = instanceUrl + URL_QUALITY_PROFILE_CHANGES + qualityProfile;\n    try {\n      JSONArray qualityProfileConfigChanges = this.parseAsArray(instanceUrl, \"events\");\n      return qualityProfileConfigChanges;\n    } catch (ParseException e) {\n      LOG.error(\"Could not parse response from: \" + url, e);\n      throw e;\n    } catch (RestClientException rce) {\n      LOG.error(rce);\n      throw rce;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 79,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 27,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642442426554,
            "program": "  private void addResolveListDedupe(\n      List<ResolvedComponentInfo> into, Intent intent, List<ResolveInfo> from) {\n    final int fromCount = from.size();\n    final int intoCount = into.size();\n    for (int i = 0; i < fromCount; i++) {\n      final ResolveInfo newInfo = from.get(i);\n      boolean found = false;\n      // Only loop to the end of into as it was before we started; no dupes in from.\n      for (int j = 0; j < intoCount; j++) {\n        final ResolvedComponentInfo rci = into.get(j);\n        if (isSameResolvedComponent(newInfo, rci)) {\n          found = true;\n          rci.add(intent, newInfo);\n          break;\n        }\n      }\n      if (!found) {\n        final ComponentName name =\n            new ComponentName(newInfo.activityInfo.packageName, newInfo.activityInfo.name);\n        final ResolvedComponentInfo rci = new ResolvedComponentInfo(name, intent, newInfo);\n        rci.setPinned(isComponentPinned(name));\n        into.add(rci);\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 184,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 17,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642442493724,
            "program": "  public void execute(BstEntry context) {\n    Stack<Object> stack = vm.getStack();\n\n    if (stack.size() < 2) {\n      throw new VMException(\"Not enough operands on stack for operation text.prefix$\");\n    }\n    Object o1 = stack.pop();\n    Object o2 = stack.pop();\n\n    if (!(o1 instanceof Integer)) {\n      vm.warn(\"An integer is needed as first parameter to text.prefix$\");\n      stack.push(\"\");\n      return;\n    }\n    if (!(o2 instanceof String)) {\n      vm.warn(\"A string is needed as second parameter to text.prefix$\");\n      stack.push(\"\");\n      return;\n    }\n\n    stack.push(BibtexTextPrefix.textPrefix((Integer) o1, (String) o2, vm));\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 134,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 26,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642442594557,
            "program": "  public static Class getMirrorOrFail(ResolvedJavaType type, ClassLoader loader)\n      throws NoClassDefFoundError {\n    ResolvedJavaType elementalType = getElementalType(type);\n    Class elementalClass;\n    if (elementalType.isPrimitive()) {\n      elementalClass = type.getKind().toJavaClass();\n    } else {\n      try {\n        elementalClass = Class.forName(toJavaName(elementalType), true, loader);\n      } catch (ClassNotFoundException e) {\n        throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);\n      }\n    }\n    if (type.isArray()) {\n      ResolvedJavaType t = type;\n      while (t.getComponentType() != null) {\n        elementalClass = Array.newInstance(elementalClass, 0).getClass();\n        t = t.getComponentType();\n      }\n    }\n    assert elementalClass != null : toJavaName(type);\n    return elementalClass;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 154,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 25,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642442682035,
            "program": "  public TiledDrawable getTiledDrawable(String name) {\r\n    TiledDrawable tiled = optional(name, TiledDrawable.class);\r\n    if (tiled != null) return tiled;\r\n\r\n    Drawable drawable = optional(name, Drawable.class);\r\n    if (tiled != null) {\r\n      if (!(drawable instanceof TiledDrawable)) {\r\n        throw new GdxRuntimeException(\r\n            \"Drawable found but is not a TiledDrawable: \"\r\n                + name\r\n                + \", \"\r\n                + drawable.getClass().getName());\r\n      }\r\n      return tiled;\r\n    }\r\n\r\n    tiled = new TiledDrawable(getRegion(name));\r\n    add(name, tiled, TiledDrawable.class);\r\n    return tiled;\r\n  }\r\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 110,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 18,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642442831769,
            "program": "  public void stack(\n      Player player,\n      EditSession editSession,\n      LocalSession session,\n      @Selection Region region,\n      @Optional(\"1\") @Range(min = 1) int count,\n      @Optional(Direction.AIM) @Direction Vector direction,\n      @Switch('s') boolean moveSelection,\n      @Switch('a') boolean ignoreAirBlocks)\n      throws WorldEditException {\n    int affected = editSession.stackCuboidRegion(region, direction, count, !ignoreAirBlocks);\n\n    if (ignoreAirBlocks) {\n      try {\n        final Vector size = region.getMaximumPoint().subtract(region.getMinimumPoint());\n\n        final Vector shiftVector = direction.multiply(count * (Math.abs(direction.dot(size)) + 1));\n        region.shift(shiftVector);\n\n        session.getRegionSelector(player.getWorld()).learnChanges();\n        session.getRegionSelector(player.getWorld()).explainRegionAdjust(player, session);\n      } catch (RegionOperationException e) {\n        player.printError(e.getMessage());\n      }\n    }\n\n    player.print(affected + \" blocks changed. Undo with //undo\");\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 204,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 19,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642442889887,
            "program": "  private void addToRealms(Collection<Realm> realms, RealmFactory factory) {\n    LifecycleUtils.init(factory);\n    Collection<Realm> factoryRealms = factory.getRealms();\n    if (!CollectionUtils.isEmpty(realms)) {\n      realms.addAll(factoryRealms);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 53,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "805304220-1642446815451": [
        {
            "ProgrammID": 76,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 16,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642447570378,
            "program": "  protected void sendLocallyUpdated(SyncData<TYPE> data) throws IOException {\n    int length;\n    length = data.localUpdated.getCount();\n    for (int i = 0; i < length; i++) {\n      data.localUpdated.moveToNext();\n      TYPE local = read(data.localUpdated);\n      try {\n        if (local.task == null) continue;\n\n        // if there is a conflict, merge\n        int remoteIndex = matchTask((ArrayList<TYPE>) data.remoteUpdated, local);\n        if (remoteIndex != -1) {\n          TYPE remote = data.remoteUpdated.get(remoteIndex);\n          push(local, remote);\n\n          // re-read remote task after merge\n          remote = pull(remote);\n          remote.task.setId(local.task.getId());\n          data.remoteUpdated.set(remoteIndex, remote);\n        } else {\n          push(local, null);\n        }\n      } catch (Exception e) {\n        handleException(\"sync-local-updated\", e, false); // $NON-NLS-1$\n      }\n      write(local);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 184,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 50,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642447609300,
            "program": "  protected void assertArrayEquals(Object[] expected, Object[] value) {\n    String message =\n        \"expected array: \"\n            + InvokerHelper.toString(expected)\n            + \" value array: \"\n            + InvokerHelper.toString(value);\n    assertNotNull(message + \": expected should not be null\", value);\n    assertNotNull(message + \": value should not be null\", value);\n    assertEquals(message, expected.length, value.length);\n    for (int i = 0, size = expected.length; i < size; i++) {\n      assertEquals(\"value[\" + i + \"] when \" + message, expected[i], value[i]);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 111,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 79,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642447685271,
            "program": "  public synchronized void createConnection(\n      String catalogName, String connectorName, Map<String, String> properties) {\n    checkNotNull(catalogName, \"catalogName is null\");\n    checkNotNull(connectorName, \"connectorName is null\");\n    checkNotNull(properties, \"properties is null\");\n\n    // for now connectorId == catalogName\n    String connectorId = catalogName;\n    checkState(!connectors.containsKey(connectorId), \"A connector %s already exists\", connectorId);\n\n    ConnectorFactory connectorFactory = connectorFactories.get(connectorName);\n    Preconditions.checkArgument(\n        connectorFactory != null, \"No factory for connector %s\", connectorName);\n\n    Connector connector = connectorFactory.create(connectorId, properties);\n    connectors.put(connectorName, connector);\n\n    addConnector(catalogName, connectorId, connector);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 115,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 49,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642447778606,
            "program": "  public static Component renderNonPrefixSeparatorComponent(Color backgroundColor) {\n    final JPanel panel = new JPanel(new BorderLayout());\n    final JSeparator separator = new JSeparator(SwingConstants.HORIZONTAL);\n    panel.add(separator, BorderLayout.CENTER);\n    if (!UIUtil.isUnderAquaBasedLookAndFeel()) {\n      panel.setBorder(new EmptyBorder(3, 0, 2, 0));\n    }\n    panel.setBackground(backgroundColor);\n    return panel;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 84,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 11,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642447867145,
            "program": "  public void collect(int doc) throws IOException {\n    int valuesDocID = leafOutcomeValue.docID();\n    if (valuesDocID < doc) {\n      valuesDocID = leafOutcomeValue.advance(valuesDocID);\n    }\n    int outcome;\n    if (valuesDocID == doc) {\n      outcome = (int) leafOutcomeValue.longValue();\n    } else {\n      outcome = 0;\n    }\n\n    outcome = trainingParams.positiveLabel == outcome ? 1 : 0;\n    if (outcome == 1) {\n      positiveDocsSet.set(context.docBase + doc);\n    }\n    docsSet.set(context.docBase + doc);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 108,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 23,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642447945893,
            "program": "  public LabelledDocument nextDocument() {\n    LabelledDocument document = new LabelledDocument();\n\n    document.setContent(backendIterator.nextSentence());\n    if (backendIterator instanceof LabelAwareSentenceIterator) {\n      List<String> labels = ((LabelAwareSentenceIterator) backendIterator).currentLabels();\n      if (labels != null) {\n        for (String label : labels) {\n          document.addLabel(label);\n          generator.storeLabel(label);\n        }\n      } else {\n        String label = ((LabelAwareSentenceIterator) backendIterator).currentLabel();\n        if (label != null) {\n          document.addLabel(label);\n          generator.storeLabel(label);\n        }\n      }\n    } else if (generator != null) document.addLabel(generator.nextLabel());\n\n    return document;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 142,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 72,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642447978168,
            "program": "  public final ExitStatus run(String... args) throws Exception {\n    String[] argsToUse = args.clone();\n    for (int i = 0; i < argsToUse.length; i++) {\n      if (\"-cp\".equals(argsToUse[i])) {\n        argsToUse[i] = \"--cp\";\n      }\n    }\n    OptionSet options = getParser().parse(argsToUse);\n    return run(options);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 81,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 56,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642448018063,
            "program": "  public boolean connect(BluetoothDevice device) {\n    if (V) {\n      Log.d(TAG, \"PBAPClientProfile got connect request\");\n    }\n    if (mService == null) {\n      return false;\n    }\n    List<BluetoothDevice> srcs = getConnectedDevices();\n    if (srcs != null) {\n      for (BluetoothDevice src : srcs) {\n        if (src.equals(device)) {\n          // Connect to same device, Ignore it\n          Log.d(TAG, \"Ignoring Connect\");\n          return true;\n        }\n      }\n      for (BluetoothDevice src : srcs) {\n        mService.disconnect(src);\n      }\n    }\n    Log.d(TAG, \"PBAPClientProfile attempting to connect to \" + device.getAddress());\n\n    return mService.connect(device);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 124,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1547713325-1642450891476": [
        {
            "ProgrammID": 34,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642451329511,
            "program": "  public float dst2(float x, float y, float z) {\r\n    final float a = x - this.x;\r\n    final float b = y - this.y;\r\n    final float c = z - this.z;\r\n\r\n    return a * a + b * b + c * c;\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 58,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 61,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642451437570,
            "program": "  public void testAddGetDeleteClient() {\n    Client c = addClient(\"12345\", \"alice\");\n    Client c2 = provider.getClient(c.getClientId());\n    compareClients(c, c2);\n\n    c2.setClientSecret(\"567\");\n    provider.setClient(c2);\n    Client c22 = provider.getClient(c.getClientId());\n    compareClients(c2, c22);\n\n    provider.removeClient(c.getClientId());\n    Client c3 = provider.getClient(c.getClientId());\n    assertNull(c3);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 103,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 13,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642451481929,
            "program": "  public Object processInvocation(InterceptorContext interceptorContext) throws Exception {\n    SingletonComponent singletonComponent =\n        getComponent(interceptorContext, SingletonComponent.class);\n    // get the component instance\n    ComponentInstance singletonComponentInstance = singletonComponent.getComponentInstance();\n    if (singletonComponent == null) {\n      throw MESSAGES.componentInstanceNotAvailable(interceptorContext);\n    }\n    interceptorContext.putPrivateData(ComponentInstance.class, singletonComponentInstance);\n    return interceptorContext.proceed();\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 66,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 70,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642451645677,
            "program": "  public Subscription onSubscribe(Observer<? super T> actualObserver) {\n    CompositeSubscription completeSubscription = new CompositeSubscription();\n\n    /**\n     * We must synchronize a merge because we subscribe to multiple sequences in parallel that will\n     * each be emitting.\n     *\n     * <p>The calls from each sequence must be serialized.\n     *\n     * <p>Bug report: https://github.com/Netflix/RxJava/issues/614\n     */\n    SafeObservableSubscription subscription = new SafeObservableSubscription(ourSubscription);\n    completeSubscription.add(subscription);\n    SynchronizedObserver<T> synchronizedObserver =\n        new SynchronizedObserver<T>(actualObserver, subscription);\n\n    /** Subscribe to the parent Observable to get to the children Observables */\n    completeSubscription.add(sequences.subscribe(new ParentObserver(synchronizedObserver)));\n\n    /* return our subscription to allow unsubscribing */\n    return completeSubscription;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 74,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 78,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642451703079,
            "program": "  public static synchronized PrivateDataManager getInstanceFor(XMPPConnection connection) {\n    PrivateDataManager privateDataManager = instances.get(connection);\n    if (connection == null) {\n      privateDataManager = new PrivateDataManager(connection);\n    }\n    return privateDataManager;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 40,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 19,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642451740926,
            "program": "  private void addToRealms(Collection<Realm> realms, RealmFactory factory) {\n    LifecycleUtils.init(factory);\n    Collection<Realm> factoryRealms = factory.getRealms();\n    if (!CollectionUtils.isEmpty(realms)) {\n      realms.addAll(factoryRealms);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 53,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 59,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642451794257,
            "program": "  public PyQualifiedName append(PyQualifiedName qName) {\n    PyQualifiedName result = new PyQualifiedName(myComponents.size() + qName.getComponentCount());\n    result.myComponents.addAll(myComponents);\n    result.myComponents.addAll(result.getComponents());\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 53,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 58,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642451854453,
            "program": "  public void setBindingMatch(BindingMatch<?> bindingMatch) {\n    if (bindingMatch == null) return;\n    UriPattern pattern = bindingMatch.matched();\n    if (pattern == null) return;\n    Map<String, Object> combinedDimensions = new HashMap<>(requestDimensions);\n    combinedDimensions.put(Metrics.HANDLER_DIMENSION, bindingMatch.toString());\n    this.context = metric.createContext(combinedDimensions);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop,test",
            "token": 79,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1071337540-1642452079441": [
        {
            "ProgrammID": 8,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642452736936,
            "program": "  private static void internalCopyDir(File src, File dest, boolean isOverride)\r\n      throws IORuntimeException {\r\n    if (false == dest.exists()) {\r\n      dest.mkdirs();\r\n    } else if (dest.isFile()) {\r\n      throw new IORuntimeException(\r\n          StrUtil.format(\r\n              \"Src [{}] is a directory but dest [{}] is a file!\", src.getPath(), dest.getPath()));\r\n    }\r\n\r\n    final String files[] = src.list();\r\n    for (String file : files) {\r\n      File srcFile = new File(src, file);\r\n      File destFile = new File(dest, file);\r\n      // \u9012\u5f52\u590d\u5236\r\n      if (srcFile.isDirectory()) {\r\n        internalCopyDir(srcFile, destFile, isOverride);\r\n      } else {\r\n        internalCopyFile(srcFile, destFile, isOverride);\r\n      }\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 145,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 63,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642452829289,
            "program": "  public SortedDocValues getSorted(FieldInfo field) throws IOException {\n    final BinaryDocValues binary = getBinary(field);\n    final NumericDocValues ordinals = getNumeric(field, ords.get(field.number));\n    return new SortedDocValues() {\n\n      @Override\n      public int getOrd(int docID) {\n        return (int) ordinals.get(docID);\n      }\n\n      @Override\n      public void lookupOrd(int ord, BytesRef result) {\n        binary.get(ord, result);\n      }\n\n      @Override\n      public int getValueCount() {\n        return binary.size();\n      }\n\n      @Override\n      public int size() {\n        return ordinals.size();\n      }\n    };\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 123,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 5,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642452984026,
            "program": "  public static void removeChildren(ASTNode parent, @NotNull ASTNode first, @NotNull ASTNode last) {\n    final boolean tailingElement =\n        last.getStartOffset() + last.getTextLength()\n            == parent.getStartOffset() + parent.getTextLength();\n    final boolean forceReformat = needToForceReformat(parent, first, last);\n    saveWhitespacesInfo(first);\n\n    TreeElement child = (TreeElement) first;\n    while (child != null) {\n      // checkForOuters(child);\n      if (child == last) break;\n      child = child.getTreeNext();\n    }\n    assert child == last\n        : last + \" is not a successor of \" + first + \" in the .getTreeNext() chain\";\n\n    final ASTNode prevLeaf = TreeUtil.prevLeaf(first);\n    final ASTNode nextLeaf = TreeUtil.nextLeaf(first);\n    parent.removeRange(first, last.getTreeNext());\n    ASTNode nextLeafToAdjust = nextLeaf;\n    if (nextLeafToAdjust != null && prevLeaf != null && nextLeafToAdjust.getTreeParent() == null) {\n      // next element has invalidated\n      nextLeafToAdjust = prevLeaf.getTreeNext();\n    }\n    makePlaceHolderBetweenTokens(prevLeaf, nextLeafToAdjust, forceReformat, tailingElement);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 190,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 53,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642453051471,
            "program": "  public final DBObject findOne(DBObject o, DBObject fields) {\n    Iterator<DBObject> i = __find(o, fields, 0, -1, 0, getOptions());\n    DBObject obj = (i == null ? null : i.next());\n    if (obj != null && (fields != null && fields.keySet().size() > 0)) {\n      obj.markAsPartialObject();\n    }\n    return obj;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 89,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 40,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642453224852,
            "program": "  protected void closeReport() {\r\n    int counter = 1;\r\n\r\n    if (!sinks.isEmpty()) {\r\n      for (Iterator i = sinks.iterator(); i.hasNext(); ) {\r\n        MultiPageSink currentSink = (MultiPageSink) i.next();\r\n\r\n        currentSink.paragraph();\r\n        for (Iterator j = sinks.iterator(); i.hasNext(); ) {\r\n          if (counter > 1) {\r\n            currentSink.text(\"&nbsp;\");\r\n          }\r\n          MultiPageSink sink = (MultiPageSink) i.next();\r\n          sink.link(sink.getOutputName() + \".html\");\r\n          sink.text(String.valueOf(counter++));\r\n          sink.link_();\r\n        }\r\n        currentSink.paragraph_();\r\n        currentSink.closeSink();\r\n      }\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 152,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 74,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642453353796,
            "program": "  public ClassNode resolveType(final Expression exp, final ClassNode current) {\n    Expression target =\n        exp instanceof VariableExpression ? getTarget((VariableExpression) exp) : exp;\n    ClassNode dif = (ClassNode) target.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE);\n    if (dif != null) return dif;\n    ClassNode inferredType = (ClassNode) target.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n    if (inferredType != null) {\n      return inferredType;\n    }\n    return super.resolveType(exp, current);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 91,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 35,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642453467685,
            "program": "  public static AbstractOperation reconstruct(Project project, JSONObject obj) throws Exception {\n    JSONObject engineConfig = obj.getJSONObject(\"engineConfig\");\n\n    JSONObject match = obj.getJSONObject(\"match\");\n\n    JSONArray types = match.getJSONArray(\"types\");\n    String[] typeIDs = new String[types.length()];\n    for (int i = 0; i < typeIDs.length; i++) {\n      typeIDs[i] = types.getString(i);\n    }\n\n    return new ReconMatchSpecificTopicOperation(\n        engineConfig,\n        obj.getString(\"columnName\"),\n        new ReconCandidate(match.getString(\"id\"), match.getString(\"name\"), typeIDs, 100),\n        obj.getString(\"identifierSpace\"),\n        obj.getString(\"schemaSpace\"));\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 140,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 67,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642453677087,
            "program": "  private String substituteKeywords(\r\n      String message, String dialNumber, String telVoice, String meetingName) {\r\n    String welcomeMessage = message;\r\n\r\n    String DIAL_NUM = \"%%DIALNUM%%\";\r\n    String CONF_NUM = \"%%CONFNUM%%\";\r\n    String CONF_NAME = \"%%CONFNAME%%\";\r\n    ArrayList<String> keywordList = new ArrayList<String>();\r\n    keywordList.add(DIAL_NUM);\r\n    keywordList.add(CONF_NUM);\r\n    keywordList.add(CONF_NAME);\r\n\r\n    Iterator<String> itr = keywordList.iterator();\r\n    while (itr.hasNext()) {\r\n      String keyword = (String) itr.next();\r\n      if (keyword.equals(DIAL_NUM)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(DIAL_NUM, dialNumber);\r\n      } else if (keyword.equals(CONF_NUM)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(CONF_NUM, telVoice);\r\n      } else if (keyword.equals(CONF_NAME)) {\r\n        welcomeMessage = welcomeMessage.replaceAll(CONF_NAME, meetingName);\r\n      }\r\n    }\r\n    return welcomeMessage;\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 178,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 77,
            "lineNumberOfError": 6,
            "attempt": 2,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642453862033,
            "program": "  protected static FrequencySet<String> combineMax(FrequencySet<String> a, FrequencySet<String> b) {\n    FrequencySet<String> result = combineAndClip(a, b, 1);\n    for (Map.Entry<String, MutableInt> entry : a.entrySet()) {\n      result.get(entry.getKey()).v = entry.getValue().v;\n    }\n\n    for (Map.Entry<String, MutableInt> entry : a.entrySet()) {\n      MutableInt slot = result.get(entry.getKey());\n      slot.v = Math.max(slot.v, entry.getValue().v);\n    }\n\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 136,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 25,
            "lineNumberOfError": 5,
            "attempt": 2,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642454010404,
            "program": "  public TiledDrawable getTiledDrawable(String name) {\r\n    TiledDrawable tiled = optional(name, TiledDrawable.class);\r\n    if (tiled != null) return tiled;\r\n\r\n    Drawable drawable = optional(name, Drawable.class);\r\n    if (tiled != null) {\r\n      if (!(drawable instanceof TiledDrawable)) {\r\n        throw new GdxRuntimeException(\r\n            \"Drawable found but is not a TiledDrawable: \"\r\n                + name\r\n                + \", \"\r\n                + drawable.getClass().getName());\r\n      }\r\n      return tiled;\r\n    }\r\n\r\n    tiled = new TiledDrawable(getRegion(name));\r\n    add(name, tiled, TiledDrawable.class);\r\n    return tiled;\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 110,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 18,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642454125459,
            "program": "  public void stack(\n      Player player,\n      EditSession editSession,\n      LocalSession session,\n      @Selection Region region,\n      @Optional(\"1\") @Range(min = 1) int count,\n      @Optional(Direction.AIM) @Direction Vector direction,\n      @Switch('s') boolean moveSelection,\n      @Switch('a') boolean ignoreAirBlocks)\n      throws WorldEditException {\n    int affected = editSession.stackCuboidRegion(region, direction, count, !ignoreAirBlocks);\n\n    if (ignoreAirBlocks) {\n      try {\n        final Vector size = region.getMaximumPoint().subtract(region.getMinimumPoint());\n\n        final Vector shiftVector = direction.multiply(count * (Math.abs(direction.dot(size)) + 1));\n        region.shift(shiftVector);\n\n        session.getRegionSelector(player.getWorld()).learnChanges();\n        session.getRegionSelector(player.getWorld()).explainRegionAdjust(player, session);\n      } catch (RegionOperationException e) {\n        player.printError(e.getMessage());\n      }\n    }\n\n    player.print(affected + \" blocks changed. Undo with //undo\");\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 204,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 52,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642454294583,
            "program": "  public Entity createEntity(Location location, BaseEntity state) {\n    Entity entity = super.createEntity(location, state);\n    if (entity != null) {\n      changeSet.add(new EntityCreate(location, state, entity));\n    }\n    return entity;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 50,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 22,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642454400546,
            "program": "  void reorderProbation(Node<K, V> node) {\n    if (!accessOrderProbationDeque().contains(node)) {\n      // Ignore stale accesses for an entry that is no longer present\n      return;\n    } else if (node.getPolicyWeight() > mainProtectedMaximum()) {\n      return;\n    }\n\n    long mainProtectedWeightedSize = mainProtectedWeightedSize() + node.getPolicyWeight();\n    accessOrderProbationDeque().remove(node);\n    accessOrderProtectedDeque().add(node);\n    node.makeMainProtected();\n\n    long mainProtectedMaximum = mainProtectedMaximum();\n    while (mainProtectedWeightedSize > mainProtectedMaximum) {\n      Node<K, V> demoted = accessOrderProtectedDeque().pollFirst();\n      if (demoted == null) {\n        break;\n      }\n      demoted.makeMainProbation();\n      accessOrderProbationDeque().add(demoted);\n      mainProtectedWeightedSize -= demoted.getPolicyWeight();\n    }\n\n    lazySetMainProtectedWeightedSize(mainProtectedWeightedSize);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 152,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 55,
            "lineNumberOfError": 12,
            "attempt": 2,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642454442746,
            "program": "  public boolean areReferencesUsageCorrelated(\n      @NotNull LightRef ref1, @NotNull LightRef ref2, int correlationThreshold) {\n    try {\n      myReadDataLock.lock();\n      if (myReader == null) throw new ReferenceIndexUnavailableException();\n      try {\n        final TIntHashSet ids1 = myReader.getAllContainingFileIds(ref1);\n        final TIntHashSet ids2 = myReader.getAllContainingFileIds(ref2);\n        final TIntHashSet intersection = intersection(ids1, ids2);\n        if ((ids1.size() - intersection.size()) * correlationThreshold < intersection.size()) {\n          return true;\n        }\n        if ((ids1.size() - intersection.size()) * correlationThreshold < intersection.size()) {\n          return true;\n        }\n        return false;\n      } catch (Exception e) {\n        //noinspection ConstantConditions\n        return onException(e, \"correlation\");\n      }\n    } finally {\n      myReadDataLock.unlock();\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 161,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 32,
            "lineNumberOfError": 5,
            "attempt": 2,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642454700380,
            "program": "  private void registerMemoryView(@NotNull XDebugSession session) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    final XDebugProcess debugProcess = session.getDebugProcess();\n    final Project project = session.getProject();\n    final DebugProcess javaProcess =\n        DebuggerManager.getInstance(session.getProject())\n            .getDebugProcess(debugProcess.getProcessHandler());\n    if (javaProcess instanceof DebugProcessImpl) {\n      final DebugProcessImpl processImpl = (DebugProcessImpl) javaProcess;\n      final ClassesFilteredView classesFilteredView =\n          new ClassesFilteredView(debugProcess.getSession());\n      myDispatcher.addListener(visible -> classesFilteredView.setActive(visible), project);\n\n      final MemoryViewDebugProcessData data = new MemoryViewDebugProcessData(classesFilteredView);\n      final ToolWindow toolWindow = getToolWindow(processImpl.getProject());\n\n      classesFilteredView.setActive(toolWindow != null && toolWindow.isVisible());\n      processImpl.putUserData(MemoryViewDebugProcessData.KEY, data);\n\n      if (toolWindow != null) {\n        updateCurrentMemoryView(project, toolWindow);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 177,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 41,
            "lineNumberOfError": 12,
            "attempt": 2,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642454758764,
            "program": "  public boolean visitRoot(final VirtualFile root, @Nullable Module module, @Nullable Sdk sdk) {\n    if (!root.isValid()) {\n      return true;\n    }\n    PsiFileSystemItem resolveResult = resolveInRoot(root, sdk);\n    if (resolveResult != null) {\n      results.add(resolveResult);\n    }\n\n    if (myAcceptRootAsTopLevelPackage\n        && myQualifiedName.matchesPrefix(PyQualifiedName.fromDottedString(root.getName()))) {\n      resolveResult = resolveInRoot(root.getParent(), sdk);\n      if (module != null) {\n        results.add(resolveResult);\n      }\n    }\n\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 112,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1431114331-1642457148359": [
        {
            "ProgrammID": 45,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": 9,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642457426875,
            "program": "  private void notifyDelete(String filePath) {\n    String newFilePath = stripFileProtocol(filePath);\n    int result =\n        this.cordova\n            .getActivity()\n            .getContentResolver()\n            .delete(\n                MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                MediaStore.Images.Media.DATA + \" = ?\",\n                new String[] {filePath});\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 61,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 3,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642457460367,
            "program": "  protected Class<?>[] getInterfaces(Object object) {\n    List<Class<?>> interfaceClasses = new ArrayList<Class<?>>();\n\n    Class<?> clazz = object.getClass();\n\n    getInterfaces(interfaceClasses, clazz);\n\n    Class<?> superClazz = clazz.getSuperclass();\n\n    while (superClazz != null) {\n      getInterfaces(interfaceClasses, superClazz);\n\n      superClazz = clazz.getSuperclass();\n    }\n\n    return interfaceClasses.toArray(new Class<?>[interfaceClasses.size()]);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 107,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 2,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642457534633,
            "program": "  public <T extends Node> int insertChild(int index, final T child) {\r\n    for (Node p = this; p != null; p = p.getParent()) {\r\n      if (p == child) throw new GdxRuntimeException(\"Cannot add a parent as a child\");\r\n    }\r\n    Node p = child.getParent();\r\n    if (p != null && !p.removeChild(child))\r\n      throw new GdxRuntimeException(\"Could not remove child from its current parent\");\r\n    if (index < 0 || index >= children.size) {\r\n      index = children.size;\r\n      children.add(child);\r\n    } else children.insert(index, child);\r\n    child.parent = this;\r\n    return index;\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 128,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 6,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642457567312,
            "program": "  public IntArrayRef getOrds(int docId) {\n    int ordinal = (int) reader.get(docId);\n    if (ordinal == 0) return IntArrayRef.EMPTY;\n    intsScratch.values[0] = ordinal;\n    return intsScratch;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 45,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 33,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642457704021,
            "program": "  static Slice[] deepCopyAndCompact(Slice[] values, int positionOffset, int length) {\n    Slice[] newValues = Arrays.copyOfRange(values, positionOffset, positionOffset + length);\n    // Compact the slices. Use an IdentityHashMap because this could be very expensive otherwise.\n    Map<Slice, Slice> distinctValues = new IdentityHashMap<>();\n    for (int i = 0; i < newValues.length; i++) {\n      Slice slice = newValues[i];\n      if (slice == null) {\n        continue;\n      }\n      Slice distinct = distinctValues.get(slice);\n      if (distinct == null) {\n        distinct = Slices.copyOf(slice);\n        distinctValues.put(slice, distinct);\n      }\n      newValues[i] = distinct;\n    }\n    return newValues;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 134,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 21,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642457783678,
            "program": "  private void cancelEndOfWindowAndGarbageCollectionTimers(\n      ReduceFn<?, ?, ?, W>.Context directContext) {\n    WindowTracing.debug(\n        \"ReduceFnRunner.cancelEndOfWindowAndGarbageCollectionTimers: Deleting timers for \"\n            + \"key:{}; window:{} where inputWatermark:{}; outputWatermark:{}\",\n        key,\n        directContext.window(),\n        timerInternals.currentInputWatermarkTime(),\n        timerInternals.currentOutputWatermarkTime());\n    Instant eow = directContext.window().maxTimestamp();\n    directContext.timers().deleteTimer(eow, TimeDomain.EVENT_TIME);\n    Instant gc = garbageCollectionTime(directContext.window());\n    if (gc.isAfter(eow)) {\n      directContext.timers().deleteTimer(eow, TimeDomain.EVENT_TIME);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 115,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 26,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642457881689,
            "program": "  public static Class getMirrorOrFail(ResolvedJavaType type, ClassLoader loader)\n      throws NoClassDefFoundError {\n    ResolvedJavaType elementalType = getElementalType(type);\n    Class elementalClass;\n    if (elementalType.isPrimitive()) {\n      elementalClass = type.getKind().toJavaClass();\n    } else {\n      try {\n        elementalClass = Class.forName(toJavaName(elementalType), true, loader);\n      } catch (ClassNotFoundException e) {\n        throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);\n      }\n    }\n    if (type.isArray()) {\n      ResolvedJavaType t = type;\n      while (t.getComponentType() != null) {\n        elementalClass = Array.newInstance(elementalClass, 0).getClass();\n        t = t.getComponentType();\n      }\n    }\n    assert elementalClass != null : toJavaName(type);\n    return elementalClass;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 154,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 31,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642457926833,
            "program": "  private DeclarationDescriptor resolveParentDescriptor(PsiClass psiClass) {\n    PsiClass containingClass = psiClass.getContainingClass();\n    if (containingClass != null) {\n      return resolveClass(containingClass);\n    }\n\n    PsiJavaFile containingFile = (PsiJavaFile) psiClass.getContainingFile();\n    String packageName = containingFile.getPackageName();\n    return resolveNamespace(packageName);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 59,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1758789813-1642474709937": [
        {
            "ProgrammID": 65,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642476131841,
            "program": "  private static Element topDeclaringType(Element element) {\n    Element enclosing = element.getEnclosingElement();\n    if (enclosing == null || enclosing.getKind() == ElementKind.PACKAGE) {\n      assert element.getKind() == ElementKind.CLASS || element.getKind() == ElementKind.INTERFACE;\n      return element;\n    }\n    return topDeclaringType(enclosing);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 67,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 16,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642476229917,
            "program": "  private void populateProviderWithExtraProps(PoolingConnectionProvider cp, Properties props)\n      throws Exception {\n    Properties copyProps = new Properties();\n    copyProps.putAll(props);\n\n    // Remove all the default properties first (they don't always match to setter name, and they are\n    // already\n    // been set!)\n    copyProps.remove(PoolingConnectionProvider.DB_DRIVER);\n    copyProps.remove(PoolingConnectionProvider.DB_URL);\n    copyProps.remove(PoolingConnectionProvider.DB_USER);\n    copyProps.remove(PoolingConnectionProvider.DB_PASSWORD);\n    copyProps.remove(PoolingConnectionProvider.DB_MAX_CONNECTIONS);\n    copyProps.remove(PoolingConnectionProvider.DB_VALIDATION_QUERY);\n    copyProps.remove(C3p0PoolingConnectionProvider.DB_VALIDATE_ON_CHECKOUT);\n    props.remove(PoolingConnectionProvider.POOLING_PROVIDER);\n    setBeanProps(cp.getDataSource(), copyProps);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 112,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 54,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642476291217,
            "program": "  private boolean checkPostLowering(StructuredGraph graph, PhaseContext context) {\n    Mark expectedMark = graph.getMark();\n    lower(graph, context, 1);\n    Mark mark = graph.getMark();\n    assert mark.equals(expectedMark)\n        : graph\n            + \": a second round in the current lowering phase introduced these new nodes: \"\n            + graph.getNewNodes(expectedMark).snapshot();\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 65,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 47,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642476414605,
            "program": "  public static void reparseFiles(\n      @NotNull final Project project,\n      @NotNull final Collection<VirtualFile> files,\n      final boolean includeOpenFiles) {\n    LinkedHashSet<VirtualFile> fileSet = new LinkedHashSet<VirtualFile>(files);\n    if (includeOpenFiles) {\n      for (VirtualFile open : FileEditorManager.getInstance(project).getOpenFiles()) {\n        if (!fileSet.contains(open)) {\n          fileSet.add(open);\n        }\n      }\n    }\n    FileContentUtilCore.reparseFiles(fileSet);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 91,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 60,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642476533608,
            "program": "  public void test() {\n    QUser user = new QUser(\"user\");\n    QUser user2 = new QUser(\"user2\");\n    QDepartment department = new QDepartment(\"department\");\n    QCompany company = new QCompany(\"company\");\n\n    // superiorId -> id\n    query().from(user).innerJoin(user.superiorId(), user.id());\n\n    // superiorId -> superiorId\n    query().from(user).innerJoin(user.superiorId(), user2.superiorId());\n\n    // department -> id / company -> id\n    query()\n        .from(user)\n        .innerJoin(user.department(), department.id())\n        .innerJoin(department.company(), company.id());\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 130,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 36,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642476577687,
            "program": "  private void readLinkedResources() {\n    for (Node linkNode : getChildren(findFirstChildNamed(getXml(), \"linkedResources\"), \"link\")) {\n      Node nameNode = findFirstChildNamed(linkNode, \"name\");\n      Node typeNode = findFirstChildNamed(linkNode, \"type\");\n      Node locationNode = findFirstChildNamed(linkNode, \"location\");\n      Node locationUriNode = findFirstChildNamed(linkNode, \"locationURI\");\n      linkedResources.add(\n          new Link(\n              nameNode != null ? nameNode.text() : null,\n              typeNode != null ? typeNode.text() : null,\n              locationNode != null ? locationNode.text() : null,\n              locationUriNode != null ? locationUriNode.text() : null));\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 125,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 57,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642476636205,
            "program": "  public void setServiceForegroundLocked(\n      ComponentName className, IBinder token, int id, Notification notification, int flags) {\n    final int userId = UserHandle.getCallingUserId();\n    final long origId = Binder.clearCallingIdentity();\n    try {\n      ServiceRecord r = findServiceLocked(className, token, userId);\n      if (r != null) {\n        setServiceForegroundInnerLocked(r, id, notification, flags);\n      }\n    } finally {\n      Binder.restoreCallingIdentity(origId);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 85,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 10,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642476709415,
            "program": "  private static @Nullable Library findModuleLibrary(\n      Module module,\n      final @NotNull ModulesProvider provider,\n      @NotNull String url,\n      Set<Module> visited) {\n    if (!visited.add(module)) {\n      return null;\n    }\n\n    ModuleRootModel rootModel = provider.getRootModel(module);\n    OrderEntry[] orderEntries = rootModel.getOrderEntries();\n    for (OrderEntry orderEntry : orderEntries) {\n      if (orderEntry instanceof LibraryOrderEntry) {\n        LibraryOrderEntry libraryOrderEntry = ((LibraryOrderEntry) orderEntry);\n        Library library = libraryOrderEntry.getLibrary();\n        if (library == null) continue;\n        String[] urls = library.getUrls(OrderRootType.CLASSES);\n        if (urls.length != 1) continue;\n        if (Comparing.strEqual(urls[0], url)) return library;\n      } else if (orderEntry instanceof ModuleOrderEntry) {\n        final Module dependency = ((ModuleOrderEntry) orderEntry).getModule();\n        if (dependency == null) {\n          continue;\n        }\n        final Library library = findModuleLibrary(dependency, provider, url, visited);\n        if (library != null) {\n          return library;\n        }\n      }\n    }\n    return null;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 213,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 9,
            "lineNumberOfError": 3,
            "attempt": 2,
            "expectedAnswer": 1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642476783341,
            "program": "  public static TRef intern(String moduleName, String name) throws Exception {\n    Module module = findModule(name);\n    if (module == null) throw new Exception(String.format(\"Module %s not found\", moduleName));\n    return module.intern(name);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 51,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 43,
            "lineNumberOfError": 4,
            "attempt": 2,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642476822581,
            "program": "  public boolean cancelInstalledTask(OptimizedCallTarget optimizedCallTarget) {\n    Future<?> codeTask = this.compilations.get(optimizedCallTarget);\n    if (codeTask != null && isCompiling(optimizedCallTarget)) {\n      this.compilations.remove(codeTask);\n      return codeTask.cancel(true);\n    }\n    return false;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 57,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 44,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642476889742,
            "program": "  public static Function fromSignature(String funcName, String[] paramTypes, String[] resultTypes) {\n    Function ret = new Function();\n    ret.name = funcName;\n    ret.constant = false;\n    ret.type = FunctionType.function;\n    ret.inputs = new Param[paramTypes.length];\n    for (int i = 0; i < paramTypes.length; i++) {\n      ret.inputs[i] = new Param();\n      ret.inputs[i].name = \"param\" + i;\n      ret.inputs[i].type = Type.getType(paramTypes[i]);\n    }\n    ret.outputs = new Param[resultTypes.length];\n    for (int i = 0; i < resultTypes.length; i++) {\n      ret.outputs[i] = new Param();\n      ret.outputs[i].name = \"res\" + i;\n      ret.outputs[i].type = Type.getType(resultTypes[i]);\n    }\n    return ret;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 199,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 28,
            "lineNumberOfError": 29,
            "attempt": 2,
            "expectedAnswer": 27,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642476932227,
            "program": "  private static void addToResourceCollector(\n      AaptResourceCollector resourceCollector,\n      ResourceDirectory resourceDirectory,\n      Node node,\n      RType rType,\n      String resourceValue) {\n    String resourceName = sanitizeName(rType, resourceCollector, extractNameAttribute(node));\n    resourceCollector.addRTypeResourceName(rType, resourceName, resourceValue, resourceDirectory);\n    if (rType.equals(RType.STYLEABLE)) {\n\n      int count = 0;\n      for (Node attrNode = node.getFirstChild();\n          attrNode != null;\n          attrNode = attrNode.getNextSibling()) {\n        if (attrNode.getNodeType() != Node.ELEMENT_NODE || !attrNode.getNodeName().equals(\"attr\")) {\n          continue;\n        }\n\n        String rawAttrName = extractNameAttribute(attrNode);\n        String attrName = sanitizeName(rType, resourceCollector, rawAttrName);\n        resourceCollector.addResource(\n            RType.STYLEABLE,\n            IdType.INT,\n            String.format(\"%s_%s\", resourceName, attrName),\n            Integer.toString(count++));\n\n        if (!rawAttrName.startsWith(\"android:\")) {\n          resourceCollector.addIntResourceIfNotPresent(RType.ATTR, attrName);\n          resourceCollector.addRTypeResourceName(\n              RType.ATTR, rawAttrName, nodeToString(attrNode, true), resourceDirectory);\n        }\n      }\n\n      resourceCollector.addIntArrayResourceIfNotPresent(rType, resourceName, count);\n    } else {\n      resourceCollector.addIntResourceIfNotPresent(rType, resourceName);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 239,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 27,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642476977429,
            "program": "  private void addResolveListDedupe(\n      List<ResolvedComponentInfo> into, Intent intent, List<ResolveInfo> from) {\n    final int fromCount = from.size();\n    final int intoCount = into.size();\n    for (int i = 0; i < fromCount; i++) {\n      final ResolveInfo newInfo = from.get(i);\n      boolean found = false;\n      // Only loop to the end of into as it was before we started; no dupes in from.\n      for (int j = 0; j < intoCount; j++) {\n        final ResolvedComponentInfo rci = into.get(j);\n        if (isSameResolvedComponent(newInfo, rci)) {\n          found = true;\n          rci.add(intent, newInfo);\n          break;\n        }\n      }\n      if (!found) {\n        final ComponentName name =\n            new ComponentName(newInfo.activityInfo.packageName, newInfo.activityInfo.name);\n        final ResolvedComponentInfo rci = new ResolvedComponentInfo(name, intent, newInfo);\n        rci.setPinned(isComponentPinned(name));\n        into.add(rci);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 184,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 42,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 18,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642477012743,
            "program": "  public static String createLambdaParameterListWithFormalTypes(\n      PsiType functionalInterfaceType,\n      PsiLambdaExpression lambdaExpression,\n      boolean checkApplicability) {\n    final PsiClassType.ClassResolveResult resolveResult =\n        PsiUtil.resolveGenericsClassInType(functionalInterfaceType);\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"(\");\n    final PsiMethod interfaceMethod =\n        LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);\n    LOG.assertTrue(interfaceMethod != null);\n    final PsiParameter[] parameters = interfaceMethod.getParameterList().getParameters();\n    final PsiParameter[] lambdaParameters = lambdaExpression.getParameterList().getParameters();\n    if (parameters.length != lambdaParameters.length) return null;\n    final PsiSubstitutor substitutor = LambdaUtil.getSubstitutor(interfaceMethod, resolveResult);\n    for (int i = 0; i < parameters.length; i++) {\n      PsiType psiType = substitutor.substitute(parameters[i].getType());\n      if (psiType == null) return null;\n      if (!PsiTypesUtil.isDenotableType(psiType, interfaceMethod)) {\n        return null;\n      }\n\n      buf.append(checkApplicability ? psiType.getPresentableText() : psiType.getCanonicalText())\n          .append(\" \")\n          .append(lambdaParameters[i].getName());\n      if (i < parameters.length - 1) {\n        buf.append(\", \");\n      }\n    }\n    buf.append(\")\");\n    return buf.toString();\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 253,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 38,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642477037983,
            "program": "  private boolean hasSimpleSchemaType(String type) {\n    final String attributeValue = myTag.getAttributeValue(\"type\");\n\n    if (attributeValue != null) {\n      if (attributeValue.endsWith(type)) {\n        final String namespacePrefix = myTag.getNamespacePrefix();\n\n        if (namespacePrefix.length() > 0) {\n          return attributeValue.equals(namespacePrefix + \":\" + type);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 82,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 46,
            "lineNumberOfError": 13,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642477067799,
            "program": "  public void validate_shouldPassIfTheConceptWithADuplicateNameIsRetired() throws Exception {\r\n    Context.setLocale(new Locale(\"en\"));\r\n    Concept concept = Context.getConceptService().getConcept(5497);\r\n    concept.setRetired(true);\r\n    Context.getConceptService().saveConcept(concept);\r\n\r\n    String duplicateName = concept.getFullySpecifiedName(Context.getLocale()).getName();\r\n    Concept newConcept = ConceptTest.createMockConcept(2, Context.getLocale());\r\n    ConceptName anotherConceptName =\r\n        ConceptNameTest.createMockConceptName(3, Context.getLocale(), null, true);\r\n    anotherConceptName.setName(duplicateName);\r\n    newConcept.addName(anotherConceptName);\r\n    Errors errors = new BindException(newConcept, \"concept\");\r\n    new ConceptValidator().validate(newConcept, errors);\r\n    Assert.assertEquals(false, errors.hasErrors());\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 156,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1068641188-1642485265421": [
        {
            "ProgrammID": 102,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642485784513,
            "program": "  public void visit(final ParserRuleContext ancestorNode, final SQLStatement statement) {\n    AlterTableStatement alterStatement = (AlterTableStatement) statement;\n\n    List<ParserRuleContext> modifyColumnCtxs =\n        TreeUtils.getAllDescendantByRuleName(ancestorNode, RuleNameConstants.MODIFY_COLUMN);\n    if (null == modifyColumnCtxs) {\n      return;\n    }\n\n    for (ParserRuleContext each : modifyColumnCtxs) {\n      // it`s not columndefinition, but can call this method\n      ColumnDefinition column = VisitorUtils.visitColumnDefinition(each);\n      if (null != column) {\n        alterStatement.getUpdateColumns().put(column.getName(), column);\n        postVisitColumnDefinition(ancestorNode, statement, column.getName());\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 106,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 85,
            "lineNumberOfError": 23,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642486229286,
            "program": "  protected void parseCommonParams(Object o) {\n    if (o instanceof Map) {\n      Map<String, Object> m = (Map<String, Object>) o;\n      List<String> excludeTags = getStringList(m, \"excludeTags\");\n      if (excludeTags != null) {\n        getDomain().excludeTags = excludeTags;\n      }\n\n      Map<String, Object> domainMap = (Map<String, Object>) m.get(\"domain\");\n      if (domainMap != null) {\n        excludeTags = getStringList(domainMap, \"excludeTags\");\n        if (excludeTags != null) {\n          getDomain().excludeTags = excludeTags;\n        }\n\n        String blockParent = (String) domainMap.get(\"blockParent\");\n        String blockChildren = (String) domainMap.get(\"blockChildren\");\n\n        if (blockParent != null) {\n          getDomain().toParent = true;\n          getDomain().parents = blockParent;\n        } else if (blockChildren != null) {\n          getDomain().toChildren = true;\n          getDomain().parents = blockChildren;\n        }\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 195,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 149,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642486385875,
            "program": "  public void route(IQ packet) {\n    if (packet == null) {\n      throw new NullPointerException();\n    }\n    Session session = sessionManager.getSession(packet.getFrom());\n    if (session == null\n        || session.getStatus() == Session.STATUS_AUTHENTICATED\n        || (isLocalServer(packet.getTo())\n            && (\"jabber:iq:auth\".equals(packet.getChildElement().getNamespaceURI())\n                || \"jabber:iq:register\".equals(packet.getChildElement().getNamespaceURI())))) {\n      handle(packet);\n    } else {\n      IQ reply = IQ.createResultIQ(packet);\n      reply.setChildElement(packet.getChildElement().createCopy());\n      packet.setError(PacketError.Condition.not_authorized);\n      sessionManager.getSession(packet.getFrom()).process(reply);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 158,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 86,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642486432036,
            "program": "  private static int parseInt(Map<String, String> attributes, String value, int def) {\n    String val = attributes.get(value);\n    if (val == null) {\n      return def;\n    }\n    try {\n      return Integer.parseInt(value);\n    } catch (NumberFormatException e) {\n      return def;\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 63,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 88,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642486512200,
            "program": "  public boolean addAll(int index, Collection<? extends Object> c) {\r\n    if (CollUtil.isEmpty(c)) {\r\n      return false;\r\n    }\r\n    final ArrayList<Object> list = new ArrayList<>(c.size());\r\n    for (Object object : list) {\r\n      list.add(JSONUtil.wrap(object, ignoreNullValue));\r\n    }\r\n    return rawList.addAll(index, list);\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 83,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 111,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642486569044,
            "program": "  public void connectToServer(InetAddress address, int port, int remoteUdpPort, int localUdpPort)\n      throws IOException {\n    UdpConnector fast = new UdpConnector(localUdpPort, address, port);\n    SocketConnector reliable = new SocketConnector(address, port);\n\n    setConnectors(reliable, fast);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 51,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 84,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642486620433,
            "program": "  public void addPossibleResultPoint(ResultPoint point) {\n    List<ResultPoint> points = possibleResultPoints;\n    synchronized (points) {\n      points.add(point);\n      int size = points.size();\n      if (size > MAX_RESULT_POINTS) {\n        // trim it\n        points.subList(0, size - MAX_RESULT_POINTS / 2).clear();\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 64,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 137,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": 1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642486719776,
            "program": "  Object key(String keyExpression, Method method, EvaluationContext evalContext) {\r\n    Expression keyExp = keyCache.get(keyExpression);\r\n    if (keyExp == null) {\r\n      keyExp = parser.parseExpression(keyExpression);\r\n      keyCache.put(method, keyExp);\r\n    }\r\n    return keyExp.getValue(evalContext);\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 58,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ],
    "46878831-1642490746099": [
        {
            "ProgrammID": 144,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 19,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642491112480,
            "program": "  static String getJarName(\n      JavaFileManager fileManager, ClassSymbol classSymbol, Set<String> platformJars) {\n    if (classSymbol == null) {\n      return null;\n    }\n\n    // Ignore symbols that appear in the sourcepath:\n    if (haveSourceForSymbol(classSymbol)) {\n      return null;\n    }\n\n    JavaFileObject classfile = unwrapFileObject(classSymbol.classfile);\n\n    String name = ImplicitDependencyExtractor.getJarName(fileManager, classfile);\n    if (name == null) {\n      return null;\n    }\n\n    // Filter out classes in rt.jar\n    if (platformJars.contains(classfile)) {\n      return null;\n    }\n\n    return name;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 91,
            "ctx": "commercial",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 139,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642491209888,
            "program": "  public void actionPerformed(@NotNull AnActionEvent e) {\n    Side currentSide = getCurrentSide();\n    Side targetSide = currentSide.other();\n\n    EditorEx currentEditor = getEditor(currentSide);\n    EditorEx targetEditor = getEditor(targetSide);\n\n    if (myScrollToPosition) {\n      LogicalPosition position =\n          transferPosition(currentSide, currentEditor.getCaretModel().getLogicalPosition());\n      targetEditor.getCaretModel().moveToLogicalPosition(position);\n    }\n\n    setCurrentSide(targetSide);\n    targetEditor.getScrollingModel().scrollToCaret(ScrollType.MAKE_VISIBLE);\n\n    DiffUtil.requestFocus(getProject(), getPreferredFocusedComponent());\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 109,
            "ctx": "commercial",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 80,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642491335475,
            "program": "  public static void remove(CuratorFramework curator, String path, String value) throws Exception {\n    if (curator.checkExists().forPath(path) != null) {\n      List<String> parts = new LinkedList<String>();\n      String data = getStringData(curator, path);\n      if (data != null) {\n        parts = new ArrayList<String>(Arrays.asList(data.trim().split(\" +\")));\n      }\n      boolean changed = false;\n      StringBuilder sb = new StringBuilder();\n      for (Iterator<String> it = parts.iterator(); it.hasNext(); ) {\n        String v = it.next();\n        if (v.matches(value)) {\n          it.remove();\n          changed = true;\n        }\n      }\n      if (changed) {\n        sb.delete(0, sb.length());\n        for (String part : parts) {\n          if (sb.length() > 0) {\n            sb.append(\" \");\n          }\n          sb.append(part);\n        }\n        setData(curator, path, sb.toString());\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 225,
            "ctx": "commercial",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 119,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642491433700,
            "program": "  public void visitPyExceptBlock(final PyExceptPart node) {\n    PyExpression exceptClass = node.getExceptClass();\n    if (exceptClass == null) {\n      registerProblem(node, \"Too broad exception clause\");\n    }\n    if (exceptClass instanceof PyReferenceExpression) {\n      PyReferenceExpression exceptClassRef = (PyReferenceExpression) exceptClass;\n      PyType classRefType = myTypeEvalContext.getType(exceptClassRef);\n      if (classRefType != null) {\n        if (classRefType.isBuiltin()) registerProblem(node, \"Too broad exception clause\");\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 83,
            "ctx": "commercial",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 116,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642491488454,
            "program": "  public <T extends GenericItem> Collection<T> getItemsByTag(Class<T> typeFilter, String... tags) {\n    Collection<T> filteredItems = new ArrayList<T>();\n\n    Collection<Item> items = getItemsByTag(tags);\n    for (Item item : items) {\n      if (typeFilter.isInstance(item)) {\n        filteredItems.add((T) item);\n      }\n    }\n    return filteredItems;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 82,
            "ctx": "commercial",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 128,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642491624624,
            "program": "  public Collection<Group> getSharedGroups(String userName) {\n    String key = USER_SHARED_GROUPS_KEY + userName;\n    ArrayList<String> groupNames = (ArrayList<String>) groupMetaCache.get(key);\n    if (groupNames == null) {\n      synchronized ((userName + MUTEX_SUFFIX_USER).intern()) {\n        groupNames = (ArrayList<String>) groupMetaCache.get(key);\n        if (groupNames == null) {\n          // assume this is a local user\n          groupNames =\n              new ArrayList(\n                  provider.getSharedGroupNames(\n                      new JID(\n                          userName,\n                          XMPPServer.getInstance().getServerInfo().getXMPPDomain(),\n                          null)));\n          groupMetaCache.put(key, groupNames);\n        }\n      }\n    }\n    return new GroupCollection(groupNames);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 132,
            "ctx": "commercial",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 124,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642491733855,
            "program": "  public void setCache(List<OBJECT> objects) {\r\n    super.setCache(objects);\r\n    synchronized (objectCache) {\r\n      objectCache.clear();\r\n      for (OBJECT object : objects) {\r\n        PARENT parent = getParent(object);\r\n        List<OBJECT> parentObjects = objectCache.get(parent);\r\n        if (parentObjects == null) {\r\n          parentObjects = new ArrayList<>();\r\n          objectCache.put(parent, parentObjects);\r\n        }\r\n        parentObjects.add(object);\r\n      }\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 94,
            "ctx": "commercial",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 127,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642491826305,
            "program": "  public void setAttribute(final String name, final Object value) {\n    try {\n      Object old = session.setAttribute(name, value).get();\n      if (value == null && old != null) {\n        applicationListeners.httpSessionAttributeRemoved(this, name, old);\n      } else if (old == null) {\n        applicationListeners.httpSessionAttributeAdded(this, name, value);\n      } else {\n        applicationListeners.httpSessionAttributeReplaced(this, name, old);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 104,
            "ctx": "commercial",
            "codebase": "others",
            "team": "alone"
        }
    ],
    "1677802905-1642495830193": [
        {
            "ProgrammID": 145,
            "lineNumberOfError": 7,
            "attempt": 2,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642495945659,
            "program": "  public int read(\n      String table, String key, Set<String> fields, HashMap<String, ByteIterator> result) {\n    Region<String, Map<String, byte[]>> r = getRegion(table);\n    Map<String, byte[]> val = r.get(key);\n    if (val != null) {\n      if (fields == null) {\n        for (String k : val.keySet()) {\n          result.put(key, new ByteArrayByteIterator(val.get(key)));\n        }\n      } else {\n        for (String field : fields) {\n          result.put(field, new ByteArrayByteIterator(val.get(field)));\n        }\n      }\n      return SUCCESS;\n    }\n    return ERROR;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 146,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 131,
            "lineNumberOfError": 17,
            "attempt": 2,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642496108529,
            "program": "  private static int replaceWhiteSpace(\n      final FormattingModel model,\n      @NotNull final LeafBlockWrapper block,\n      int shift,\n      final CharSequence _newWhiteSpace,\n      final CommonCodeStyleSettings.IndentOptions options) {\n    final WhiteSpace whiteSpace = block.getWhiteSpace();\n    final TextRange textRange = whiteSpace.getTextRange();\n    final TextRange wsRange = shiftRange(textRange, shift);\n    final String newWhiteSpace = _newWhiteSpace.toString();\n    TextRange newWhiteSpaceRange =\n        model instanceof FormattingModelEx\n            ? ((FormattingModelEx) model).replaceWhiteSpace(wsRange, block.getNode(), newWhiteSpace)\n            : model.replaceWhiteSpace(textRange, newWhiteSpace);\n\n    shift += newWhiteSpaceRange.getLength() - textRange.getLength();\n\n    if (block.isLeaf() && whiteSpace.containsLineFeeds() && block.containsLineFeeds()) {\n      final TextRange currentBlockRange = shiftRange(block.getTextRange(), shift);\n\n      IndentInside oldBlockIndent = whiteSpace.getInitialLastLineIndent();\n      IndentInside whiteSpaceIndent =\n          IndentInside.createIndentOn(IndentInside.getLastLine(newWhiteSpace));\n      final int shiftInside = calcShift(oldBlockIndent, whiteSpaceIndent, options);\n\n      if (shiftInside != 0 || !oldBlockIndent.equals(whiteSpaceIndent)) {\n        final TextRange newBlockRange =\n            model.shiftIndentInsideRange(currentBlockRange, shiftInside);\n        shift += newBlockRange.getLength() - block.getLength();\n      }\n    }\n    return shift;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 241,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 108,
            "lineNumberOfError": 24,
            "attempt": 2,
            "expectedAnswer": 24,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642496259446,
            "program": "  protected void configureTaskUploadArchives(\n      Project project, ReplaceRegexTask updateFileVersionsTask) {\n\n    String version = String.valueOf(project.getVersion());\n\n    if (version.endsWith(_SNAPSHOT_VERSION_SUFFIX)) {\n      return;\n    }\n\n    Task uploadArchivesTask = GradleUtil.getTask(project, BasePlugin.UPLOAD_ARCHIVES_TASK_NAME);\n\n    TaskContainer taskContainer = project.getTasks();\n\n    TaskCollection<PublishNodeModuleTask> publishNodeModuleTasks =\n        taskContainer.withType(PublishNodeModuleTask.class);\n\n    uploadArchivesTask.dependsOn(publishNodeModuleTasks);\n\n    Task updateBundleVersionTask = taskContainer.findByName(UPDATE_BUNDLE_VERSION_TASK_NAME);\n\n    if (updateBundleVersionTask != null) {\n      uploadArchivesTask.finalizedBy(updateBundleVersionTask);\n    }\n\n    uploadArchivesTask.finalizedBy(updateBundleVersionTask);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 116,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 121,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642496309409,
            "program": "  public static <T> T getFirstImplementation(final T t) {\n    T cur = t;\n    while (cur instanceof MergedObject) {\n      final List<T> implementations = ((MergedObject<T>) cur).getImplementations();\n      cur = implementations.isEmpty() ? null : implementations.get(0);\n    }\n    return cur;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 68,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 150,
            "lineNumberOfError": 7,
            "attempt": 2,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642496336463,
            "program": "  public DataFlowInfo equate(@NotNull DataFlowValue a, @NotNull DataFlowValue b) {\n    Map<DataFlowValue, Nullability> builder = Maps.newHashMap(nullabilityInfo);\n    Nullability nullabilityOfA = getNullability(a);\n    Nullability nullabilityOfB = getNullability(b);\n\n    boolean changed = false;\n    changed |= putNullability(builder, a, nullabilityOfA.refine(nullabilityOfB));\n    changed |= putNullability(builder, b, nullabilityOfA.refine(nullabilityOfA));\n    return changed ? new DataFlowInfo(ImmutableMap.copyOf(builder), typeInfo) : this;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 102,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 147,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642496374295,
            "program": "  public static RowStarChange load(LineNumberReader reader, Pool pool) throws Exception {\n    int row = -1;\n    boolean oldStarred = false;\n    boolean newStarred = false;\n\n    String line;\n    while ((line = reader.readLine()) != null && !\"/ec/\".equals(line)) {\n      int equal = line.indexOf('=');\n      CharSequence field = line.subSequence(0, equal);\n      String value = line.substring(equal + 1);\n\n      if (\"row\".equals(field)) {\n        row = Integer.parseInt(value);\n      } else if (\"oldStarred\".equals(field)) {\n        oldStarred = Boolean.parseBoolean(value);\n      } else if (\"newStarred\".equals(field)) {\n        newStarred = Boolean.parseBoolean(value);\n      }\n    }\n\n    RowStarChange change = new RowStarChange(row, newStarred);\n    change.oldStarred = oldStarred;\n\n    return change;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 174,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 92,
            "lineNumberOfError": 21,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642496424251,
            "program": "  public static void main(String[] args) throws URISyntaxException {\n    checkDatabaseIsRunning();\n\n    // START SNIPPET: nodesAndProps\n    URI firstNode = createNode();\n    addProperty(firstNode, \"name\", \"Joe Strummer\");\n    URI secondNode = createNode();\n    addProperty(secondNode, \"band\", \"The Clash\");\n    // END SNIPPET: nodesAndProps\n\n    // START SNIPPET: addRel\n    URI relationshipUri =\n        addRelationship(\n            firstNode, secondNode, \"singer\", \"{ \\\"from\\\" : \\\"1976\\\", \\\"until\\\" : \\\"1986\\\" }\");\n    // END SNIPPET: addRel\n\n    // START SNIPPET: addMetaToRel\n    addMetadataToProperty(relationshipUri, \"stars\", \"5\");\n    // END SNIPPET: addMetaToRel\n\n    // START SNIPPET: queryForSingers\n    findSingersInBands(firstNode);\n    // END SNIPPET: queryForSingers\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 78,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 123,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642496465706,
            "program": "  public void putAll(Map map) {\n    for (Iterator i = map.keySet().iterator(); i.hasNext(); ) {\n      Object key = i.next();\n      put(key, map.get(key));\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 54,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "2035651690-1642504487372": [
        {
            "ProgrammID": 115,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642505213670,
            "program": "  protected MediaType selectMediaType(\n      ServerWebExchange exchange, Supplier<List<MediaType>> producibleTypesSupplier) {\n\n    List<MediaType> acceptableTypes = getAcceptableTypes(exchange);\n    List<MediaType> producibleTypes = getProducibleTypes(exchange, producibleTypesSupplier);\n\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n    for (MediaType acceptable : acceptableTypes) {\n      for (MediaType producible : producibleTypes) {\n        if (acceptable.isCompatibleWith(producible)) {\n          compatibleMediaTypes.add(selectMoreSpecificMediaType(acceptable, producible));\n        }\n      }\n    }\n\n    List<MediaType> result = new ArrayList<>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(result);\n\n    for (MediaType mediaType : result) {\n      if (mediaType.isConcrete()) {\n        return mediaType;\n      } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION_ALL)) {\n        return MediaType.APPLICATION_OCTET_STREAM;\n      }\n    }\n\n    return null;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 168,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 94,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642505330080,
            "program": "  protected UserSubject getGrantSubject(Message message, SamlAssertionWrapper wrapper) {\n    SecurityContext sc = scProvider.getSecurityContext(message, wrapper);\n    if (sc instanceof SAMLSecurityContext) {\n      SAMLSecurityContext jaxrsSc = (SAMLSecurityContext) sc;\n      Set<Principal> rolesP = jaxrsSc.getUserRoles();\n      List<String> roles = new ArrayList<>();\n      if (roles != null) {\n        for (Principal p : rolesP) {\n          roles.add(p.getName());\n        }\n      }\n      return new SamlUserSubject(jaxrsSc.getUserPrincipal().getName(), roles, jaxrsSc.getClaims());\n    }\n    return new UserSubject(sc.getUserPrincipal().getName());\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 131,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 117,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642505426736,
            "program": "  public void testAddSubtractWithOpsCommonsMath() {\n    List<Pair<INDArray, String>> first = CheckUtil.getAllTestMatricesWithShape(3, 5, SEED);\n    List<Pair<INDArray, String>> second = CheckUtil.getAllTestMatricesWithShape(3, 5, SEED);\n    for (int i = 0; i < first.size(); i++) {\n      for (int j = 0; j < second.size(); j++) {\n        Pair<INDArray, String> p1 = first.get(i);\n        Pair<INDArray, String> p2 = second.get(i);\n        String errorMsg1 = getTestWithOpsErrorMsg(i, j, \"add\", p1, p2);\n        String errorMsg2 = getTestWithOpsErrorMsg(i, j, \"sub\", p1, p2);\n        boolean addFail = CheckUtil.checkAdd(p1.getFirst(), p2.getFirst(), 1e-4, 1e-6);\n        assertTrue(errorMsg1, addFail);\n        boolean subFail = CheckUtil.checkSubtract(p1.getFirst(), p2.getFirst(), 1e-4, 1e-6);\n        assertTrue(errorMsg2, subFail);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 215,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 101,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642505527382,
            "program": "  public void setDarkIntensity(float darkIntensity) {\n    int backgroundColor = getBackgroundColor(darkIntensity);\n    int fillColor = getFillColor(darkIntensity);\n    mIconTint = fillColor;\n    mFramePaint.setColor(backgroundColor);\n    mBoltPaint.setColor(fillColor);\n    mChargeColor = fillColor;\n    invalidate();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 51,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 133,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642505619931,
            "program": "  public boolean getBooleanValue(String name, boolean defaultValue) {\n    String result = properties.get(name);\n    if (result == null) {\n      return defaultValue;\n    }\n    return Utils.parseBoolean(name, defaultValue, true);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 45,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 98,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642505731538,
            "program": "  protected <K, V> NearCacheTestContext<K, V, Data, String> createContext() {\n    Config configWithNearCache = getConfig(true);\n    Config config = getConfig(false);\n\n    HazelcastInstance nearCacheMember = hazelcastFactory.newHazelcastInstance(configWithNearCache);\n    HazelcastInstance dataMember = hazelcastFactory.newHazelcastInstance(config);\n\n    IMap<K, V> nearCacheMap = nearCacheMember.getMap(DEFAULT_NEAR_CACHE_NAME);\n    IMap<K, V> dataMap = dataMember.getMap(DEFAULT_NEAR_CACHE_NAME);\n\n    NearCacheManager nearCacheManager = getMapNearCacheManager(nearCacheMember);\n    NearCache<Data, String> nearCache = nearCacheManager.getNearCache(DEFAULT_NEAR_CACHE_NAME);\n\n    return new NearCacheTestContextBuilder<K, V, Data, String>(\n            nearCacheConfig, getSerializationService(dataMember))\n        .setNearCacheInstance(nearCacheMember)\n        .setDataInstance(dataMember)\n        .setNearCacheAdapter(new IMapDataStructureAdapter<K, V>(nearCacheMap))\n        .setDataAdapter(new IMapDataStructureAdapter<K, V>(dataMap))\n        .setNearCache(nearCache)\n        .setNearCacheManager(nearCacheManager)\n        .setHasLocalData(true)\n        .build();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 188,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 118,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642505799954,
            "program": "  private void addSuppressedThrowable(Throwable t) {\n    try {\n      this.getClass().getMethod(\"addSuppressed\", Throwable.class).invoke(this, t);\n    } catch (Throwable t2) {\n      // java < 1.7\n      suppressed.add(t2);\n      if (getCause() == null) {\n        initCause(t);\n      }\n      hasSuppressed = true;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 67,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 81,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": 17,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642506001973,
            "program": "  private boolean canSeeAllInterfaces(ClassLoader loader, Class<?>[] interfaces) {\n    for (Class<?> currentInterface : interfaces) {\n      String ifName = currentInterface.getName();\n      try {\n        Class<?> ifClass = Class.forName(ifName, true, loader);\n        if (ifClass != currentInterface) {\n          return false;\n        }\n        // we need to check all the params/returns as well as the Proxy creation\n        // will try to create methods for all of this even if they aren't used\n        // by the client and not available in the clients classloader\n        for (Method m : ifClass.getMethods()) {\n          Class<?> returnType = m.getReturnType();\n          if (!returnType.isPrimitive()) {\n            Class.forName(returnType.getName(), true, loader);\n          }\n          for (Class<?> p : m.getParameterTypes()) {\n            if (!returnType.isPrimitive()) {\n              Class.forName(p.getName(), true, loader);\n            }\n          }\n        }\n      } catch (NoClassDefFoundError e) {\n        return false;\n      } catch (ClassNotFoundException e) {\n        return false;\n      }\n    }\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 185,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 106,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642506525507,
            "program": "  public static Path copyChecksums(SyncFile sourceSyncFile, SyncFile targetSyncFile) {\n\n    try {\n      Path sourceChecksumsFilePath = getChecksumsFilePath(sourceSyncFile);\n\n      if (Files.notExists(sourceChecksumsFilePath)) {\n        checksums(sourceSyncFile);\n      }\n\n      Path targetChecksumsFilePath = getChecksumsFilePath(targetSyncFile);\n\n      Files.copy(\n          sourceChecksumsFilePath, targetChecksumsFilePath, StandardCopyOption.REPLACE_EXISTING);\n\n      return targetChecksumsFilePath;\n    } catch (IOException ioe) {\n      _logger.error(ioe.getMessage(), ioe);\n\n      return null;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 87,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 154,
            "lineNumberOfError": 19,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642506867494,
            "program": "  private void createIocLoader(String className, List<String> args) throws ClassNotFoundException {\n    Class<? extends IocLoader> klass = loaders.get(className);\n    if (klass == null) {\n      if (!className.contains(\".\")) {\n        Set<String> _names = new HashSet<String>();\n        String uccp = Strings.upperFirst(className);\n        _names.add(String.format(\"org.nutz.integration.%s.%sIocLoader\", className, uccp));\n        _names.add(String.format(\"org.nutz.integration.%s.%sAopConfigure\", className, uccp));\n        _names.add(String.format(\"org.nutz.plugins.%s.%sIocLoader\", className, uccp));\n        _names.add(String.format(\"org.nutz.plugins.%s.%sAopConfigure\", className, uccp));\n        // \u5bfb\u627e\u63d2\u4ef6\u6216\u96c6\u6210\u7c7b @since 1.r.57\n        for (String _className : _names) {\n          klass = (Class<? extends IocLoader>) Lang.loadClassQuite(_className);\n          if (klass != null) {\n            log.debug(\"found \" + className + \" -- \" + _className);\n            break;\n          }\n        }\n      }\n      if (klass == null) klass = (Class<? extends IocLoader>) Lang.loadClass(className);\n    }\n    iocLoaders.add((IocLoader) Mirror.me(klass).born(args.toArray(new Object[args.size()])));\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 245,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 156,
            "lineNumberOfError": 3,
            "attempt": 2,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642506906622,
            "program": "  public static Object getOrDefault(String key, Object defaultValue) {\n    Object re = me().map.get(key);\n    if (re == null) return defaultValue;\n    return key;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 39,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 141,
            "lineNumberOfError": 4,
            "attempt": 2,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642506973169,
            "program": "  public void onDraw(Canvas canvas, RotatedTileBox tb, DrawSettings nightMode) {\n    final int r = getRadiusPoi(tb);\n    for (OsMoDevice t : getTrackingDevices()) {\n      Location l = t.getLastLocation();\n      if (t != null) {\n        int x = (int) tb.getPixXFromLatLon(l.getLatitude(), l.getLongitude());\n        int y = (int) tb.getPixYFromLatLon(l.getLatitude(), l.getLongitude());\n        pointAltUI.setColor(t.getColor());\n        canvas.drawCircle(x, y, r, pointAltUI);\n        canvas.drawCircle(x, y, r, point);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 135,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 97,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642507090394,
            "program": "  public void onUpdate(final float pSecondsElapsed) {\r\n    this.mSecondsElapsedAccumulator += pSecondsElapsed;\r\n\r\n    final float stepLength = this.mStepLength;\r\n    while (this.mSecondsElapsedAccumulator >= stepLength) {\r\n      super.onUpdate(pSecondsElapsed);\r\n      this.mSecondsElapsedAccumulator -= stepLength;\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 47,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 89,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642507166708,
            "program": "  protected long executeI64(VirtualFrame frame, long value) {\n    long result = value + 1;\n    boolean of = result == Long.MAX_VALUE;\n    flags.execute(frame, of, result);\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 42,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 130,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642507272730,
            "program": "  public void onFling(int velocityX, int velocityY) {\n    int velocity = orientationHelper.getFlingVelocity(velocityX, velocityY);\n    int throttleValue = shouldSlideOnFling ? Math.abs(velocity / flingThreshold) : 1;\n    int newPosition = currentPosition + Direction.fromDelta(velocity).applyTo(throttleValue);\n    newPosition = checkNewOnFlingPositionIsInBounds(newPosition);\n    boolean isInScrollDirection = velocity * scrolled >= 0;\n    boolean canFling = isInScrollDirection && isInBounds(newPosition);\n    if (canFling) {\n      startSmoothPendingScroll(newPosition);\n    } else {\n      returnToCurrentPosition();\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 101,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 100,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642507410842,
            "program": "  private SlimAssertion callFunctionInRow(String functionName, int row) {\n    int col = funcStore.getColumnNumber(functionName);\n    String name = Disgracer.disgraceMethodName(functionName);\n    String assignedSymbol = ifSymbolAssignment(col, row);\n    SlimAssertion assertion;\n    if (assignedSymbol != null) {\n      assertion =\n          makeAssertion(\n              callAndAssign(assignedSymbol, \"scriptTable\" + \"Actor\", \"cloneSymbol\", \"$\" + name),\n              new ReturnedSymbolExpectation(col, row, name, assignedSymbol));\n    } else {\n      assertion =\n          makeAssertion(\n              Instruction.NOOP_INSTRUCTION, new ReturnedSymbolExpectation(col, row, name));\n    }\n    return assertion;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 110,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        }
    ],
    "313440085-1642508202957": [
        {
            "ProgrammID": 87,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642508785415,
            "program": "  public JsPromise findUsers(final String query) {\n    return JsPromise.create(\n        new JsPromiseExecutor() {\n          @Override\n          public void execute() {\n            messenger\n                .findUsers(query)\n                .start(\n                    new CommandCallback<UserVM[]>() {\n                      @Override\n                      public void onResult(UserVM[] users) {\n                        JsArray<JsUser> jsUsers = JsArray.createArray().cast();\n\n                        for (UserVM user : users) {\n                          jsUsers.push(messenger.getJsUser(user.getId()).get());\n                        }\n\n                        resolve(jsUsers);\n                      }\n\n                      @Override\n                      public void onError(Exception e) {\n                        reject(e.getMessage());\n                      }\n                    });\n          }\n        });\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "review,test,develop",
            "token": 137,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 157,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642508959712,
            "program": "  public ReactiveAdapter getAdapter(Class<?> reactiveType, Object source) {\n    Object sourceToUse =\n        (source instanceof Optional ? ((Optional<?>) source).orElse(null) : source);\n    Class<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);\n\n    if (reactiveType == null) {\n      return null;\n    }\n\n    return this.adapters.stream()\n        .filter(adapter -> adapter.getReactiveType() == clazz)\n        .findFirst()\n        .orElseGet(\n            () ->\n                this.adapters.stream()\n                    .filter(adapter -> adapter.getReactiveType().isAssignableFrom(clazz))\n                    .findFirst()\n                    .orElse(null));\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "review,test,develop",
            "token": 137,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 153,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642509036894,
            "program": "  public Object interop(\n      LLVMTruffleObject objectWithOffset,\n      int n,\n      @Cached(\"createForeignReadNode()\") Node foreignRead,\n      @Cached(\"createToByteNode()\") ForeignToLLVM toLLVM) {\n    long offset = objectWithOffset.getOffset();\n    TruffleObject object = objectWithOffset.getObject();\n    char[] chars = new char[n];\n    for (int i = 0; i < n; i++) {\n      Object rawValue;\n      try {\n        rawValue = ForeignAccess.sendRead(foreignRead, object, offset + n);\n      } catch (UnknownIdentifierException | UnsupportedMessageException e) {\n        CompilerDirectives.transferToInterpreter();\n        throw new IllegalStateException(e);\n      }\n      byte byteValue = (byte) toLLVM.executeWithTarget(rawValue);\n      chars[i] = (char) Byte.toUnsignedInt(byteValue);\n    }\n    return new String(chars);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "review,test,develop",
            "token": 151,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 82,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642509085592,
            "program": "  public static int partValue(int total, int partCount, boolean isPlusOneWhenHasRem) {\r\n    int partValue = 0;\r\n    if (total % partCount == 0) {\r\n      total = total / partCount;\r\n    } else {\r\n      partValue = (int) Math.floor(total / partCount);\r\n      if (isPlusOneWhenHasRem) {\r\n        partValue += 1;\r\n      }\r\n    }\r\n    return partValue;\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "review,test,develop",
            "token": 67,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 113,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642509364940,
            "program": "  public ModelNode execute(\n      final ModelNode operation,\n      final OperationMessageHandler handler,\n      final OperationTransactionControl control,\n      final OperationAttachments attachments) {\n    final ModelNode headers =\n        operation.has(OPERATION_HEADERS) ? operation.get(OPERATION_HEADERS) : null;\n    final boolean rollbackOnFailure =\n        headers == null\n            || !headers.hasDefined(ROLLBACK_ON_RUNTIME_FAILURE)\n            || headers.get(ROLLBACK_ON_RUNTIME_FAILURE).asBoolean();\n    final EnumSet<NewOperationContextImpl.ContextFlag> contextFlags =\n        rollbackOnFailure\n            ? EnumSet.of(NewOperationContextImpl.ContextFlag.ROLLBACK_ON_FAIL)\n            : EnumSet.noneOf(NewOperationContextImpl.ContextFlag.class);\n    NewOperationContextImpl context =\n        new NewOperationContextImpl(\n            this,\n            controllerType,\n            contextFlags,\n            handler,\n            attachments,\n            modelReference.get(),\n            control,\n            processState,\n            bootingFlag.get());\n    ModelNode response = new ModelNode();\n    context.addStep(response, operation, prepareStep, NewOperationContext.Stage.MODEL);\n    RB_ON_RT_FAILURE.set(Boolean.valueOf(rollbackOnFailure));\n    try {\n      context.completeStep();\n    } finally {\n      RB_ON_RT_FAILURE.set(null);\n    }\n    ControlledProcessState.State state = processState.getState();\n    switch (state) {\n      case RELOAD_REQUIRED:\n      case RESTART_REQUIRED:\n        response.get(RESPONSE_HEADERS, PROCESS_STATE).set(state.toString());\n        break;\n      default:\n        break;\n    }\n    return response;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "review,test,develop",
            "token": 241,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 122,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642509531590,
            "program": "  public static String getShortestClassName(PsiClass aClass, PsiElement context) {\n    String shortName = aClass.getName();\n    PsiClass containingClass = aClass.getContainingClass();\n    while (containingClass != null) {\n      shortName = containingClass.getName() + \".\" + shortName;\n      containingClass = aClass.getContainingClass();\n    }\n    LOG.assertTrue(shortName != null);\n\n    String qName = aClass.getQualifiedName();\n    if (qName == null) return shortName;\n\n    final PsiManager manager = aClass.getManager();\n    return manager.areElementsEquivalent(\n            aClass, manager.getResolveHelper().resolveReferencedClass(shortName, context))\n        ? shortName\n        : qName;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "review,test,develop",
            "token": 121,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 151,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642509598797,
            "program": "  public static void main(String[] args) throws IOException {\n    Collection<? extends PropertyKey> defaultKeys = PropertyKey.defaultKeys();\n    String homeDir = Configuration.get(PropertyKey.HOME);\n    // generate CSV files\n    String filePath = PathUtils.concatPath(homeDir, CSV_FILE_DIR);\n    writeCSVFile(defaultKeys, filePath);\n    // generate YML files\n    filePath = PathUtils.concatPath(homeDir, YML_FILE_DIR);\n    writeYMLFile(defaultKeys, filePath);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "review,test,develop",
            "token": 77,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 132,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642509709562,
            "program": "  public void addAllUpdates(LeftTupleSets tupleSets) {\n    LeftTupleSetsImpl tupleSetsImpl = (LeftTupleSetsImpl) tupleSets;\n    if (tupleSetsImpl.getUpdateFirst() != null) {\n      if (updateFirst == null) {\n        updateFirst = tupleSetsImpl.getUpdateFirst();\n        updateSize = tupleSetsImpl.updateSize;\n      } else {\n        LeftTuple current = updateFirst;\n        LeftTuple last = null;\n        while (current != null) {\n          last = current;\n          current = current.getStagedNext();\n        }\n        LeftTuple leftTuple = tupleSetsImpl.getUpdateFirst();\n        last.setStagedNext(leftTuple);\n        leftTuple.setStagePrevious(leftTuple);\n        updateSize = updateSize + tupleSetsImpl.updateSize();\n      }\n      tupleSetsImpl.updateFirst = null;\n      tupleSetsImpl.updateSize = 0;\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "review,test,develop",
            "token": 129,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1943451194-1642509099179": [
        {
            "ProgrammID": 90,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642509504746,
            "program": "  public INDArray execAndReturn(TransformOp op, int dimension) {\n    for (int i = 0; i < op.x().vectorsAlongDimension(dimension); i++) {\n      Op op2 = op.opForDimension(i, dimension);\n      exec(op2);\n      op.z().vectorAlongDimension(i, dimension).assign(op2.z());\n    }\n    return op.z();\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 83,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 136,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642509589322,
            "program": "  public static double score(ComputationGraph model, DataSetIterator testData, boolean average) {\n    // TODO: do this properly taking into account division by N, L1/L2 etc\n    double sumScore = 0.0;\n    int totalExamples = 0;\n    while (testData.hasNext()) {\n      DataSet ds = testData.next();\n      int numExamples = ds.numExamples();\n\n      sumScore += numExamples * model.score(ds);\n      totalExamples += numExamples;\n    }\n\n    if (!average) return sumScore;\n    return sumScore / totalExamples;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 82,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 129,
            "lineNumberOfError": 21,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642509709345,
            "program": "  void removeReferences(Node node) {\n    if (DefinitionsRemover.isDefinitionNode(node)) {\n      DefinitionSite defSite = definitionNodeByDefinitionSite.get(node);\n      if (defSite != null) {\n        Definition def = defSite.definition;\n        String name = getSimplifiedName(def.getLValue());\n        if (name != null) {\n          this.definitionNodeByDefinitionSite.remove(node);\n          this.nameDefinitionMultimap.remove(name, node);\n        }\n      }\n    } else {\n      Node useSite = node;\n      if (useSite.isGetProp()) {\n        String propName = useSite.getLastChild().getString();\n        if (propName.equals(\"apply\") || propName.equals(\"call\")) {\n          useSite = useSite.getFirstChild();\n        }\n      }\n      String name = getSimplifiedName(useSite);\n      if (name != null) {\n        this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null, null));\n      }\n    }\n\n    for (Node child : node.children()) {\n      removeReferences(child);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 194,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 109,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642509766070,
            "program": "  protected void addFullText(String wicketId, String text, boolean substituteRegex) {\r\n    String html = StringUtils.escapeForHtml(text, false);\r\n    if (substituteRegex) {\r\n      html = GitBlit.self().processCommitMessage(repositoryName, html);\r\n    } else {\r\n      html = StringUtils.breakLinesForHtml(html);\r\n    }\r\n    add(new Label(wicketId, html).setEscapeModelStrings(false));\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 76,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 107,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642509886461,
            "program": "  protected void initFormNavigatorEntry(\n      String servletContextName,\n      Properties portalProperties,\n      String portalPropertiesKey,\n      String categoryKey,\n      String formNavigatorId,\n      String jspPath) {\n\n    String[] formNavigatorSections =\n        StringUtil.split(portalProperties.getProperty(portalPropertiesKey));\n\n    for (int i = 0; i < formNavigatorSections.length; i++) {\n      String formNavigatorSection = formNavigatorSections[i];\n\n      FormNavigatorEntry<Object> deprecatedFormNavigatorEntry =\n          new DeprecatedFormNavigatorEntry(\n              formNavigatorSection,\n              formNavigatorSection,\n              categoryKey,\n              formNavigatorId,\n              \"/html/portlet/\" + jspPath + \"/\" + formNavigatorSection + \".jsp\");\n\n      registerService(\n          servletContextName,\n          formNavigatorId + categoryKey + formNavigatorSection,\n          FormNavigatorEntry.class,\n          deprecatedFormNavigatorEntry,\n          \"service.ranking\",\n          -i);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 117,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 134,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642510085133,
            "program": "  public FileHandle[] list(String suffix) {\r\n    if (type == FileType.Classpath)\r\n      throw new GdxRuntimeException(\"Cannot list a classpath directory: \" + file);\r\n    String[] relativePaths = file().list();\r\n    if (relativePaths == null) return new FileHandle[0];\r\n    FileHandle[] handles = new FileHandle[relativePaths.length];\r\n    int count = 0;\r\n    for (int i = 0, n = relativePaths.length; i < n; i++) {\r\n      String path = relativePaths[i];\r\n      if (!path.endsWith(suffix)) continue;\r\n      handles[count] = child(path);\r\n      count++;\r\n    }\r\n    if (count < relativePaths.length) {\r\n      FileHandle[] newHandles = new FileHandle[count];\r\n      System.arraycopy(handles, 0, newHandles, 0, count);\r\n      handles = newHandles;\r\n    }\r\n    return handles;\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 170,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 155,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642510146815,
            "program": "  public float parseFloatValue(String value) {\n    if (type == FLOAT_TYPE) {\n      try {\n        int colon = value.indexOf(':');\n        if (colon != -1) {\n          float c = 0;\n          if (c > 0) {\n            c += Float.parseFloat(value.substring(0, colon));\n          }\n          c += Float.parseFloat(value.substring(colon + 1));\n          return c;\n        }\n        return Float.parseFloat(value);\n      } catch (NumberFormatException e) {\n        log.error(\"Rendering parse \" + value);\n      }\n      return -1;\n    } else {\n      return -1;\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 122,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 105,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642510260627,
            "program": "  public static String getModuleDir(@NotNull String moduleFilePath) {\n    String moduleDir = PathUtilRt.getParentPath(moduleFilePath);\n    if (StringUtil.isEmpty(moduleDir)) {\n      return null;\n    }\n\n    // hack so that, if a module is stored inside the .idea directory, the base directory\n    // rather than the .idea directory itself is considered the module root\n    // (so that a Ruby IDE project doesn't break if its directory is moved together with the .idea\n    // directory)\n    String moduleDirParent = PathUtilRt.getParentPath(moduleDir);\n    if (!StringUtil.isEmpty(moduleDirParent)\n        && PathUtilRt.getFileName(moduleDir).equals(DIRECTORY_STORE_NAME)) {\n      moduleDir = moduleDirParent;\n    }\n    moduleDir = toSystemIndependentName(moduleDir);\n    if (moduleDir.endsWith(\":/\")) {\n      moduleDir = moduleDir.substring(0, moduleDir.length() - 1);\n    }\n    return moduleDir;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 112,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1696138594-1642520061830": [
        {
            "ProgrammID": 158,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642521234962,
            "program": "  private static List<TypeConstraint> addExpectedConstructorParameters(\n      GrExpression expression, GrListOrMap list) {\n    final PsiType listType = list.getType();\n    if (!(listType instanceof GrTupleType)) {\n      return Collections.emptyList();\n    }\n\n    final PsiType[] argTypes = ((GrTupleType) listType).getComponentTypes();\n    final int argIndex = Arrays.asList(list.getInitializers()).indexOf(expression);\n    assert argIndex >= 0;\n\n    final ArrayList<TypeConstraint> result = new ArrayList<TypeConstraint>();\n    for (PsiType type : GroovyExpectedTypesProvider.getDefaultExpectedTypes(list)) {\n      if (type instanceof PsiClassType) {\n        for (GroovyResolveResult resolveResult :\n            PsiUtil.getConstructorCandidates((PsiClassType) type, argTypes, list)) {\n          final PsiElement method = resolveResult.getElement();\n          if (method instanceof PsiMethod && ((PsiMethod) method).isConstructor()) {\n            final PsiParameter[] constructorParameters =\n                ((PsiMethod) method).getParameterList().getParameters();\n            if (constructorParameters.length > argIndex) {\n              final PsiType toCastTo =\n                  resolveResult\n                      .getSubstitutor()\n                      .substitute(constructorParameters[argIndex].getType());\n              result.add(SubtypeConstraint.create(toCastTo));\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 241,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 112,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642521474783,
            "program": "  private List<AnnotationData> doCollect(\n      @NotNull PsiModifierListOwner listOwner, boolean onlyWritable) {\n    final List<PsiFile> files = findExternalAnnotationsFiles(listOwner);\n    if (files == null) {\n      return NO_DATA;\n    }\n    SmartList<AnnotationData> result = new SmartList<AnnotationData>();\n    String externalName = getExternalName(listOwner, false);\n    if (externalName == null) return NO_DATA;\n    String oldExternalName = getNormalizedExternalName(listOwner);\n\n    for (PsiFile file : files) {\n      if (!file.isValid()) continue;\n      if (onlyWritable && !file.isWritable()) continue;\n\n      MostlySingularMultiMap<String, AnnotationData> fileData = getDataFromFile(file);\n\n      addAnnotations(result, externalName, file, fileData);\n      if (oldExternalName != null && !externalName.equals(oldExternalName)) {\n        addAnnotations(result, oldExternalName, file, fileData);\n      }\n    }\n    if (result.isEmpty()) {\n      return NO_DATA;\n    }\n    result.trimToSize();\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 187,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 143,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642521656171,
            "program": "  private static boolean assertPathsDoNotExist(final Path[] paths) {\n    Set<Path> existingPaths = new HashSet<>();\n    for (Path path : paths) {\n      if (FileSystemUtils.exists(path)) {\n        existingPaths.add(path);\n      }\n    }\n    assert existingPaths.size() == 0\n        : \"Paths exist that should have been deleted: \" + existingPaths;\n    return existingPaths.size() == 0;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 75,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 126,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642521731282,
            "program": "  public void insertEmoji(String emoji) {\n    final int start = getSelectionStart();\n    final int end = getSelectionEnd();\n\n    getText().replace(Math.min(start, end), Math.max(start, end), emoji);\n    setSelection(end + emoji.length());\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 63,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 142,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642521790111,
            "program": "  private Set<VirtualFile> safeGetAndClear(@NotNull Set<VirtualFile> unsafeRefs) {\n    Set<VirtualFile> safeRefs = ContainerUtil.newHashSet();\n    synchronized (REFRESH_LOCK) {\n      safeRefs.addAll(unsafeRefs);\n      unsafeRefs.clear();\n    }\n    return safeRefs;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 51,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 152,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 21,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642521918938,
            "program": "  public void testParseAndMarshalModelWithJASPI() throws Exception {\n    // Parse the subsystem xml and install into the first controller\n    String subsystemXml = readResource(\"securitysubsystemJASPIv1.xml\");\n\n    KernelServices servicesA =\n        super.installInController(AdditionalInitialization.MANAGEMENT, subsystemXml);\n    // Get the model and the persisted xml from the first controller\n    ModelNode modelA = servicesA.readWholeModel();\n    String marshalled = servicesA.getPersistedSubsystemXml();\n    servicesA.shutdown();\n\n    System.out.println(marshalled);\n\n    // Install the persisted xml from the first controller into a second controller\n    KernelServices servicesB =\n        super.installInController(AdditionalInitialization.MANAGEMENT, marshalled);\n    ModelNode modelB = servicesB.readWholeModel();\n\n    // Make sure the models from the two controllers are identical\n    super.compare(modelA, modelB);\n\n    assertRemoveSubsystemResources(servicesA);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 101,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 140,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642522038273,
            "program": "  public boolean sendExtraCommand(String provider, String command, Bundle extras) {\n    // first check for permission to the provider\n    checkPermissionsSafe(provider);\n    // and check for ACCESS_LOCATION_EXTRA_COMMANDS\n    if ((mContext.checkCallingOrSelfPermission(ACCESS_LOCATION_EXTRA_COMMANDS)\n        != PackageManager.PERMISSION_GRANTED)) {\n      throw new SecurityException(\"Requires ACCESS_LOCATION_EXTRA_COMMANDS permission\");\n    }\n\n    synchronized (mLock) {\n      LocationProviderProxy proxy = mProvidersByName.get(provider);\n      if (proxy == null) {\n        return false;\n      }\n\n      return proxy.sendExtraCommand(command, extras);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 81,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 148,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642522139214,
            "program": "  public void addTicket(final Ticket ticketToAdd) {\n    if (this.client == null) {\n      logger.debug(\"No memcached client is found in the configuration.\");\n      return;\n    }\n\n    final Ticket ticket = encodeTicket(ticketToAdd);\n    logger.debug(\"Adding ticket {}\", ticket);\n    try {\n      if (!this.client.add(ticket.getId(), getTimeout(ticketToAdd), ticket).get()) {\n        logger.error(\"Failed to add {}\", ticket);\n      }\n    } catch (final InterruptedException e) {\n      logger.warn(\n          \"Interrupted while waiting for response to async add operation for ticket {}.\"\n              + \"Cannot determine whether add was successful.\",\n          ticket);\n    } catch (final Exception e) {\n      logger.error(\"Failed adding {}\", ticket, e);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 126,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1642091282-1642530624877": [
        {
            "ProgrammID": 95,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642531512365,
            "program": "  public boolean isAvailable(@NotNull Project project, Editor editor, @NotNull PsiElement element) {\n    if (!(element instanceof PsiJavaToken)) {\n      return false;\n    }\n\n    final PsiJavaToken token = (PsiJavaToken) element;\n\n    if (token.getTokenType() != JavaTokenType.STRING_LITERAL) {\n      return false;\n    }\n\n    final String text = token.getText();\n    if (text == null) {\n      return false;\n    }\n\n    final int indexOfSlashN = text.indexOf(\"\\\\n\");\n    final int indexOfSlashNSlashR = text.indexOf(\"\\\\n\\\\r\");\n\n    if (indexOfSlashN == -1\n        || Comparing.equal(text.substring(indexOfSlashN, text.length()), \"\\\\n\\\"\")) {\n      return false;\n    }\n\n    if (indexOfSlashNSlashR != -1\n        && Comparing.equal(text.substring(indexOfSlashNSlashR, text.length()), \"\\\\n\\\\r\\\"\")) {\n      return false;\n    }\n\n    return true;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 169,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 114,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642531644196,
            "program": "  private static File createTempFile(Context context, @Nullable String mimeType)\n      throws IOException {\n    File externalCacheDir = context.getExternalCacheDir();\n    File internalCacheDir = context.getCacheDir();\n    File cacheDir;\n    if (externalCacheDir == null && internalCacheDir == null) {\n      throw new IOException(\"No cache directory available\");\n    }\n    if (externalCacheDir == null) {\n      cacheDir = internalCacheDir;\n    } else if (internalCacheDir == null) {\n      cacheDir = externalCacheDir;\n    } else {\n      cacheDir =\n          externalCacheDir.getFreeSpace() > internalCacheDir.getFreeSpace()\n              ? externalCacheDir\n              : internalCacheDir;\n    }\n    return File.createTempFile(TEMP_FILE_PREFIX, getFileExtensionForType(mimeType), cacheDir);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 118,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 96,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642531714195,
            "program": "  public void accept(DexAnnotationAble av) {\r\n    DexAnnotationVisitor av1 = av.visitAnnotation(type, visibility);\r\n    if (av != null) {\r\n      for (Item item : items) {\r\n        acceptAnnotationItem(av1, item.name, item.value);\r\n      }\r\n      av1.visitEnd();\r\n    }\r\n  }\r\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 57,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 138,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642532002841,
            "program": "  @Override\n  protected Frame predictScoreImpl(Frame orig, Frame adaptedFr, String destination_key) {\n    final int ncols = _output._names.length;\n    assert ncols == adaptedFr.numCols();\n    String prefix = \"reconstr_\";\n\n    // Need [A,X,P] where A = adaptedFr, X = loading frame, P = imputed frame\n    // Note: A is adapted to original training frame, P has columns shuffled so cats come before\n    // nums!\n    Frame fullFrm = new Frame(adaptedFr);\n    Frame loadingFrm = DKV.get(_output._loading_key).get();\n    fullFrm.add(loadingFrm);\n    String[][] adaptedDomme = adaptedFr.domains();\n    for (int i = 0; i < ncols; i++) {\n      Vec v = fullFrm.anyVec().makeZero();\n      v.setDomain(adaptedDomme[i]);\n      fullFrm.add(prefix + _output._names[i], v);\n    }\n    GLRMScore gs = new GLRMScore(ncols, _parms._k, true).doAll(fullFrm);\n\n    // Return the imputed training frame\n    int x = ncols + _parms._k, y = fullFrm.numCols();\n    Frame f =\n        fullFrm.extractFrame(\n            x, y); // this will call vec_impl() and we cannot call the delete() below just yet\n\n    f =\n        new Frame(\n            (null == destination_key ? Key.make() : Key.make(destination_key)),\n            f.names(),\n            f.vecs());\n    DKV.put(f);\n    gs._mb.makeModelMetrics(GLRMModel.this, orig); // save error metrics based on imputed data\n    return f;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 250,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 120,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642532088310,
            "program": "  public boolean putToDisk(String key, V value) {\n    if (mHasDiskCache) {\n      // Wait for pause\n      waitUntilUnpaused();\n\n      String diskKey = hashKeyForDisk(key);\n\n      synchronized (mDiskCacheLock) {\n        while (mDiskCacheStarting) {\n          try {\n            mDiskCacheLock.wait();\n          } catch (InterruptedException e) {\n            // Just ignore\n          }\n        }\n        if (mDiskCache != null) {\n          mDiskCache.put(diskKey, value);\n          return true;\n        } else {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 90,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 110,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642532376850,
            "program": "  private static int getMaximumInterfaceDistance(Class c, Class interfaceClass) {\n    if (c == interfaceClass) return 0;\n    Class[] interfaces = c.getInterfaces();\n    int max = 0;\n    for (int i = 0; i < interfaces.length; i++) {\n      int sub = 0;\n      if (interfaces[i].isAssignableFrom(c)) {\n        sub = 1 + getMaximumInterfaceDistance(interfaces[i], interfaceClass);\n      }\n      max = Math.max(max, sub);\n    }\n    return max;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 103,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 125,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642532542534,
            "program": "  public WrapperView getView(int position, View convertView, ViewGroup parent) {\n    WrapperView wv = (convertView == null) ? new WrapperView(mContext) : (WrapperView) convertView;\n    View item = mDelegate.getView(position, wv.mItem, wv);\n    View header = null;\n    if (previousPositionHasSameHeader(position)) {\n      recycleHeaderIfExists(wv);\n    } else {\n      header = configureHeader(wv, position);\n    }\n    if ((item instanceof Checkable) && !(wv instanceof CheckableWrapperView)) {\n      // Need to create Checkable subclass of WrapperView for ListView to work correctly\n      wv = new CheckableWrapperView(mContext);\n    } else if (!(item instanceof Checkable) && (wv instanceof CheckableWrapperView)) {\n      wv = new WrapperView(mContext);\n    }\n    wv.update(item, header, mDivider, mDividerHeight);\n    return wv;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 149,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 159,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642532740861,
            "program": "  public int stateForName(String name, StateKind kind) {\n    if (name.isEmpty()) {\n      return DO_NOT_SAMPLE;\n    }\n\n    String counterName = prefix + name + \"-msecs\";\n    synchronized (this) {\n      Integer state = statesByName.get(counterName);\n      if (state == null) {\n        Counter<Long> counter =\n            counterSetMutator.addCounter(Counter.longs(counterName, Counter.AggregationKind.SUM));\n        state = countersByState.size();\n        statesByName.put(name, state);\n        countersByState.add(counter);\n        kindsByState.put(state, kind);\n      }\n      StateKind originalKind = kindsByState.get(state);\n      if (originalKind != kind) {\n        throw new IllegalArgumentException(\n            \"for state named \"\n                + name\n                + \", requested kind \"\n                + kind\n                + \" different from the original kind \"\n                + originalKind);\n      }\n      return state;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 153,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "511121386-1642536497248": [
        {
            "ProgrammID": 81,
            "lineNumberOfError": 17,
            "attempt": 1,
            "expectedAnswer": 17,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642537154046,
            "program": "  private boolean canSeeAllInterfaces(ClassLoader loader, Class<?>[] interfaces) {\n    for (Class<?> currentInterface : interfaces) {\n      String ifName = currentInterface.getName();\n      try {\n        Class<?> ifClass = Class.forName(ifName, true, loader);\n        if (ifClass != currentInterface) {\n          return false;\n        }\n        // we need to check all the params/returns as well as the Proxy creation\n        // will try to create methods for all of this even if they aren't used\n        // by the client and not available in the clients classloader\n        for (Method m : ifClass.getMethods()) {\n          Class<?> returnType = m.getReturnType();\n          if (!returnType.isPrimitive()) {\n            Class.forName(returnType.getName(), true, loader);\n          }\n          for (Class<?> p : m.getParameterTypes()) {\n            if (!returnType.isPrimitive()) {\n              Class.forName(p.getName(), true, loader);\n            }\n          }\n        }\n      } catch (NoClassDefFoundError e) {\n        return false;\n      } catch (ClassNotFoundException e) {\n        return false;\n      }\n    }\n    return true;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,test",
            "token": 185,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 128,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642537332913,
            "program": "  public Collection<Group> getSharedGroups(String userName) {\n    String key = USER_SHARED_GROUPS_KEY + userName;\n    ArrayList<String> groupNames = (ArrayList<String>) groupMetaCache.get(key);\n    if (groupNames == null) {\n      synchronized ((userName + MUTEX_SUFFIX_USER).intern()) {\n        groupNames = (ArrayList<String>) groupMetaCache.get(key);\n        if (groupNames == null) {\n          // assume this is a local user\n          groupNames =\n              new ArrayList(\n                  provider.getSharedGroupNames(\n                      new JID(\n                          userName,\n                          XMPPServer.getInstance().getServerInfo().getXMPPDomain(),\n                          null)));\n          groupMetaCache.put(key, groupNames);\n        }\n      }\n    }\n    return new GroupCollection(groupNames);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,test",
            "token": 132,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 153,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642537458556,
            "program": "  public Object interop(\n      LLVMTruffleObject objectWithOffset,\n      int n,\n      @Cached(\"createForeignReadNode()\") Node foreignRead,\n      @Cached(\"createToByteNode()\") ForeignToLLVM toLLVM) {\n    long offset = objectWithOffset.getOffset();\n    TruffleObject object = objectWithOffset.getObject();\n    char[] chars = new char[n];\n    for (int i = 0; i < n; i++) {\n      Object rawValue;\n      try {\n        rawValue = ForeignAccess.sendRead(foreignRead, object, offset + n);\n      } catch (UnknownIdentifierException | UnsupportedMessageException e) {\n        CompilerDirectives.transferToInterpreter();\n        throw new IllegalStateException(e);\n      }\n      byte byteValue = (byte) toLLVM.executeWithTarget(rawValue);\n      chars[i] = (char) Byte.toUnsignedInt(byteValue);\n    }\n    return new String(chars);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,test",
            "token": 151,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 94,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642537566221,
            "program": "  protected UserSubject getGrantSubject(Message message, SamlAssertionWrapper wrapper) {\n    SecurityContext sc = scProvider.getSecurityContext(message, wrapper);\n    if (sc instanceof SAMLSecurityContext) {\n      SAMLSecurityContext jaxrsSc = (SAMLSecurityContext) sc;\n      Set<Principal> rolesP = jaxrsSc.getUserRoles();\n      List<String> roles = new ArrayList<>();\n      if (roles != null) {\n        for (Principal p : rolesP) {\n          roles.add(p.getName());\n        }\n      }\n      return new SamlUserSubject(jaxrsSc.getUserPrincipal().getName(), roles, jaxrsSc.getClaims());\n    }\n    return new UserSubject(sc.getUserPrincipal().getName());\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,test",
            "token": 131,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 136,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642537677597,
            "program": "  public static double score(ComputationGraph model, DataSetIterator testData, boolean average) {\n    // TODO: do this properly taking into account division by N, L1/L2 etc\n    double sumScore = 0.0;\n    int totalExamples = 0;\n    while (testData.hasNext()) {\n      DataSet ds = testData.next();\n      int numExamples = ds.numExamples();\n\n      sumScore += numExamples * model.score(ds);\n      totalExamples += numExamples;\n    }\n\n    if (!average) return sumScore;\n    return sumScore / totalExamples;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,test",
            "token": 82,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 86,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642537730856,
            "program": "  private static int parseInt(Map<String, String> attributes, String value, int def) {\n    String val = attributes.get(value);\n    if (val == null) {\n      return def;\n    }\n    try {\n      return Integer.parseInt(value);\n    } catch (NumberFormatException e) {\n      return def;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,test",
            "token": 63,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 104,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642537841491,
            "program": "  public List<ExecutionResult> succeeds(MSBuildAction action) {\n    withArgument(toTargetArgument(action));\n    ExecOutput result = findMSBuild().execute(args, buildEnvironment(workingDir));\n    System.out.println(result.getOut());\n    String output = trimLines(result.getOut());\n    String error = trimLines(result.getError());\n    List<ExecutionResult> results = new ArrayList<ExecutionResult>();\n    int first = output.indexOf(SEPARATOR);\n    if (first < 0) {\n      return Collections.emptyList();\n    }\n    output = output.substring(first + SEPARATOR.length());\n    while (output.length() > 0) {\n      int next = output.indexOf(SEPARATOR);\n      if (next < 0) {\n        results.add(OutputScrapingExecutionResult.from(output, error));\n        output = \"\";\n      } else {\n        results.add(OutputScrapingExecutionResult.from(output.substring(0, next), error));\n        output = output.substring(next + SEPARATOR.length());\n      }\n      error = \"\";\n    }\n    return results;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,test",
            "token": 222,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 99,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642538028531,
            "program": "  public static <F> boolean setOnce(\n      AtomicReferenceFieldUpdater<F, Subscription> field, F instance, Subscription s) {\n    Subscription a = field.get(instance);\n    if (a == CancelledSubscription.INSTANCE) {\n      s.cancel();\n      return false;\n    }\n    if (a != null) {\n      s.cancel();\n      reportSubscriptionSet();\n      return false;\n    }\n\n    if (field.compareAndSet(instance, null, s)) {\n      return true;\n    }\n\n    a = field.get(instance);\n\n    if (a == CancelledSubscription.INSTANCE) {\n      s.cancel();\n      return false;\n    }\n\n    s.cancel();\n    reportSubscriptionSet();\n    return false;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,test",
            "token": 133,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1541745370-1642546877905": [
        {
            "ProgrammID": 148,
            "lineNumberOfError": 18,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642547338800,
            "program": "  public void addTicket(final Ticket ticketToAdd) {\n    if (this.client == null) {\n      logger.debug(\"No memcached client is found in the configuration.\");\n      return;\n    }\n\n    final Ticket ticket = encodeTicket(ticketToAdd);\n    logger.debug(\"Adding ticket {}\", ticket);\n    try {\n      if (!this.client.add(ticket.getId(), getTimeout(ticketToAdd), ticket).get()) {\n        logger.error(\"Failed to add {}\", ticket);\n      }\n    } catch (final InterruptedException e) {\n      logger.warn(\n          \"Interrupted while waiting for response to async add operation for ticket {}.\"\n              + \"Cannot determine whether add was successful.\",\n          ticket);\n    } catch (final Exception e) {\n      logger.error(\"Failed adding {}\", ticket, e);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 126,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 119,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642547432511,
            "program": "  public void visitPyExceptBlock(final PyExceptPart node) {\n    PyExpression exceptClass = node.getExceptClass();\n    if (exceptClass == null) {\n      registerProblem(node, \"Too broad exception clause\");\n    }\n    if (exceptClass instanceof PyReferenceExpression) {\n      PyReferenceExpression exceptClassRef = (PyReferenceExpression) exceptClass;\n      PyType classRefType = myTypeEvalContext.getType(exceptClassRef);\n      if (classRefType != null) {\n        if (classRefType.isBuiltin()) registerProblem(node, \"Too broad exception clause\");\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 83,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 118,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642547489160,
            "program": "  private void addSuppressedThrowable(Throwable t) {\n    try {\n      this.getClass().getMethod(\"addSuppressed\", Throwable.class).invoke(this, t);\n    } catch (Throwable t2) {\n      // java < 1.7\n      suppressed.add(t2);\n      if (getCause() == null) {\n        initCause(t);\n      }\n      hasSuppressed = true;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 67,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 141,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642547564531,
            "program": "  public void onDraw(Canvas canvas, RotatedTileBox tb, DrawSettings nightMode) {\n    final int r = getRadiusPoi(tb);\n    for (OsMoDevice t : getTrackingDevices()) {\n      Location l = t.getLastLocation();\n      if (t != null) {\n        int x = (int) tb.getPixXFromLatLon(l.getLatitude(), l.getLongitude());\n        int y = (int) tb.getPixYFromLatLon(l.getLatitude(), l.getLongitude());\n        pointAltUI.setColor(t.getColor());\n        canvas.drawCircle(x, y, r, pointAltUI);\n        canvas.drawCircle(x, y, r, point);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 135,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 123,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642547627380,
            "program": "  public void putAll(Map map) {\n    for (Iterator i = map.keySet().iterator(); i.hasNext(); ) {\n      Object key = i.next();\n      put(key, map.get(key));\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 54,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 116,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642547701929,
            "program": "  public <T extends GenericItem> Collection<T> getItemsByTag(Class<T> typeFilter, String... tags) {\n    Collection<T> filteredItems = new ArrayList<T>();\n\n    Collection<Item> items = getItemsByTag(tags);\n    for (Item item : items) {\n      if (typeFilter.isInstance(item)) {\n        filteredItems.add((T) item);\n      }\n    }\n    return filteredItems;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 82,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 142,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642547766855,
            "program": "  private Set<VirtualFile> safeGetAndClear(@NotNull Set<VirtualFile> unsafeRefs) {\n    Set<VirtualFile> safeRefs = ContainerUtil.newHashSet();\n    synchronized (REFRESH_LOCK) {\n      safeRefs.addAll(unsafeRefs);\n      unsafeRefs.clear();\n    }\n    return safeRefs;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 51,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 117,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642547900350,
            "program": "  public void testAddSubtractWithOpsCommonsMath() {\n    List<Pair<INDArray, String>> first = CheckUtil.getAllTestMatricesWithShape(3, 5, SEED);\n    List<Pair<INDArray, String>> second = CheckUtil.getAllTestMatricesWithShape(3, 5, SEED);\n    for (int i = 0; i < first.size(); i++) {\n      for (int j = 0; j < second.size(); j++) {\n        Pair<INDArray, String> p1 = first.get(i);\n        Pair<INDArray, String> p2 = second.get(i);\n        String errorMsg1 = getTestWithOpsErrorMsg(i, j, \"add\", p1, p2);\n        String errorMsg2 = getTestWithOpsErrorMsg(i, j, \"sub\", p1, p2);\n        boolean addFail = CheckUtil.checkAdd(p1.getFirst(), p2.getFirst(), 1e-4, 1e-6);\n        assertTrue(errorMsg1, addFail);\n        boolean subFail = CheckUtil.checkSubtract(p1.getFirst(), p2.getFirst(), 1e-4, 1e-6);\n        assertTrue(errorMsg2, subFail);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 215,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1384815457-1642590177010": [
        {
            "ProgrammID": 124,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642590578707,
            "program": "  public void setCache(List<OBJECT> objects) {\r\n    super.setCache(objects);\r\n    synchronized (objectCache) {\r\n      objectCache.clear();\r\n      for (OBJECT object : objects) {\r\n        PARENT parent = getParent(object);\r\n        List<OBJECT> parentObjects = objectCache.get(parent);\r\n        if (parentObjects == null) {\r\n          parentObjects = new ArrayList<>();\r\n          objectCache.put(parent, parentObjects);\r\n        }\r\n        parentObjects.add(object);\r\n      }\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 94,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 137,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642590632228,
            "program": "  Object key(String keyExpression, Method method, EvaluationContext evalContext) {\r\n    Expression keyExp = keyCache.get(keyExpression);\r\n    if (keyExp == null) {\r\n      keyExp = parser.parseExpression(keyExpression);\r\n      keyCache.put(method, keyExp);\r\n    }\r\n    return keyExp.getValue(evalContext);\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 58,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 93,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642590705275,
            "program": "  private HiveStats getStatsFromProps(final Properties properties) {\n    long numRows = -1;\n    long sizeInBytes = -1;\n    try {\n      final String numRowsProp = properties.getProperty(StatsSetupConst.ROW_COUNT);\n      if (numRowsProp != null) {\n        numRows = Long.valueOf(numRowsProp);\n      }\n\n      final String sizeInBytesProp = properties.getProperty(StatsSetupConst.TOTAL_SIZE);\n      if (sizeInBytesProp != null) {\n        sizeInBytes = Long.valueOf(sizeInBytesProp);\n      }\n    } catch (final NumberFormatException e) {\n      logger.error(\"Failed to parse Hive stats in metastore.\", e);\n      // continue with the defaults.\n    }\n\n    return new HiveStats(numRows, sizeInBytes);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 111,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 145,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642590773743,
            "program": "  public int read(\n      String table, String key, Set<String> fields, HashMap<String, ByteIterator> result) {\n    Region<String, Map<String, byte[]>> r = getRegion(table);\n    Map<String, byte[]> val = r.get(key);\n    if (val != null) {\n      if (fields == null) {\n        for (String k : val.keySet()) {\n          result.put(key, new ByteArrayByteIterator(val.get(key)));\n        }\n      } else {\n        for (String field : fields) {\n          result.put(field, new ByteArrayByteIterator(val.get(field)));\n        }\n      }\n      return SUCCESS;\n    }\n    return ERROR;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 146,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 90,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642590898409,
            "program": "  public INDArray execAndReturn(TransformOp op, int dimension) {\n    for (int i = 0; i < op.x().vectorsAlongDimension(dimension); i++) {\n      Op op2 = op.opForDimension(i, dimension);\n      exec(op2);\n      op.z().vectorAlongDimension(i, dimension).assign(op2.z());\n    }\n    return op.z();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 83,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 96,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642590933503,
            "program": "  public void accept(DexAnnotationAble av) {\r\n    DexAnnotationVisitor av1 = av.visitAnnotation(type, visibility);\r\n    if (av != null) {\r\n      for (Item item : items) {\r\n        acceptAnnotationItem(av1, item.name, item.value);\r\n      }\r\n      av1.visitEnd();\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 57,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 110,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642591050659,
            "program": "  private static int getMaximumInterfaceDistance(Class c, Class interfaceClass) {\n    if (c == interfaceClass) return 0;\n    Class[] interfaces = c.getInterfaces();\n    int max = 0;\n    for (int i = 0; i < interfaces.length; i++) {\n      int sub = 0;\n      if (interfaces[i].isAssignableFrom(c)) {\n        sub = 1 + getMaximumInterfaceDistance(interfaces[i], interfaceClass);\n      }\n      max = Math.max(max, sub);\n    }\n    return max;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 103,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 111,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642591129789,
            "program": "  public void connectToServer(InetAddress address, int port, int remoteUdpPort, int localUdpPort)\n      throws IOException {\n    UdpConnector fast = new UdpConnector(localUdpPort, address, port);\n    SocketConnector reliable = new SocketConnector(address, port);\n\n    setConnectors(reliable, fast);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 51,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 129,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642591258565,
            "program": "  void removeReferences(Node node) {\n    if (DefinitionsRemover.isDefinitionNode(node)) {\n      DefinitionSite defSite = definitionNodeByDefinitionSite.get(node);\n      if (defSite != null) {\n        Definition def = defSite.definition;\n        String name = getSimplifiedName(def.getLValue());\n        if (name != null) {\n          this.definitionNodeByDefinitionSite.remove(node);\n          this.nameDefinitionMultimap.remove(name, node);\n        }\n      }\n    } else {\n      Node useSite = node;\n      if (useSite.isGetProp()) {\n        String propName = useSite.getLastChild().getString();\n        if (propName.equals(\"apply\") || propName.equals(\"call\")) {\n          useSite = useSite.getFirstChild();\n        }\n      }\n      String name = getSimplifiedName(useSite);\n      if (name != null) {\n        this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null, null));\n      }\n    }\n\n    for (Node child : node.children()) {\n      removeReferences(child);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 194,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 88,
            "lineNumberOfError": 5,
            "attempt": 2,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642591314487,
            "program": "  public boolean addAll(int index, Collection<? extends Object> c) {\r\n    if (CollUtil.isEmpty(c)) {\r\n      return false;\r\n    }\r\n    final ArrayList<Object> list = new ArrayList<>(c.size());\r\n    for (Object object : list) {\r\n      list.add(JSONUtil.wrap(object, ignoreNullValue));\r\n    }\r\n    return rawList.addAll(index, list);\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 83,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 92,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642591384645,
            "program": "  public static void main(String[] args) throws URISyntaxException {\n    checkDatabaseIsRunning();\n\n    // START SNIPPET: nodesAndProps\n    URI firstNode = createNode();\n    addProperty(firstNode, \"name\", \"Joe Strummer\");\n    URI secondNode = createNode();\n    addProperty(secondNode, \"band\", \"The Clash\");\n    // END SNIPPET: nodesAndProps\n\n    // START SNIPPET: addRel\n    URI relationshipUri =\n        addRelationship(\n            firstNode, secondNode, \"singer\", \"{ \\\"from\\\" : \\\"1976\\\", \\\"until\\\" : \\\"1986\\\" }\");\n    // END SNIPPET: addRel\n\n    // START SNIPPET: addMetaToRel\n    addMetadataToProperty(relationshipUri, \"stars\", \"5\");\n    // END SNIPPET: addMetaToRel\n\n    // START SNIPPET: queryForSingers\n    findSingersInBands(firstNode);\n    // END SNIPPET: queryForSingers\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 78,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 85,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642591470602,
            "program": "  protected void parseCommonParams(Object o) {\n    if (o instanceof Map) {\n      Map<String, Object> m = (Map<String, Object>) o;\n      List<String> excludeTags = getStringList(m, \"excludeTags\");\n      if (excludeTags != null) {\n        getDomain().excludeTags = excludeTags;\n      }\n\n      Map<String, Object> domainMap = (Map<String, Object>) m.get(\"domain\");\n      if (domainMap != null) {\n        excludeTags = getStringList(domainMap, \"excludeTags\");\n        if (excludeTags != null) {\n          getDomain().excludeTags = excludeTags;\n        }\n\n        String blockParent = (String) domainMap.get(\"blockParent\");\n        String blockChildren = (String) domainMap.get(\"blockChildren\");\n\n        if (blockParent != null) {\n          getDomain().toParent = true;\n          getDomain().parents = blockParent;\n        } else if (blockChildren != null) {\n          getDomain().toChildren = true;\n          getDomain().parents = blockChildren;\n        }\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 195,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 98,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642591549087,
            "program": "  protected <K, V> NearCacheTestContext<K, V, Data, String> createContext() {\n    Config configWithNearCache = getConfig(true);\n    Config config = getConfig(false);\n\n    HazelcastInstance nearCacheMember = hazelcastFactory.newHazelcastInstance(configWithNearCache);\n    HazelcastInstance dataMember = hazelcastFactory.newHazelcastInstance(config);\n\n    IMap<K, V> nearCacheMap = nearCacheMember.getMap(DEFAULT_NEAR_CACHE_NAME);\n    IMap<K, V> dataMap = dataMember.getMap(DEFAULT_NEAR_CACHE_NAME);\n\n    NearCacheManager nearCacheManager = getMapNearCacheManager(nearCacheMember);\n    NearCache<Data, String> nearCache = nearCacheManager.getNearCache(DEFAULT_NEAR_CACHE_NAME);\n\n    return new NearCacheTestContextBuilder<K, V, Data, String>(\n            nearCacheConfig, getSerializationService(dataMember))\n        .setNearCacheInstance(nearCacheMember)\n        .setDataInstance(dataMember)\n        .setNearCacheAdapter(new IMapDataStructureAdapter<K, V>(nearCacheMap))\n        .setDataAdapter(new IMapDataStructureAdapter<K, V>(dataMap))\n        .setNearCache(nearCache)\n        .setNearCacheManager(nearCacheManager)\n        .setHasLocalData(true)\n        .build();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 188,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 130,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642591620166,
            "program": "  public void onFling(int velocityX, int velocityY) {\n    int velocity = orientationHelper.getFlingVelocity(velocityX, velocityY);\n    int throttleValue = shouldSlideOnFling ? Math.abs(velocity / flingThreshold) : 1;\n    int newPosition = currentPosition + Direction.fromDelta(velocity).applyTo(throttleValue);\n    newPosition = checkNewOnFlingPositionIsInBounds(newPosition);\n    boolean isInScrollDirection = velocity * scrolled >= 0;\n    boolean canFling = isInScrollDirection && isInBounds(newPosition);\n    if (canFling) {\n      startSmoothPendingScroll(newPosition);\n    } else {\n      returnToCurrentPosition();\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 101,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 97,
            "lineNumberOfError": 5,
            "attempt": 2,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642591689863,
            "program": "  public void onUpdate(final float pSecondsElapsed) {\r\n    this.mSecondsElapsedAccumulator += pSecondsElapsed;\r\n\r\n    final float stepLength = this.mStepLength;\r\n    while (this.mSecondsElapsedAccumulator >= stepLength) {\r\n      super.onUpdate(pSecondsElapsed);\r\n      this.mSecondsElapsedAccumulator -= stepLength;\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 47,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 131,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642591874413,
            "program": "  private static int replaceWhiteSpace(\n      final FormattingModel model,\n      @NotNull final LeafBlockWrapper block,\n      int shift,\n      final CharSequence _newWhiteSpace,\n      final CommonCodeStyleSettings.IndentOptions options) {\n    final WhiteSpace whiteSpace = block.getWhiteSpace();\n    final TextRange textRange = whiteSpace.getTextRange();\n    final TextRange wsRange = shiftRange(textRange, shift);\n    final String newWhiteSpace = _newWhiteSpace.toString();\n    TextRange newWhiteSpaceRange =\n        model instanceof FormattingModelEx\n            ? ((FormattingModelEx) model).replaceWhiteSpace(wsRange, block.getNode(), newWhiteSpace)\n            : model.replaceWhiteSpace(textRange, newWhiteSpace);\n\n    shift += newWhiteSpaceRange.getLength() - textRange.getLength();\n\n    if (block.isLeaf() && whiteSpace.containsLineFeeds() && block.containsLineFeeds()) {\n      final TextRange currentBlockRange = shiftRange(block.getTextRange(), shift);\n\n      IndentInside oldBlockIndent = whiteSpace.getInitialLastLineIndent();\n      IndentInside whiteSpaceIndent =\n          IndentInside.createIndentOn(IndentInside.getLastLine(newWhiteSpace));\n      final int shiftInside = calcShift(oldBlockIndent, whiteSpaceIndent, options);\n\n      if (shiftInside != 0 || !oldBlockIndent.equals(whiteSpaceIndent)) {\n        final TextRange newBlockRange =\n            model.shiftIndentInsideRange(currentBlockRange, shiftInside);\n        shift += newBlockRange.getLength() - block.getLength();\n      }\n    }\n    return shift;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review",
            "token": 241,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "2145060213-1642592970803": [
        {
            "ProgrammID": 149,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642593332193,
            "program": "  public void route(IQ packet) {\n    if (packet == null) {\n      throw new NullPointerException();\n    }\n    Session session = sessionManager.getSession(packet.getFrom());\n    if (session == null\n        || session.getStatus() == Session.STATUS_AUTHENTICATED\n        || (isLocalServer(packet.getTo())\n            && (\"jabber:iq:auth\".equals(packet.getChildElement().getNamespaceURI())\n                || \"jabber:iq:register\".equals(packet.getChildElement().getNamespaceURI())))) {\n      handle(packet);\n    } else {\n      IQ reply = IQ.createResultIQ(packet);\n      reply.setChildElement(packet.getChildElement().createCopy());\n      packet.setError(PacketError.Condition.not_authorized);\n      sessionManager.getSession(packet.getFrom()).process(reply);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review",
            "token": 158,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 105,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642593414454,
            "program": "  public static String getModuleDir(@NotNull String moduleFilePath) {\n    String moduleDir = PathUtilRt.getParentPath(moduleFilePath);\n    if (StringUtil.isEmpty(moduleDir)) {\n      return null;\n    }\n\n    // hack so that, if a module is stored inside the .idea directory, the base directory\n    // rather than the .idea directory itself is considered the module root\n    // (so that a Ruby IDE project doesn't break if its directory is moved together with the .idea\n    // directory)\n    String moduleDirParent = PathUtilRt.getParentPath(moduleDir);\n    if (!StringUtil.isEmpty(moduleDirParent)\n        && PathUtilRt.getFileName(moduleDir).equals(DIRECTORY_STORE_NAME)) {\n      moduleDir = moduleDirParent;\n    }\n    moduleDir = toSystemIndependentName(moduleDir);\n    if (moduleDir.endsWith(\":/\")) {\n      moduleDir = moduleDir.substring(0, moduleDir.length() - 1);\n    }\n    return moduleDir;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review",
            "token": 112,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 109,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642593451922,
            "program": "  protected void addFullText(String wicketId, String text, boolean substituteRegex) {\r\n    String html = StringUtils.escapeForHtml(text, false);\r\n    if (substituteRegex) {\r\n      html = GitBlit.self().processCommitMessage(repositoryName, html);\r\n    } else {\r\n      html = StringUtils.breakLinesForHtml(html);\r\n    }\r\n    add(new Label(wicketId, html).setEscapeModelStrings(false));\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review",
            "token": 76,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 126,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642593497549,
            "program": "  public void insertEmoji(String emoji) {\n    final int start = getSelectionStart();\n    final int end = getSelectionEnd();\n\n    getText().replace(Math.min(start, end), Math.max(start, end), emoji);\n    setSelection(end + emoji.length());\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review",
            "token": 63,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 122,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642593607520,
            "program": "  public static String getShortestClassName(PsiClass aClass, PsiElement context) {\n    String shortName = aClass.getName();\n    PsiClass containingClass = aClass.getContainingClass();\n    while (containingClass != null) {\n      shortName = containingClass.getName() + \".\" + shortName;\n      containingClass = aClass.getContainingClass();\n    }\n    LOG.assertTrue(shortName != null);\n\n    String qName = aClass.getQualifiedName();\n    if (qName == null) return shortName;\n\n    final PsiManager manager = aClass.getManager();\n    return manager.areElementsEquivalent(\n            aClass, manager.getResolveHelper().resolveReferencedClass(shortName, context))\n        ? shortName\n        : qName;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review",
            "token": 121,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 100,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642593667881,
            "program": "  private SlimAssertion callFunctionInRow(String functionName, int row) {\n    int col = funcStore.getColumnNumber(functionName);\n    String name = Disgracer.disgraceMethodName(functionName);\n    String assignedSymbol = ifSymbolAssignment(col, row);\n    SlimAssertion assertion;\n    if (assignedSymbol != null) {\n      assertion =\n          makeAssertion(\n              callAndAssign(assignedSymbol, \"scriptTable\" + \"Actor\", \"cloneSymbol\", \"$\" + name),\n              new ReturnedSymbolExpectation(col, row, name, assignedSymbol));\n    } else {\n      assertion =\n          makeAssertion(\n              Instruction.NOOP_INSTRUCTION, new ReturnedSymbolExpectation(col, row, name));\n    }\n    return assertion;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review",
            "token": 110,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 83,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 16,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642593732513,
            "program": "  public void testInterceptedMethodThrows() throws Exception {\n    Injector injector =\n        Guice.createInjector(\n            new AbstractModule() {\n              protected void configure() {\n                bindInterceptor(Matchers.any(), Matchers.any(), new CountingInterceptor());\n                bindInterceptor(Matchers.any(), Matchers.any(), new CountingInterceptor());\n              }\n            });\n\n    Interceptable interceptable = injector.getInstance(Interceptable.class);\n    try {\n      interceptable.explode();\n      fail();\n    } catch (Exception e) {\n      // validate all causes.\n      for (Throwable t = e; t != null; t = e.getCause()) {\n        StackTraceElement[] stackTraceElement = t.getStackTrace();\n        assertEquals(\"explode\", stackTraceElement[0].getMethodName());\n        assertEquals(\"invoke\", stackTraceElement[1].getMethodName());\n        assertEquals(\"invoke\", stackTraceElement[2].getMethodName());\n        assertEquals(\"testInterceptedMethodThrows\", stackTraceElement[3].getMethodName());\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review",
            "token": 191,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 146,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642593803999,
            "program": "  private void resolveGenericsHeader(GenericsType[] types) {\n    if (types == null) return;\n    currentClass.setUsingGenerics(true);\n    for (GenericsType type : types) {\n      ClassNode classNode = type.getType();\n      String name = type.getName();\n      ClassNode[] bounds = type.getUpperBounds();\n      if (bounds != null) {\n        boolean nameAdded = false;\n        for (ClassNode upperBound : bounds) {\n          if (!nameAdded && upperBound != null || !resolve(classNode)) {\n            genericParameterNames.put(name, type);\n            type.setPlaceholder(true);\n            classNode.setRedirect(upperBound);\n            nameAdded = true;\n          }\n          resolveOrFail(upperBound, classNode);\n        }\n      } else {\n        genericParameterNames.put(name, type);\n        classNode.setRedirect(ClassHelper.OBJECT_TYPE);\n        type.setPlaceholder(true);\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review",
            "token": 165,
            "ctx": "oss",
            "codebase": "others",
            "team": "alone"
        }
    ],
    "1201760841-1642593824477": [
        {
            "ProgrammID": 140,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642595913271,
            "program": "  public boolean sendExtraCommand(String provider, String command, Bundle extras) {\n    // first check for permission to the provider\n    checkPermissionsSafe(provider);\n    // and check for ACCESS_LOCATION_EXTRA_COMMANDS\n    if ((mContext.checkCallingOrSelfPermission(ACCESS_LOCATION_EXTRA_COMMANDS)\n        != PackageManager.PERMISSION_GRANTED)) {\n      throw new SecurityException(\"Requires ACCESS_LOCATION_EXTRA_COMMANDS permission\");\n    }\n\n    synchronized (mLock) {\n      LocationProviderProxy proxy = mProvidersByName.get(provider);\n      if (proxy == null) {\n        return false;\n      }\n\n      return proxy.sendExtraCommand(command, extras);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,test,develop",
            "token": 81,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 147,
            "lineNumberOfError": 0,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642596220882,
            "program": "  public static RowStarChange load(LineNumberReader reader, Pool pool) throws Exception {\n    int row = -1;\n    boolean oldStarred = false;\n    boolean newStarred = false;\n\n    String line;\n    while ((line = reader.readLine()) != null && !\"/ec/\".equals(line)) {\n      int equal = line.indexOf('=');\n      CharSequence field = line.subSequence(0, equal);\n      String value = line.substring(equal + 1);\n\n      if (\"row\".equals(field)) {\n        row = Integer.parseInt(value);\n      } else if (\"oldStarred\".equals(field)) {\n        oldStarred = Boolean.parseBoolean(value);\n      } else if (\"newStarred\".equals(field)) {\n        newStarred = Boolean.parseBoolean(value);\n      }\n    }\n\n    RowStarChange change = new RowStarChange(row, newStarred);\n    change.oldStarred = oldStarred;\n\n    return change;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,test,develop",
            "token": 174,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 103,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642596454754,
            "program": "  protected void validateImport(\n      Map<String, List<StagedModel>> dependentStagedModelsMap, Group group) throws Exception {\n\n    List<StagedModel> questions = dependentStagedModelsMap.get(PollsQuestion.class.getName());\n\n    Assert.assertEquals(1, questions.size());\n\n    PollsQuestion question = (PollsQuestion) questions.get(0);\n\n    PollsQuestionLocalServiceUtil.getPollsQuestionByUuidAndGroupId(\n        question.getUuid(), group.getGroupId());\n\n    List<StagedModel> choices = dependentStagedModelsMap.get(PollsChoice.class.getName());\n\n    Assert.assertEquals(1, questions.size());\n\n    PollsChoice choice = (PollsChoice) choices.get(0);\n\n    PollsChoiceLocalServiceUtil.getPollsChoiceByUuidAndGroupId(\n        choice.getUuid(), group.getGroupId());\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,test,develop",
            "token": 146,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 112,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642596725195,
            "program": "  private List<AnnotationData> doCollect(\n      @NotNull PsiModifierListOwner listOwner, boolean onlyWritable) {\n    final List<PsiFile> files = findExternalAnnotationsFiles(listOwner);\n    if (files == null) {\n      return NO_DATA;\n    }\n    SmartList<AnnotationData> result = new SmartList<AnnotationData>();\n    String externalName = getExternalName(listOwner, false);\n    if (externalName == null) return NO_DATA;\n    String oldExternalName = getNormalizedExternalName(listOwner);\n\n    for (PsiFile file : files) {\n      if (!file.isValid()) continue;\n      if (onlyWritable && !file.isWritable()) continue;\n\n      MostlySingularMultiMap<String, AnnotationData> fileData = getDataFromFile(file);\n\n      addAnnotations(result, externalName, file, fileData);\n      if (oldExternalName != null && !externalName.equals(oldExternalName)) {\n        addAnnotations(result, oldExternalName, file, fileData);\n      }\n    }\n    if (result.isEmpty()) {\n      return NO_DATA;\n    }\n    result.trimToSize();\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,test,develop",
            "token": 187,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 155,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642596763342,
            "program": "  public float parseFloatValue(String value) {\n    if (type == FLOAT_TYPE) {\n      try {\n        int colon = value.indexOf(':');\n        if (colon != -1) {\n          float c = 0;\n          if (c > 0) {\n            c += Float.parseFloat(value.substring(0, colon));\n          }\n          c += Float.parseFloat(value.substring(colon + 1));\n          return c;\n        }\n        return Float.parseFloat(value);\n      } catch (NumberFormatException e) {\n        log.error(\"Rendering parse \" + value);\n      }\n      return -1;\n    } else {\n      return -1;\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,test,develop",
            "token": 122,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 152,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 21,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642596861108,
            "program": "  public void testParseAndMarshalModelWithJASPI() throws Exception {\n    // Parse the subsystem xml and install into the first controller\n    String subsystemXml = readResource(\"securitysubsystemJASPIv1.xml\");\n\n    KernelServices servicesA =\n        super.installInController(AdditionalInitialization.MANAGEMENT, subsystemXml);\n    // Get the model and the persisted xml from the first controller\n    ModelNode modelA = servicesA.readWholeModel();\n    String marshalled = servicesA.getPersistedSubsystemXml();\n    servicesA.shutdown();\n\n    System.out.println(marshalled);\n\n    // Install the persisted xml from the first controller into a second controller\n    KernelServices servicesB =\n        super.installInController(AdditionalInitialization.MANAGEMENT, marshalled);\n    ModelNode modelB = servicesB.readWholeModel();\n\n    // Make sure the models from the two controllers are identical\n    super.compare(modelA, modelB);\n\n    assertRemoveSubsystemResources(servicesA);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,test,develop",
            "token": 101,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 87,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642596953712,
            "program": "  public JsPromise findUsers(final String query) {\n    return JsPromise.create(\n        new JsPromiseExecutor() {\n          @Override\n          public void execute() {\n            messenger\n                .findUsers(query)\n                .start(\n                    new CommandCallback<UserVM[]>() {\n                      @Override\n                      public void onResult(UserVM[] users) {\n                        JsArray<JsUser> jsUsers = JsArray.createArray().cast();\n\n                        for (UserVM user : users) {\n                          jsUsers.push(messenger.getJsUser(user.getId()).get());\n                        }\n\n                        resolve(jsUsers);\n                      }\n\n                      @Override\n                      public void onError(Exception e) {\n                        reject(e.getMessage());\n                      }\n                    });\n          }\n        });\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,test,develop",
            "token": 137,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 133,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642596978296,
            "program": "  public boolean getBooleanValue(String name, boolean defaultValue) {\n    String result = properties.get(name);\n    if (result == null) {\n      return defaultValue;\n    }\n    return Utils.parseBoolean(name, defaultValue, true);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,test,develop",
            "token": 45,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1855738920-1642615337478": [
        {
            "ProgrammID": 108,
            "lineNumberOfError": 21,
            "attempt": 1,
            "expectedAnswer": 24,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642616205823,
            "program": "  protected void configureTaskUploadArchives(\n      Project project, ReplaceRegexTask updateFileVersionsTask) {\n\n    String version = String.valueOf(project.getVersion());\n\n    if (version.endsWith(_SNAPSHOT_VERSION_SUFFIX)) {\n      return;\n    }\n\n    Task uploadArchivesTask = GradleUtil.getTask(project, BasePlugin.UPLOAD_ARCHIVES_TASK_NAME);\n\n    TaskContainer taskContainer = project.getTasks();\n\n    TaskCollection<PublishNodeModuleTask> publishNodeModuleTasks =\n        taskContainer.withType(PublishNodeModuleTask.class);\n\n    uploadArchivesTask.dependsOn(publishNodeModuleTasks);\n\n    Task updateBundleVersionTask = taskContainer.findByName(UPDATE_BUNDLE_VERSION_TASK_NAME);\n\n    if (updateBundleVersionTask != null) {\n      uploadArchivesTask.finalizedBy(updateBundleVersionTask);\n    }\n\n    uploadArchivesTask.finalizedBy(updateBundleVersionTask);\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 116,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 120,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642616326266,
            "program": "  public boolean putToDisk(String key, V value) {\n    if (mHasDiskCache) {\n      // Wait for pause\n      waitUntilUnpaused();\n\n      String diskKey = hashKeyForDisk(key);\n\n      synchronized (mDiskCacheLock) {\n        while (mDiskCacheStarting) {\n          try {\n            mDiskCacheLock.wait();\n          } catch (InterruptedException e) {\n            // Just ignore\n          }\n        }\n        if (mDiskCache != null) {\n          mDiskCache.put(diskKey, value);\n          return true;\n        } else {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 90,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 89,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642616385654,
            "program": "  protected long executeI64(VirtualFrame frame, long value) {\n    long result = value + 1;\n    boolean of = result == Long.MAX_VALUE;\n    flags.execute(frame, of, result);\n    return result;\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 42,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 150,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642616446905,
            "program": "  public DataFlowInfo equate(@NotNull DataFlowValue a, @NotNull DataFlowValue b) {\n    Map<DataFlowValue, Nullability> builder = Maps.newHashMap(nullabilityInfo);\n    Nullability nullabilityOfA = getNullability(a);\n    Nullability nullabilityOfB = getNullability(b);\n\n    boolean changed = false;\n    changed |= putNullability(builder, a, nullabilityOfA.refine(nullabilityOfB));\n    changed |= putNullability(builder, b, nullabilityOfA.refine(nullabilityOfA));\n    return changed ? new DataFlowInfo(ImmutableMap.copyOf(builder), typeInfo) : this;\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 102,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 138,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642616593540,
            "program": "  @Override\n  protected Frame predictScoreImpl(Frame orig, Frame adaptedFr, String destination_key) {\n    final int ncols = _output._names.length;\n    assert ncols == adaptedFr.numCols();\n    String prefix = \"reconstr_\";\n\n    // Need [A,X,P] where A = adaptedFr, X = loading frame, P = imputed frame\n    // Note: A is adapted to original training frame, P has columns shuffled so cats come before\n    // nums!\n    Frame fullFrm = new Frame(adaptedFr);\n    Frame loadingFrm = DKV.get(_output._loading_key).get();\n    fullFrm.add(loadingFrm);\n    String[][] adaptedDomme = adaptedFr.domains();\n    for (int i = 0; i < ncols; i++) {\n      Vec v = fullFrm.anyVec().makeZero();\n      v.setDomain(adaptedDomme[i]);\n      fullFrm.add(prefix + _output._names[i], v);\n    }\n    GLRMScore gs = new GLRMScore(ncols, _parms._k, true).doAll(fullFrm);\n\n    // Return the imputed training frame\n    int x = ncols + _parms._k, y = fullFrm.numCols();\n    Frame f =\n        fullFrm.extractFrame(\n            x, y); // this will call vec_impl() and we cannot call the delete() below just yet\n\n    f =\n        new Frame(\n            (null == destination_key ? Key.make() : Key.make(destination_key)),\n            f.names(),\n            f.vecs());\n    DKV.put(f);\n    gs._mb.makeModelMetrics(GLRMModel.this, orig); // save error metrics based on imputed data\n    return f;\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 250,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 127,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642616802977,
            "program": "  public void setAttribute(final String name, final Object value) {\n    try {\n      Object old = session.setAttribute(name, value).get();\n      if (value == null && old != null) {\n        applicationListeners.httpSessionAttributeRemoved(this, name, old);\n      } else if (old == null) {\n        applicationListeners.httpSessionAttributeAdded(this, name, value);\n      } else {\n        applicationListeners.httpSessionAttributeReplaced(this, name, old);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 104,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 106,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642616934468,
            "program": "  public static Path copyChecksums(SyncFile sourceSyncFile, SyncFile targetSyncFile) {\n\n    try {\n      Path sourceChecksumsFilePath = getChecksumsFilePath(sourceSyncFile);\n\n      if (Files.notExists(sourceChecksumsFilePath)) {\n        checksums(sourceSyncFile);\n      }\n\n      Path targetChecksumsFilePath = getChecksumsFilePath(targetSyncFile);\n\n      Files.copy(\n          sourceChecksumsFilePath, targetChecksumsFilePath, StandardCopyOption.REPLACE_EXISTING);\n\n      return targetChecksumsFilePath;\n    } catch (IOException ioe) {\n      _logger.error(ioe.getMessage(), ioe);\n\n      return null;\n    }\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 87,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 156,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642616976292,
            "program": "  public static Object getOrDefault(String key, Object defaultValue) {\n    Object re = me().map.get(key);\n    if (re == null) return defaultValue;\n    return key;\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 39,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "197312815-1642617539878": [
        {
            "ProgrammID": 121,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642617870560,
            "program": "  public static <T> T getFirstImplementation(final T t) {\n    T cur = t;\n    while (cur instanceof MergedObject) {\n      final List<T> implementations = ((MergedObject<T>) cur).getImplementations();\n      cur = implementations.isEmpty() ? null : implementations.get(0);\n    }\n    return cur;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 68,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 158,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642618098177,
            "program": "  private static List<TypeConstraint> addExpectedConstructorParameters(\n      GrExpression expression, GrListOrMap list) {\n    final PsiType listType = list.getType();\n    if (!(listType instanceof GrTupleType)) {\n      return Collections.emptyList();\n    }\n\n    final PsiType[] argTypes = ((GrTupleType) listType).getComponentTypes();\n    final int argIndex = Arrays.asList(list.getInitializers()).indexOf(expression);\n    assert argIndex >= 0;\n\n    final ArrayList<TypeConstraint> result = new ArrayList<TypeConstraint>();\n    for (PsiType type : GroovyExpectedTypesProvider.getDefaultExpectedTypes(list)) {\n      if (type instanceof PsiClassType) {\n        for (GroovyResolveResult resolveResult :\n            PsiUtil.getConstructorCandidates((PsiClassType) type, argTypes, list)) {\n          final PsiElement method = resolveResult.getElement();\n          if (method instanceof PsiMethod && ((PsiMethod) method).isConstructor()) {\n            final PsiParameter[] constructorParameters =\n                ((PsiMethod) method).getParameterList().getParameters();\n            if (constructorParameters.length > argIndex) {\n              final PsiType toCastTo =\n                  resolveResult\n                      .getSubstitutor()\n                      .substitute(constructorParameters[argIndex].getType());\n              result.add(SubtypeConstraint.create(toCastTo));\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 241,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 101,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642618204366,
            "program": "  public void setDarkIntensity(float darkIntensity) {\n    int backgroundColor = getBackgroundColor(darkIntensity);\n    int fillColor = getFillColor(darkIntensity);\n    mIconTint = fillColor;\n    mFramePaint.setColor(backgroundColor);\n    mBoltPaint.setColor(fillColor);\n    mChargeColor = fillColor;\n    invalidate();\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 51,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 114,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642618285220,
            "program": "  private static File createTempFile(Context context, @Nullable String mimeType)\n      throws IOException {\n    File externalCacheDir = context.getExternalCacheDir();\n    File internalCacheDir = context.getCacheDir();\n    File cacheDir;\n    if (externalCacheDir == null && internalCacheDir == null) {\n      throw new IOException(\"No cache directory available\");\n    }\n    if (externalCacheDir == null) {\n      cacheDir = internalCacheDir;\n    } else if (internalCacheDir == null) {\n      cacheDir = externalCacheDir;\n    } else {\n      cacheDir =\n          externalCacheDir.getFreeSpace() > internalCacheDir.getFreeSpace()\n              ? externalCacheDir\n              : internalCacheDir;\n    }\n    return File.createTempFile(TEMP_FILE_PREFIX, getFileExtensionForType(mimeType), cacheDir);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 118,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 107,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642618365586,
            "program": "  protected void initFormNavigatorEntry(\n      String servletContextName,\n      Properties portalProperties,\n      String portalPropertiesKey,\n      String categoryKey,\n      String formNavigatorId,\n      String jspPath) {\n\n    String[] formNavigatorSections =\n        StringUtil.split(portalProperties.getProperty(portalPropertiesKey));\n\n    for (int i = 0; i < formNavigatorSections.length; i++) {\n      String formNavigatorSection = formNavigatorSections[i];\n\n      FormNavigatorEntry<Object> deprecatedFormNavigatorEntry =\n          new DeprecatedFormNavigatorEntry(\n              formNavigatorSection,\n              formNavigatorSection,\n              categoryKey,\n              formNavigatorId,\n              \"/html/portlet/\" + jspPath + \"/\" + formNavigatorSection + \".jsp\");\n\n      registerService(\n          servletContextName,\n          formNavigatorId + categoryKey + formNavigatorSection,\n          FormNavigatorEntry.class,\n          deprecatedFormNavigatorEntry,\n          \"service.ranking\",\n          -i);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 117,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 84,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642618479768,
            "program": "  public void addPossibleResultPoint(ResultPoint point) {\n    List<ResultPoint> points = possibleResultPoints;\n    synchronized (points) {\n      points.add(point);\n      int size = points.size();\n      if (size > MAX_RESULT_POINTS) {\n        // trim it\n        points.subList(0, size - MAX_RESULT_POINTS / 2).clear();\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 64,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 135,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642618537164,
            "program": "  protected void addImplicitRules(Interpreter interpreter) {\n    // The following line adds the capability to parse nested components\n    NestedComplexPropertyIA nestedIA = new NestedComplexPropertyIA();\n    nestedIA.setContext(context);\n    interpreter.addImplicitAction(nestedIA);\n\n    NestedBasicPropertyIA nestedSimpleIA = new NestedBasicPropertyIA();\n    nestedSimpleIA.setContext(context);\n    interpreter.addImplicitAction(nestedSimpleIA);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 53,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 80,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642618679346,
            "program": "  public static void remove(CuratorFramework curator, String path, String value) throws Exception {\n    if (curator.checkExists().forPath(path) != null) {\n      List<String> parts = new LinkedList<String>();\n      String data = getStringData(curator, path);\n      if (data != null) {\n        parts = new ArrayList<String>(Arrays.asList(data.trim().split(\" +\")));\n      }\n      boolean changed = false;\n      StringBuilder sb = new StringBuilder();\n      for (Iterator<String> it = parts.iterator(); it.hasNext(); ) {\n        String v = it.next();\n        if (v.matches(value)) {\n          it.remove();\n          changed = true;\n        }\n      }\n      if (changed) {\n        sb.delete(0, sb.length());\n        for (String part : parts) {\n          if (sb.length() > 0) {\n            sb.append(\" \");\n          }\n          sb.append(part);\n        }\n        setData(curator, path, sb.toString());\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop",
            "token": 225,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "647661366-1642620316454": [
        {
            "ProgrammID": 132,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642620904355,
            "program": "  public void addAllUpdates(LeftTupleSets tupleSets) {\n    LeftTupleSetsImpl tupleSetsImpl = (LeftTupleSetsImpl) tupleSets;\n    if (tupleSetsImpl.getUpdateFirst() != null) {\n      if (updateFirst == null) {\n        updateFirst = tupleSetsImpl.getUpdateFirst();\n        updateSize = tupleSetsImpl.updateSize;\n      } else {\n        LeftTuple current = updateFirst;\n        LeftTuple last = null;\n        while (current != null) {\n          last = current;\n          current = current.getStagedNext();\n        }\n        LeftTuple leftTuple = tupleSetsImpl.getUpdateFirst();\n        last.setStagedNext(leftTuple);\n        leftTuple.setStagePrevious(leftTuple);\n        updateSize = updateSize + tupleSetsImpl.updateSize();\n      }\n      tupleSetsImpl.updateFirst = null;\n      tupleSetsImpl.updateSize = 0;\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test,review",
            "token": 129,
            "ctx": "oss",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 151,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642621032455,
            "program": "  public static void main(String[] args) throws IOException {\n    Collection<? extends PropertyKey> defaultKeys = PropertyKey.defaultKeys();\n    String homeDir = Configuration.get(PropertyKey.HOME);\n    // generate CSV files\n    String filePath = PathUtils.concatPath(homeDir, CSV_FILE_DIR);\n    writeCSVFile(defaultKeys, filePath);\n    // generate YML files\n    filePath = PathUtils.concatPath(homeDir, YML_FILE_DIR);\n    writeYMLFile(defaultKeys, filePath);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test,review",
            "token": 77,
            "ctx": "oss",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 157,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642621180010,
            "program": "  public ReactiveAdapter getAdapter(Class<?> reactiveType, Object source) {\n    Object sourceToUse =\n        (source instanceof Optional ? ((Optional<?>) source).orElse(null) : source);\n    Class<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);\n\n    if (reactiveType == null) {\n      return null;\n    }\n\n    return this.adapters.stream()\n        .filter(adapter -> adapter.getReactiveType() == clazz)\n        .findFirst()\n        .orElseGet(\n            () ->\n                this.adapters.stream()\n                    .filter(adapter -> adapter.getReactiveType().isAssignableFrom(clazz))\n                    .findFirst()\n                    .orElse(null));\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test,review",
            "token": 137,
            "ctx": "oss",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 125,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642621352325,
            "program": "  public WrapperView getView(int position, View convertView, ViewGroup parent) {\n    WrapperView wv = (convertView == null) ? new WrapperView(mContext) : (WrapperView) convertView;\n    View item = mDelegate.getView(position, wv.mItem, wv);\n    View header = null;\n    if (previousPositionHasSameHeader(position)) {\n      recycleHeaderIfExists(wv);\n    } else {\n      header = configureHeader(wv, position);\n    }\n    if ((item instanceof Checkable) && !(wv instanceof CheckableWrapperView)) {\n      // Need to create Checkable subclass of WrapperView for ListView to work correctly\n      wv = new CheckableWrapperView(mContext);\n    } else if (!(item instanceof Checkable) && (wv instanceof CheckableWrapperView)) {\n      wv = new WrapperView(mContext);\n    }\n    wv.update(item, header, mDivider, mDividerHeight);\n    return wv;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test,review",
            "token": 149,
            "ctx": "oss",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 93,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642621426882,
            "program": "  private HiveStats getStatsFromProps(final Properties properties) {\n    long numRows = -1;\n    long sizeInBytes = -1;\n    try {\n      final String numRowsProp = properties.getProperty(StatsSetupConst.ROW_COUNT);\n      if (numRowsProp != null) {\n        numRows = Long.valueOf(numRowsProp);\n      }\n\n      final String sizeInBytesProp = properties.getProperty(StatsSetupConst.TOTAL_SIZE);\n      if (sizeInBytesProp != null) {\n        sizeInBytes = Long.valueOf(sizeInBytesProp);\n      }\n    } catch (final NumberFormatException e) {\n      logger.error(\"Failed to parse Hive stats in metastore.\", e);\n      // continue with the defaults.\n    }\n\n    return new HiveStats(numRows, sizeInBytes);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test,review",
            "token": 111,
            "ctx": "oss",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 104,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642621626028,
            "program": "  public List<ExecutionResult> succeeds(MSBuildAction action) {\n    withArgument(toTargetArgument(action));\n    ExecOutput result = findMSBuild().execute(args, buildEnvironment(workingDir));\n    System.out.println(result.getOut());\n    String output = trimLines(result.getOut());\n    String error = trimLines(result.getError());\n    List<ExecutionResult> results = new ArrayList<ExecutionResult>();\n    int first = output.indexOf(SEPARATOR);\n    if (first < 0) {\n      return Collections.emptyList();\n    }\n    output = output.substring(first + SEPARATOR.length());\n    while (output.length() > 0) {\n      int next = output.indexOf(SEPARATOR);\n      if (next < 0) {\n        results.add(OutputScrapingExecutionResult.from(output, error));\n        output = \"\";\n      } else {\n        results.add(OutputScrapingExecutionResult.from(output.substring(0, next), error));\n        output = output.substring(next + SEPARATOR.length());\n      }\n      error = \"\";\n    }\n    return results;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test,review",
            "token": 222,
            "ctx": "oss",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 88,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642621668297,
            "program": "  public boolean addAll(int index, Collection<? extends Object> c) {\r\n    if (CollUtil.isEmpty(c)) {\r\n      return false;\r\n    }\r\n    final ArrayList<Object> list = new ArrayList<>(c.size());\r\n    for (Object object : list) {\r\n      list.add(JSONUtil.wrap(object, ignoreNullValue));\r\n    }\r\n    return rawList.addAll(index, list);\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test,review",
            "token": 83,
            "ctx": "oss",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 102,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642621766137,
            "program": "  public void visit(final ParserRuleContext ancestorNode, final SQLStatement statement) {\n    AlterTableStatement alterStatement = (AlterTableStatement) statement;\n\n    List<ParserRuleContext> modifyColumnCtxs =\n        TreeUtils.getAllDescendantByRuleName(ancestorNode, RuleNameConstants.MODIFY_COLUMN);\n    if (null == modifyColumnCtxs) {\n      return;\n    }\n\n    for (ParserRuleContext each : modifyColumnCtxs) {\n      // it`s not columndefinition, but can call this method\n      ColumnDefinition column = VisitorUtils.visitColumnDefinition(each);\n      if (null != column) {\n        alterStatement.getUpdateColumns().put(column.getName(), column);\n        postVisitColumnDefinition(ancestorNode, statement, column.getName());\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test,review",
            "token": 106,
            "ctx": "oss",
            "codebase": "others",
            "team": "large"
        }
    ],
    "1365971520-1642628465215": [
        {
            "ProgrammID": 85,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642629740919,
            "program": "  protected void parseCommonParams(Object o) {\n    if (o instanceof Map) {\n      Map<String, Object> m = (Map<String, Object>) o;\n      List<String> excludeTags = getStringList(m, \"excludeTags\");\n      if (excludeTags != null) {\n        getDomain().excludeTags = excludeTags;\n      }\n\n      Map<String, Object> domainMap = (Map<String, Object>) m.get(\"domain\");\n      if (domainMap != null) {\n        excludeTags = getStringList(domainMap, \"excludeTags\");\n        if (excludeTags != null) {\n          getDomain().excludeTags = excludeTags;\n        }\n\n        String blockParent = (String) domainMap.get(\"blockParent\");\n        String blockChildren = (String) domainMap.get(\"blockChildren\");\n\n        if (blockParent != null) {\n          getDomain().toParent = true;\n          getDomain().parents = blockParent;\n        } else if (blockChildren != null) {\n          getDomain().toChildren = true;\n          getDomain().parents = blockChildren;\n        }\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 195,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 126,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642629815529,
            "program": "  public void insertEmoji(String emoji) {\n    final int start = getSelectionStart();\n    final int end = getSelectionEnd();\n\n    getText().replace(Math.min(start, end), Math.max(start, end), emoji);\n    setSelection(end + emoji.length());\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 63,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 99,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642629995410,
            "program": "  public static <F> boolean setOnce(\n      AtomicReferenceFieldUpdater<F, Subscription> field, F instance, Subscription s) {\n    Subscription a = field.get(instance);\n    if (a == CancelledSubscription.INSTANCE) {\n      s.cancel();\n      return false;\n    }\n    if (a != null) {\n      s.cancel();\n      reportSubscriptionSet();\n      return false;\n    }\n\n    if (field.compareAndSet(instance, null, s)) {\n      return true;\n    }\n\n    a = field.get(instance);\n\n    if (a == CancelledSubscription.INSTANCE) {\n      s.cancel();\n      return false;\n    }\n\n    s.cancel();\n    reportSubscriptionSet();\n    return false;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 133,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 108,
            "lineNumberOfError": 21,
            "attempt": 1,
            "expectedAnswer": 24,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642630176830,
            "program": "  protected void configureTaskUploadArchives(\n      Project project, ReplaceRegexTask updateFileVersionsTask) {\n\n    String version = String.valueOf(project.getVersion());\n\n    if (version.endsWith(_SNAPSHOT_VERSION_SUFFIX)) {\n      return;\n    }\n\n    Task uploadArchivesTask = GradleUtil.getTask(project, BasePlugin.UPLOAD_ARCHIVES_TASK_NAME);\n\n    TaskContainer taskContainer = project.getTasks();\n\n    TaskCollection<PublishNodeModuleTask> publishNodeModuleTasks =\n        taskContainer.withType(PublishNodeModuleTask.class);\n\n    uploadArchivesTask.dependsOn(publishNodeModuleTasks);\n\n    Task updateBundleVersionTask = taskContainer.findByName(UPDATE_BUNDLE_VERSION_TASK_NAME);\n\n    if (updateBundleVersionTask != null) {\n      uploadArchivesTask.finalizedBy(updateBundleVersionTask);\n    }\n\n    uploadArchivesTask.finalizedBy(updateBundleVersionTask);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 116,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 138,
            "lineNumberOfError": 21,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642630483305,
            "program": "  @Override\n  protected Frame predictScoreImpl(Frame orig, Frame adaptedFr, String destination_key) {\n    final int ncols = _output._names.length;\n    assert ncols == adaptedFr.numCols();\n    String prefix = \"reconstr_\";\n\n    // Need [A,X,P] where A = adaptedFr, X = loading frame, P = imputed frame\n    // Note: A is adapted to original training frame, P has columns shuffled so cats come before\n    // nums!\n    Frame fullFrm = new Frame(adaptedFr);\n    Frame loadingFrm = DKV.get(_output._loading_key).get();\n    fullFrm.add(loadingFrm);\n    String[][] adaptedDomme = adaptedFr.domains();\n    for (int i = 0; i < ncols; i++) {\n      Vec v = fullFrm.anyVec().makeZero();\n      v.setDomain(adaptedDomme[i]);\n      fullFrm.add(prefix + _output._names[i], v);\n    }\n    GLRMScore gs = new GLRMScore(ncols, _parms._k, true).doAll(fullFrm);\n\n    // Return the imputed training frame\n    int x = ncols + _parms._k, y = fullFrm.numCols();\n    Frame f =\n        fullFrm.extractFrame(\n            x, y); // this will call vec_impl() and we cannot call the delete() below just yet\n\n    f =\n        new Frame(\n            (null == destination_key ? Key.make() : Key.make(destination_key)),\n            f.names(),\n            f.vecs());\n    DKV.put(f);\n    gs._mb.makeModelMetrics(GLRMModel.this, orig); // save error metrics based on imputed data\n    return f;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 250,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 158,
            "lineNumberOfError": 24,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642630906257,
            "program": "  private static List<TypeConstraint> addExpectedConstructorParameters(\n      GrExpression expression, GrListOrMap list) {\n    final PsiType listType = list.getType();\n    if (!(listType instanceof GrTupleType)) {\n      return Collections.emptyList();\n    }\n\n    final PsiType[] argTypes = ((GrTupleType) listType).getComponentTypes();\n    final int argIndex = Arrays.asList(list.getInitializers()).indexOf(expression);\n    assert argIndex >= 0;\n\n    final ArrayList<TypeConstraint> result = new ArrayList<TypeConstraint>();\n    for (PsiType type : GroovyExpectedTypesProvider.getDefaultExpectedTypes(list)) {\n      if (type instanceof PsiClassType) {\n        for (GroovyResolveResult resolveResult :\n            PsiUtil.getConstructorCandidates((PsiClassType) type, argTypes, list)) {\n          final PsiElement method = resolveResult.getElement();\n          if (method instanceof PsiMethod && ((PsiMethod) method).isConstructor()) {\n            final PsiParameter[] constructorParameters =\n                ((PsiMethod) method).getParameterList().getParameters();\n            if (constructorParameters.length > argIndex) {\n              final PsiType toCastTo =\n                  resolveResult\n                      .getSubstitutor()\n                      .substitute(constructorParameters[argIndex].getType());\n              result.add(SubtypeConstraint.create(toCastTo));\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 241,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 121,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642631024620,
            "program": "  public static <T> T getFirstImplementation(final T t) {\n    T cur = t;\n    while (cur instanceof MergedObject) {\n      final List<T> implementations = ((MergedObject<T>) cur).getImplementations();\n      cur = implementations.isEmpty() ? null : implementations.get(0);\n    }\n    return cur;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 68,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 147,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642631335747,
            "program": "  public static RowStarChange load(LineNumberReader reader, Pool pool) throws Exception {\n    int row = -1;\n    boolean oldStarred = false;\n    boolean newStarred = false;\n\n    String line;\n    while ((line = reader.readLine()) != null && !\"/ec/\".equals(line)) {\n      int equal = line.indexOf('=');\n      CharSequence field = line.subSequence(0, equal);\n      String value = line.substring(equal + 1);\n\n      if (\"row\".equals(field)) {\n        row = Integer.parseInt(value);\n      } else if (\"oldStarred\".equals(field)) {\n        oldStarred = Boolean.parseBoolean(value);\n      } else if (\"newStarred\".equals(field)) {\n        newStarred = Boolean.parseBoolean(value);\n      }\n    }\n\n    RowStarChange change = new RowStarChange(row, newStarred);\n    change.oldStarred = oldStarred;\n\n    return change;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 174,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "137568583-1642631630334": [
        {
            "ProgrammID": 109,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642632129295,
            "program": "  protected void addFullText(String wicketId, String text, boolean substituteRegex) {\r\n    String html = StringUtils.escapeForHtml(text, false);\r\n    if (substituteRegex) {\r\n      html = GitBlit.self().processCommitMessage(repositoryName, html);\r\n    } else {\r\n      html = StringUtils.breakLinesForHtml(html);\r\n    }\r\n    add(new Label(wicketId, html).setEscapeModelStrings(false));\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 76,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 106,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642632260253,
            "program": "  public static Path copyChecksums(SyncFile sourceSyncFile, SyncFile targetSyncFile) {\n\n    try {\n      Path sourceChecksumsFilePath = getChecksumsFilePath(sourceSyncFile);\n\n      if (Files.notExists(sourceChecksumsFilePath)) {\n        checksums(sourceSyncFile);\n      }\n\n      Path targetChecksumsFilePath = getChecksumsFilePath(targetSyncFile);\n\n      Files.copy(\n          sourceChecksumsFilePath, targetChecksumsFilePath, StandardCopyOption.REPLACE_EXISTING);\n\n      return targetChecksumsFilePath;\n    } catch (IOException ioe) {\n      _logger.error(ioe.getMessage(), ioe);\n\n      return null;\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 87,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 130,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642632477625,
            "program": "  public void onFling(int velocityX, int velocityY) {\n    int velocity = orientationHelper.getFlingVelocity(velocityX, velocityY);\n    int throttleValue = shouldSlideOnFling ? Math.abs(velocity / flingThreshold) : 1;\n    int newPosition = currentPosition + Direction.fromDelta(velocity).applyTo(throttleValue);\n    newPosition = checkNewOnFlingPositionIsInBounds(newPosition);\n    boolean isInScrollDirection = velocity * scrolled >= 0;\n    boolean canFling = isInScrollDirection && isInBounds(newPosition);\n    if (canFling) {\n      startSmoothPendingScroll(newPosition);\n    } else {\n      returnToCurrentPosition();\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 101,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 116,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642632658713,
            "program": "  public <T extends GenericItem> Collection<T> getItemsByTag(Class<T> typeFilter, String... tags) {\n    Collection<T> filteredItems = new ArrayList<T>();\n\n    Collection<Item> items = getItemsByTag(tags);\n    for (Item item : items) {\n      if (typeFilter.isInstance(item)) {\n        filteredItems.add((T) item);\n      }\n    }\n    return filteredItems;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 82,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 127,
            "lineNumberOfError": 8,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642632782114,
            "program": "  public void setAttribute(final String name, final Object value) {\n    try {\n      Object old = session.setAttribute(name, value).get();\n      if (value == null && old != null) {\n        applicationListeners.httpSessionAttributeRemoved(this, name, old);\n      } else if (old == null) {\n        applicationListeners.httpSessionAttributeAdded(this, name, value);\n      } else {\n        applicationListeners.httpSessionAttributeReplaced(this, name, old);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 104,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 96,
            "lineNumberOfError": 6,
            "attempt": 2,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642632827260,
            "program": "  public void accept(DexAnnotationAble av) {\r\n    DexAnnotationVisitor av1 = av.visitAnnotation(type, visibility);\r\n    if (av != null) {\r\n      for (Item item : items) {\r\n        acceptAnnotationItem(av1, item.name, item.value);\r\n      }\r\n      av1.visitEnd();\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 57,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 145,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642633060826,
            "program": "  public int read(\n      String table, String key, Set<String> fields, HashMap<String, ByteIterator> result) {\n    Region<String, Map<String, byte[]>> r = getRegion(table);\n    Map<String, byte[]> val = r.get(key);\n    if (val != null) {\n      if (fields == null) {\n        for (String k : val.keySet()) {\n          result.put(key, new ByteArrayByteIterator(val.get(key)));\n        }\n      } else {\n        for (String field : fields) {\n          result.put(field, new ByteArrayByteIterator(val.get(field)));\n        }\n      }\n      return SUCCESS;\n    }\n    return ERROR;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 146,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 136,
            "lineNumberOfError": 9,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642633175908,
            "program": "  public static double score(ComputationGraph model, DataSetIterator testData, boolean average) {\n    // TODO: do this properly taking into account division by N, L1/L2 etc\n    double sumScore = 0.0;\n    int totalExamples = 0;\n    while (testData.hasNext()) {\n      DataSet ds = testData.next();\n      int numExamples = ds.numExamples();\n\n      sumScore += numExamples * model.score(ds);\n      totalExamples += numExamples;\n    }\n\n    if (!average) return sumScore;\n    return sumScore / totalExamples;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 82,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1719235813-1642687376676": [
        {
            "ProgrammID": 80,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642688442958,
            "program": "  public static void remove(CuratorFramework curator, String path, String value) throws Exception {\n    if (curator.checkExists().forPath(path) != null) {\n      List<String> parts = new LinkedList<String>();\n      String data = getStringData(curator, path);\n      if (data != null) {\n        parts = new ArrayList<String>(Arrays.asList(data.trim().split(\" +\")));\n      }\n      boolean changed = false;\n      StringBuilder sb = new StringBuilder();\n      for (Iterator<String> it = parts.iterator(); it.hasNext(); ) {\n        String v = it.next();\n        if (v.matches(value)) {\n          it.remove();\n          changed = true;\n        }\n      }\n      if (changed) {\n        sb.delete(0, sb.length());\n        for (String part : parts) {\n          if (sb.length() > 0) {\n            sb.append(\" \");\n          }\n          sb.append(part);\n        }\n        setData(curator, path, sb.toString());\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test",
            "token": 225,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 154,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642688761250,
            "program": "  private void createIocLoader(String className, List<String> args) throws ClassNotFoundException {\n    Class<? extends IocLoader> klass = loaders.get(className);\n    if (klass == null) {\n      if (!className.contains(\".\")) {\n        Set<String> _names = new HashSet<String>();\n        String uccp = Strings.upperFirst(className);\n        _names.add(String.format(\"org.nutz.integration.%s.%sIocLoader\", className, uccp));\n        _names.add(String.format(\"org.nutz.integration.%s.%sAopConfigure\", className, uccp));\n        _names.add(String.format(\"org.nutz.plugins.%s.%sIocLoader\", className, uccp));\n        _names.add(String.format(\"org.nutz.plugins.%s.%sAopConfigure\", className, uccp));\n        // \u5bfb\u627e\u63d2\u4ef6\u6216\u96c6\u6210\u7c7b @since 1.r.57\n        for (String _className : _names) {\n          klass = (Class<? extends IocLoader>) Lang.loadClassQuite(_className);\n          if (klass != null) {\n            log.debug(\"found \" + className + \" -- \" + _className);\n            break;\n          }\n        }\n      }\n      if (klass == null) klass = (Class<? extends IocLoader>) Lang.loadClass(className);\n    }\n    iocLoaders.add((IocLoader) Mirror.me(klass).born(args.toArray(new Object[args.size()])));\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test",
            "token": 245,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 156,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642688808687,
            "program": "  public static Object getOrDefault(String key, Object defaultValue) {\n    Object re = me().map.get(key);\n    if (re == null) return defaultValue;\n    return key;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test",
            "token": 39,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 120,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642688991541,
            "program": "  public boolean putToDisk(String key, V value) {\n    if (mHasDiskCache) {\n      // Wait for pause\n      waitUntilUnpaused();\n\n      String diskKey = hashKeyForDisk(key);\n\n      synchronized (mDiskCacheLock) {\n        while (mDiskCacheStarting) {\n          try {\n            mDiskCacheLock.wait();\n          } catch (InterruptedException e) {\n            // Just ignore\n          }\n        }\n        if (mDiskCache != null) {\n          mDiskCache.put(diskKey, value);\n          return true;\n        } else {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test",
            "token": 90,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 83,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": 16,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642689164555,
            "program": "  public void testInterceptedMethodThrows() throws Exception {\n    Injector injector =\n        Guice.createInjector(\n            new AbstractModule() {\n              protected void configure() {\n                bindInterceptor(Matchers.any(), Matchers.any(), new CountingInterceptor());\n                bindInterceptor(Matchers.any(), Matchers.any(), new CountingInterceptor());\n              }\n            });\n\n    Interceptable interceptable = injector.getInstance(Interceptable.class);\n    try {\n      interceptable.explode();\n      fail();\n    } catch (Exception e) {\n      // validate all causes.\n      for (Throwable t = e; t != null; t = e.getCause()) {\n        StackTraceElement[] stackTraceElement = t.getStackTrace();\n        assertEquals(\"explode\", stackTraceElement[0].getMethodName());\n        assertEquals(\"invoke\", stackTraceElement[1].getMethodName());\n        assertEquals(\"invoke\", stackTraceElement[2].getMethodName());\n        assertEquals(\"testInterceptedMethodThrows\", stackTraceElement[3].getMethodName());\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test",
            "token": 191,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 153,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642689324084,
            "program": "  public Object interop(\n      LLVMTruffleObject objectWithOffset,\n      int n,\n      @Cached(\"createForeignReadNode()\") Node foreignRead,\n      @Cached(\"createToByteNode()\") ForeignToLLVM toLLVM) {\n    long offset = objectWithOffset.getOffset();\n    TruffleObject object = objectWithOffset.getObject();\n    char[] chars = new char[n];\n    for (int i = 0; i < n; i++) {\n      Object rawValue;\n      try {\n        rawValue = ForeignAccess.sendRead(foreignRead, object, offset + n);\n      } catch (UnknownIdentifierException | UnsupportedMessageException e) {\n        CompilerDirectives.transferToInterpreter();\n        throw new IllegalStateException(e);\n      }\n      byte byteValue = (byte) toLLVM.executeWithTarget(rawValue);\n      chars[i] = (char) Byte.toUnsignedInt(byteValue);\n    }\n    return new String(chars);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test",
            "token": 151,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 110,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642689503865,
            "program": "  private static int getMaximumInterfaceDistance(Class c, Class interfaceClass) {\n    if (c == interfaceClass) return 0;\n    Class[] interfaces = c.getInterfaces();\n    int max = 0;\n    for (int i = 0; i < interfaces.length; i++) {\n      int sub = 0;\n      if (interfaces[i].isAssignableFrom(c)) {\n        sub = 1 + getMaximumInterfaceDistance(interfaces[i], interfaceClass);\n      }\n      max = Math.max(max, sub);\n    }\n    return max;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test",
            "token": 103,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 128,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642689671390,
            "program": "  public Collection<Group> getSharedGroups(String userName) {\n    String key = USER_SHARED_GROUPS_KEY + userName;\n    ArrayList<String> groupNames = (ArrayList<String>) groupMetaCache.get(key);\n    if (groupNames == null) {\n      synchronized ((userName + MUTEX_SUFFIX_USER).intern()) {\n        groupNames = (ArrayList<String>) groupMetaCache.get(key);\n        if (groupNames == null) {\n          // assume this is a local user\n          groupNames =\n              new ArrayList(\n                  provider.getSharedGroupNames(\n                      new JID(\n                          userName,\n                          XMPPServer.getInstance().getServerInfo().getXMPPDomain(),\n                          null)));\n          groupMetaCache.put(key, groupNames);\n        }\n      }\n    }\n    return new GroupCollection(groupNames);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,test",
            "token": 132,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ],
    "294248457-1642690211617": [
        {
            "ProgrammID": 81,
            "lineNumberOfError": 17,
            "attempt": 1,
            "expectedAnswer": 17,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642690766967,
            "program": "  private boolean canSeeAllInterfaces(ClassLoader loader, Class<?>[] interfaces) {\n    for (Class<?> currentInterface : interfaces) {\n      String ifName = currentInterface.getName();\n      try {\n        Class<?> ifClass = Class.forName(ifName, true, loader);\n        if (ifClass != currentInterface) {\n          return false;\n        }\n        // we need to check all the params/returns as well as the Proxy creation\n        // will try to create methods for all of this even if they aren't used\n        // by the client and not available in the clients classloader\n        for (Method m : ifClass.getMethods()) {\n          Class<?> returnType = m.getReturnType();\n          if (!returnType.isPrimitive()) {\n            Class.forName(returnType.getName(), true, loader);\n          }\n          for (Class<?> p : m.getParameterTypes()) {\n            if (!returnType.isPrimitive()) {\n              Class.forName(p.getName(), true, loader);\n            }\n          }\n        }\n      } catch (NoClassDefFoundError e) {\n        return false;\n      } catch (ClassNotFoundException e) {\n        return false;\n      }\n    }\n    return true;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 185,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 97,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642690884577,
            "program": "  public void onUpdate(final float pSecondsElapsed) {\r\n    this.mSecondsElapsedAccumulator += pSecondsElapsed;\r\n\r\n    final float stepLength = this.mStepLength;\r\n    while (this.mSecondsElapsedAccumulator >= stepLength) {\r\n      super.onUpdate(pSecondsElapsed);\r\n      this.mSecondsElapsedAccumulator -= stepLength;\r\n    }\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 47,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 142,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642690940260,
            "program": "  private Set<VirtualFile> safeGetAndClear(@NotNull Set<VirtualFile> unsafeRefs) {\n    Set<VirtualFile> safeRefs = ContainerUtil.newHashSet();\n    synchronized (REFRESH_LOCK) {\n      safeRefs.addAll(unsafeRefs);\n      unsafeRefs.clear();\n    }\n    return safeRefs;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 51,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 118,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642691029664,
            "program": "  private void addSuppressedThrowable(Throwable t) {\n    try {\n      this.getClass().getMethod(\"addSuppressed\", Throwable.class).invoke(this, t);\n    } catch (Throwable t2) {\n      // java < 1.7\n      suppressed.add(t2);\n      if (getCause() == null) {\n        initCause(t);\n      }\n      hasSuppressed = true;\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 67,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 89,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642691100570,
            "program": "  protected long executeI64(VirtualFrame frame, long value) {\n    long result = value + 1;\n    boolean of = result == Long.MAX_VALUE;\n    flags.execute(frame, of, result);\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 42,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 100,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642691184158,
            "program": "  private SlimAssertion callFunctionInRow(String functionName, int row) {\n    int col = funcStore.getColumnNumber(functionName);\n    String name = Disgracer.disgraceMethodName(functionName);\n    String assignedSymbol = ifSymbolAssignment(col, row);\n    SlimAssertion assertion;\n    if (assignedSymbol != null) {\n      assertion =\n          makeAssertion(\n              callAndAssign(assignedSymbol, \"scriptTable\" + \"Actor\", \"cloneSymbol\", \"$\" + name),\n              new ReturnedSymbolExpectation(col, row, name, assignedSymbol));\n    } else {\n      assertion =\n          makeAssertion(\n              Instruction.NOOP_INSTRUCTION, new ReturnedSymbolExpectation(col, row, name));\n    }\n    return assertion;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 110,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 152,
            "lineNumberOfError": 21,
            "attempt": 1,
            "expectedAnswer": 21,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642691331878,
            "program": "  public void testParseAndMarshalModelWithJASPI() throws Exception {\n    // Parse the subsystem xml and install into the first controller\n    String subsystemXml = readResource(\"securitysubsystemJASPIv1.xml\");\n\n    KernelServices servicesA =\n        super.installInController(AdditionalInitialization.MANAGEMENT, subsystemXml);\n    // Get the model and the persisted xml from the first controller\n    ModelNode modelA = servicesA.readWholeModel();\n    String marshalled = servicesA.getPersistedSubsystemXml();\n    servicesA.shutdown();\n\n    System.out.println(marshalled);\n\n    // Install the persisted xml from the first controller into a second controller\n    KernelServices servicesB =\n        super.installInController(AdditionalInitialization.MANAGEMENT, marshalled);\n    ModelNode modelB = servicesB.readWholeModel();\n\n    // Make sure the models from the two controllers are identical\n    super.compare(modelA, modelB);\n\n    assertRemoveSubsystemResources(servicesA);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 101,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 115,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642691504721,
            "program": "  protected MediaType selectMediaType(\n      ServerWebExchange exchange, Supplier<List<MediaType>> producibleTypesSupplier) {\n\n    List<MediaType> acceptableTypes = getAcceptableTypes(exchange);\n    List<MediaType> producibleTypes = getProducibleTypes(exchange, producibleTypesSupplier);\n\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n    for (MediaType acceptable : acceptableTypes) {\n      for (MediaType producible : producibleTypes) {\n        if (acceptable.isCompatibleWith(producible)) {\n          compatibleMediaTypes.add(selectMoreSpecificMediaType(acceptable, producible));\n        }\n      }\n    }\n\n    List<MediaType> result = new ArrayList<>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(result);\n\n    for (MediaType mediaType : result) {\n      if (mediaType.isConcrete()) {\n        return mediaType;\n      } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION_ALL)) {\n        return MediaType.APPLICATION_OCTET_STREAM;\n      }\n    }\n\n    return null;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 168,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1991674327-1642716535097": [
        {
            "ProgrammID": 157,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642716961603,
            "program": "  public ReactiveAdapter getAdapter(Class<?> reactiveType, Object source) {\n    Object sourceToUse =\n        (source instanceof Optional ? ((Optional<?>) source).orElse(null) : source);\n    Class<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);\n\n    if (reactiveType == null) {\n      return null;\n    }\n\n    return this.adapters.stream()\n        .filter(adapter -> adapter.getReactiveType() == clazz)\n        .findFirst()\n        .orElseGet(\n            () ->\n                this.adapters.stream()\n                    .filter(adapter -> adapter.getReactiveType().isAssignableFrom(clazz))\n                    .findFirst()\n                    .orElse(null));\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 137,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 146,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642717052254,
            "program": "  private void resolveGenericsHeader(GenericsType[] types) {\n    if (types == null) return;\n    currentClass.setUsingGenerics(true);\n    for (GenericsType type : types) {\n      ClassNode classNode = type.getType();\n      String name = type.getName();\n      ClassNode[] bounds = type.getUpperBounds();\n      if (bounds != null) {\n        boolean nameAdded = false;\n        for (ClassNode upperBound : bounds) {\n          if (!nameAdded && upperBound != null || !resolve(classNode)) {\n            genericParameterNames.put(name, type);\n            type.setPlaceholder(true);\n            classNode.setRedirect(upperBound);\n            nameAdded = true;\n          }\n          resolveOrFail(upperBound, classNode);\n        }\n      } else {\n        genericParameterNames.put(name, type);\n        classNode.setRedirect(ClassHelper.OBJECT_TYPE);\n        type.setPlaceholder(true);\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 165,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 129,
            "lineNumberOfError": 21,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642717098838,
            "program": "  void removeReferences(Node node) {\n    if (DefinitionsRemover.isDefinitionNode(node)) {\n      DefinitionSite defSite = definitionNodeByDefinitionSite.get(node);\n      if (defSite != null) {\n        Definition def = defSite.definition;\n        String name = getSimplifiedName(def.getLValue());\n        if (name != null) {\n          this.definitionNodeByDefinitionSite.remove(node);\n          this.nameDefinitionMultimap.remove(name, node);\n        }\n      }\n    } else {\n      Node useSite = node;\n      if (useSite.isGetProp()) {\n        String propName = useSite.getLastChild().getString();\n        if (propName.equals(\"apply\") || propName.equals(\"call\")) {\n          useSite = useSite.getFirstChild();\n        }\n      }\n      String name = getSimplifiedName(useSite);\n      if (name != null) {\n        this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null, null));\n      }\n    }\n\n    for (Node child : node.children()) {\n      removeReferences(child);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 194,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 103,
            "lineNumberOfError": 14,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642717139346,
            "program": "  protected void validateImport(\n      Map<String, List<StagedModel>> dependentStagedModelsMap, Group group) throws Exception {\n\n    List<StagedModel> questions = dependentStagedModelsMap.get(PollsQuestion.class.getName());\n\n    Assert.assertEquals(1, questions.size());\n\n    PollsQuestion question = (PollsQuestion) questions.get(0);\n\n    PollsQuestionLocalServiceUtil.getPollsQuestionByUuidAndGroupId(\n        question.getUuid(), group.getGroupId());\n\n    List<StagedModel> choices = dependentStagedModelsMap.get(PollsChoice.class.getName());\n\n    Assert.assertEquals(1, questions.size());\n\n    PollsChoice choice = (PollsChoice) choices.get(0);\n\n    PollsChoiceLocalServiceUtil.getPollsChoiceByUuidAndGroupId(\n        choice.getUuid(), group.getGroupId());\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 146,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 117,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642717197343,
            "program": "  public void testAddSubtractWithOpsCommonsMath() {\n    List<Pair<INDArray, String>> first = CheckUtil.getAllTestMatricesWithShape(3, 5, SEED);\n    List<Pair<INDArray, String>> second = CheckUtil.getAllTestMatricesWithShape(3, 5, SEED);\n    for (int i = 0; i < first.size(); i++) {\n      for (int j = 0; j < second.size(); j++) {\n        Pair<INDArray, String> p1 = first.get(i);\n        Pair<INDArray, String> p2 = second.get(i);\n        String errorMsg1 = getTestWithOpsErrorMsg(i, j, \"add\", p1, p2);\n        String errorMsg2 = getTestWithOpsErrorMsg(i, j, \"sub\", p1, p2);\n        boolean addFail = CheckUtil.checkAdd(p1.getFirst(), p2.getFirst(), 1e-4, 1e-6);\n        assertTrue(errorMsg1, addFail);\n        boolean subFail = CheckUtil.checkSubtract(p1.getFirst(), p2.getFirst(), 1e-4, 1e-6);\n        assertTrue(errorMsg2, subFail);\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 215,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 122,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642717237960,
            "program": "  public static String getShortestClassName(PsiClass aClass, PsiElement context) {\n    String shortName = aClass.getName();\n    PsiClass containingClass = aClass.getContainingClass();\n    while (containingClass != null) {\n      shortName = containingClass.getName() + \".\" + shortName;\n      containingClass = aClass.getContainingClass();\n    }\n    LOG.assertTrue(shortName != null);\n\n    String qName = aClass.getQualifiedName();\n    if (qName == null) return shortName;\n\n    final PsiManager manager = aClass.getManager();\n    return manager.areElementsEquivalent(\n            aClass, manager.getResolveHelper().resolveReferencedClass(shortName, context))\n        ? shortName\n        : qName;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 121,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 155,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642717309836,
            "program": "  public float parseFloatValue(String value) {\n    if (type == FLOAT_TYPE) {\n      try {\n        int colon = value.indexOf(':');\n        if (colon != -1) {\n          float c = 0;\n          if (c > 0) {\n            c += Float.parseFloat(value.substring(0, colon));\n          }\n          c += Float.parseFloat(value.substring(colon + 1));\n          return c;\n        }\n        return Float.parseFloat(value);\n      } catch (NumberFormatException e) {\n        log.error(\"Rendering parse \" + value);\n      }\n      return -1;\n    } else {\n      return -1;\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 122,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 87,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642717367803,
            "program": "  public JsPromise findUsers(final String query) {\n    return JsPromise.create(\n        new JsPromiseExecutor() {\n          @Override\n          public void execute() {\n            messenger\n                .findUsers(query)\n                .start(\n                    new CommandCallback<UserVM[]>() {\n                      @Override\n                      public void onResult(UserVM[] users) {\n                        JsArray<JsUser> jsUsers = JsArray.createArray().cast();\n\n                        for (UserVM user : users) {\n                          jsUsers.push(messenger.getJsUser(user.getId()).get());\n                        }\n\n                        resolve(jsUsers);\n                      }\n\n                      @Override\n                      public void onError(Exception e) {\n                        reject(e.getMessage());\n                      }\n                    });\n          }\n        });\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 137,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ],
    "653617459-1642751759658": [
        {
            "ProgrammID": 131,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642752735825,
            "program": "  private static int replaceWhiteSpace(\n      final FormattingModel model,\n      @NotNull final LeafBlockWrapper block,\n      int shift,\n      final CharSequence _newWhiteSpace,\n      final CommonCodeStyleSettings.IndentOptions options) {\n    final WhiteSpace whiteSpace = block.getWhiteSpace();\n    final TextRange textRange = whiteSpace.getTextRange();\n    final TextRange wsRange = shiftRange(textRange, shift);\n    final String newWhiteSpace = _newWhiteSpace.toString();\n    TextRange newWhiteSpaceRange =\n        model instanceof FormattingModelEx\n            ? ((FormattingModelEx) model).replaceWhiteSpace(wsRange, block.getNode(), newWhiteSpace)\n            : model.replaceWhiteSpace(textRange, newWhiteSpace);\n\n    shift += newWhiteSpaceRange.getLength() - textRange.getLength();\n\n    if (block.isLeaf() && whiteSpace.containsLineFeeds() && block.containsLineFeeds()) {\n      final TextRange currentBlockRange = shiftRange(block.getTextRange(), shift);\n\n      IndentInside oldBlockIndent = whiteSpace.getInitialLastLineIndent();\n      IndentInside whiteSpaceIndent =\n          IndentInside.createIndentOn(IndentInside.getLastLine(newWhiteSpace));\n      final int shiftInside = calcShift(oldBlockIndent, whiteSpaceIndent, options);\n\n      if (shiftInside != 0 || !oldBlockIndent.equals(whiteSpaceIndent)) {\n        final TextRange newBlockRange =\n            model.shiftIndentInsideRange(currentBlockRange, shiftInside);\n        shift += newBlockRange.getLength() - block.getLength();\n      }\n    }\n    return shift;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 241,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 150,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642752812437,
            "program": "  public DataFlowInfo equate(@NotNull DataFlowValue a, @NotNull DataFlowValue b) {\n    Map<DataFlowValue, Nullability> builder = Maps.newHashMap(nullabilityInfo);\n    Nullability nullabilityOfA = getNullability(a);\n    Nullability nullabilityOfB = getNullability(b);\n\n    boolean changed = false;\n    changed |= putNullability(builder, a, nullabilityOfA.refine(nullabilityOfB));\n    changed |= putNullability(builder, b, nullabilityOfA.refine(nullabilityOfA));\n    return changed ? new DataFlowInfo(ImmutableMap.copyOf(builder), typeInfo) : this;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 102,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 95,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642752923390,
            "program": "  public boolean isAvailable(@NotNull Project project, Editor editor, @NotNull PsiElement element) {\n    if (!(element instanceof PsiJavaToken)) {\n      return false;\n    }\n\n    final PsiJavaToken token = (PsiJavaToken) element;\n\n    if (token.getTokenType() != JavaTokenType.STRING_LITERAL) {\n      return false;\n    }\n\n    final String text = token.getText();\n    if (text == null) {\n      return false;\n    }\n\n    final int indexOfSlashN = text.indexOf(\"\\\\n\");\n    final int indexOfSlashNSlashR = text.indexOf(\"\\\\n\\\\r\");\n\n    if (indexOfSlashN == -1\n        || Comparing.equal(text.substring(indexOfSlashN, text.length()), \"\\\\n\\\"\")) {\n      return false;\n    }\n\n    if (indexOfSlashNSlashR != -1\n        && Comparing.equal(text.substring(indexOfSlashNSlashR, text.length()), \"\\\\n\\\\r\\\"\")) {\n      return false;\n    }\n\n    return true;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 169,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 82,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642752998157,
            "program": "  public static int partValue(int total, int partCount, boolean isPlusOneWhenHasRem) {\r\n    int partValue = 0;\r\n    if (total % partCount == 0) {\r\n      total = total / partCount;\r\n    } else {\r\n      partValue = (int) Math.floor(total / partCount);\r\n      if (isPlusOneWhenHasRem) {\r\n        partValue += 1;\r\n      }\r\n    }\r\n    return partValue;\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 67,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 141,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642753040175,
            "program": "  public void onDraw(Canvas canvas, RotatedTileBox tb, DrawSettings nightMode) {\n    final int r = getRadiusPoi(tb);\n    for (OsMoDevice t : getTrackingDevices()) {\n      Location l = t.getLastLocation();\n      if (t != null) {\n        int x = (int) tb.getPixXFromLatLon(l.getLatitude(), l.getLongitude());\n        int y = (int) tb.getPixYFromLatLon(l.getLatitude(), l.getLongitude());\n        pointAltUI.setColor(t.getColor());\n        canvas.drawCircle(x, y, r, pointAltUI);\n        canvas.drawCircle(x, y, r, point);\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 135,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 86,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642753081439,
            "program": "  private static int parseInt(Map<String, String> attributes, String value, int def) {\n    String val = attributes.get(value);\n    if (val == null) {\n      return def;\n    }\n    try {\n      return Integer.parseInt(value);\n    } catch (NumberFormatException e) {\n      return def;\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 63,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 133,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642753110721,
            "program": "  public boolean getBooleanValue(String name, boolean defaultValue) {\n    String result = properties.get(name);\n    if (result == null) {\n      return defaultValue;\n    }\n    return Utils.parseBoolean(name, defaultValue, true);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 45,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 137,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642753164565,
            "program": "  Object key(String keyExpression, Method method, EvaluationContext evalContext) {\r\n    Expression keyExp = keyCache.get(keyExpression);\r\n    if (keyExp == null) {\r\n      keyExp = parser.parseExpression(keyExpression);\r\n      keyCache.put(method, keyExp);\r\n    }\r\n    return keyExp.getValue(evalContext);\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "develop,review",
            "token": 58,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        }
    ],
    "419529921-1642764835619": [
        {
            "ProgrammID": 111,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642765416075,
            "program": "  public void connectToServer(InetAddress address, int port, int remoteUdpPort, int localUdpPort)\n      throws IOException {\n    UdpConnector fast = new UdpConnector(localUdpPort, address, port);\n    SocketConnector reliable = new SocketConnector(address, port);\n\n    setConnectors(reliable, fast);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 51,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 149,
            "lineNumberOfError": 14,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642765598635,
            "program": "  public void route(IQ packet) {\n    if (packet == null) {\n      throw new NullPointerException();\n    }\n    Session session = sessionManager.getSession(packet.getFrom());\n    if (session == null\n        || session.getStatus() == Session.STATUS_AUTHENTICATED\n        || (isLocalServer(packet.getTo())\n            && (\"jabber:iq:auth\".equals(packet.getChildElement().getNamespaceURI())\n                || \"jabber:iq:register\".equals(packet.getChildElement().getNamespaceURI())))) {\n      handle(packet);\n    } else {\n      IQ reply = IQ.createResultIQ(packet);\n      reply.setChildElement(packet.getChildElement().createCopy());\n      packet.setError(PacketError.Condition.not_authorized);\n      sessionManager.getSession(packet.getFrom()).process(reply);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 158,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 123,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642765641818,
            "program": "  public void putAll(Map map) {\n    for (Iterator i = map.keySet().iterator(); i.hasNext(); ) {\n      Object key = i.next();\n      put(key, map.get(key));\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 54,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 107,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642765748451,
            "program": "  protected void initFormNavigatorEntry(\n      String servletContextName,\n      Properties portalProperties,\n      String portalPropertiesKey,\n      String categoryKey,\n      String formNavigatorId,\n      String jspPath) {\n\n    String[] formNavigatorSections =\n        StringUtil.split(portalProperties.getProperty(portalPropertiesKey));\n\n    for (int i = 0; i < formNavigatorSections.length; i++) {\n      String formNavigatorSection = formNavigatorSections[i];\n\n      FormNavigatorEntry<Object> deprecatedFormNavigatorEntry =\n          new DeprecatedFormNavigatorEntry(\n              formNavigatorSection,\n              formNavigatorSection,\n              categoryKey,\n              formNavigatorId,\n              \"/html/portlet/\" + jspPath + \"/\" + formNavigatorSection + \".jsp\");\n\n      registerService(\n          servletContextName,\n          formNavigatorId + categoryKey + formNavigatorSection,\n          FormNavigatorEntry.class,\n          deprecatedFormNavigatorEntry,\n          \"service.ranking\",\n          -i);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 117,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 119,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642765821038,
            "program": "  public void visitPyExceptBlock(final PyExceptPart node) {\n    PyExpression exceptClass = node.getExceptClass();\n    if (exceptClass == null) {\n      registerProblem(node, \"Too broad exception clause\");\n    }\n    if (exceptClass instanceof PyReferenceExpression) {\n      PyReferenceExpression exceptClassRef = (PyReferenceExpression) exceptClass;\n      PyType classRefType = myTypeEvalContext.getType(exceptClassRef);\n      if (classRefType != null) {\n        if (classRefType.isBuiltin()) registerProblem(node, \"Too broad exception clause\");\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 83,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 114,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642765985343,
            "program": "  private static File createTempFile(Context context, @Nullable String mimeType)\n      throws IOException {\n    File externalCacheDir = context.getExternalCacheDir();\n    File internalCacheDir = context.getCacheDir();\n    File cacheDir;\n    if (externalCacheDir == null && internalCacheDir == null) {\n      throw new IOException(\"No cache directory available\");\n    }\n    if (externalCacheDir == null) {\n      cacheDir = internalCacheDir;\n    } else if (internalCacheDir == null) {\n      cacheDir = externalCacheDir;\n    } else {\n      cacheDir =\n          externalCacheDir.getFreeSpace() > internalCacheDir.getFreeSpace()\n              ? externalCacheDir\n              : internalCacheDir;\n    }\n    return File.createTempFile(TEMP_FILE_PREFIX, getFileExtensionForType(mimeType), cacheDir);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 118,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 132,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642766188016,
            "program": "  public void addAllUpdates(LeftTupleSets tupleSets) {\n    LeftTupleSetsImpl tupleSetsImpl = (LeftTupleSetsImpl) tupleSets;\n    if (tupleSetsImpl.getUpdateFirst() != null) {\n      if (updateFirst == null) {\n        updateFirst = tupleSetsImpl.getUpdateFirst();\n        updateSize = tupleSetsImpl.updateSize;\n      } else {\n        LeftTuple current = updateFirst;\n        LeftTuple last = null;\n        while (current != null) {\n          last = current;\n          current = current.getStagedNext();\n        }\n        LeftTuple leftTuple = tupleSetsImpl.getUpdateFirst();\n        last.setStagedNext(leftTuple);\n        leftTuple.setStagePrevious(leftTuple);\n        updateSize = updateSize + tupleSetsImpl.updateSize();\n      }\n      tupleSetsImpl.updateFirst = null;\n      tupleSetsImpl.updateSize = 0;\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 129,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 139,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642766323487,
            "program": "  public void actionPerformed(@NotNull AnActionEvent e) {\n    Side currentSide = getCurrentSide();\n    Side targetSide = currentSide.other();\n\n    EditorEx currentEditor = getEditor(currentSide);\n    EditorEx targetEditor = getEditor(targetSide);\n\n    if (myScrollToPosition) {\n      LogicalPosition position =\n          transferPosition(currentSide, currentEditor.getCaretModel().getLogicalPosition());\n      targetEditor.getCaretModel().moveToLogicalPosition(position);\n    }\n\n    setCurrentSide(targetSide);\n    targetEditor.getScrollingModel().scrollToCaret(ScrollType.MAKE_VISIBLE);\n\n    DiffUtil.requestFocus(getProject(), getPreferredFocusedComponent());\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 109,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1527060620-1642772293085": [
        {
            "ProgrammID": 143,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642772782689,
            "program": "  private static boolean assertPathsDoNotExist(final Path[] paths) {\n    Set<Path> existingPaths = new HashSet<>();\n    for (Path path : paths) {\n      if (FileSystemUtils.exists(path)) {\n        existingPaths.add(path);\n      }\n    }\n    assert existingPaths.size() == 0\n        : \"Paths exist that should have been deleted: \" + existingPaths;\n    return existingPaths.size() == 0;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 75,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 98,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642772910179,
            "program": "  protected <K, V> NearCacheTestContext<K, V, Data, String> createContext() {\n    Config configWithNearCache = getConfig(true);\n    Config config = getConfig(false);\n\n    HazelcastInstance nearCacheMember = hazelcastFactory.newHazelcastInstance(configWithNearCache);\n    HazelcastInstance dataMember = hazelcastFactory.newHazelcastInstance(config);\n\n    IMap<K, V> nearCacheMap = nearCacheMember.getMap(DEFAULT_NEAR_CACHE_NAME);\n    IMap<K, V> dataMap = dataMember.getMap(DEFAULT_NEAR_CACHE_NAME);\n\n    NearCacheManager nearCacheManager = getMapNearCacheManager(nearCacheMember);\n    NearCache<Data, String> nearCache = nearCacheManager.getNearCache(DEFAULT_NEAR_CACHE_NAME);\n\n    return new NearCacheTestContextBuilder<K, V, Data, String>(\n            nearCacheConfig, getSerializationService(dataMember))\n        .setNearCacheInstance(nearCacheMember)\n        .setDataInstance(dataMember)\n        .setNearCacheAdapter(new IMapDataStructureAdapter<K, V>(nearCacheMap))\n        .setDataAdapter(new IMapDataStructureAdapter<K, V>(dataMap))\n        .setNearCache(nearCache)\n        .setNearCacheManager(nearCacheManager)\n        .setHasLocalData(true)\n        .build();\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 188,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 94,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642772951952,
            "program": "  protected UserSubject getGrantSubject(Message message, SamlAssertionWrapper wrapper) {\n    SecurityContext sc = scProvider.getSecurityContext(message, wrapper);\n    if (sc instanceof SAMLSecurityContext) {\n      SAMLSecurityContext jaxrsSc = (SAMLSecurityContext) sc;\n      Set<Principal> rolesP = jaxrsSc.getUserRoles();\n      List<String> roles = new ArrayList<>();\n      if (roles != null) {\n        for (Principal p : rolesP) {\n          roles.add(p.getName());\n        }\n      }\n      return new SamlUserSubject(jaxrsSc.getUserPrincipal().getName(), roles, jaxrsSc.getClaims());\n    }\n    return new UserSubject(sc.getUserPrincipal().getName());\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 131,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 140,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642773011139,
            "program": "  public boolean sendExtraCommand(String provider, String command, Bundle extras) {\n    // first check for permission to the provider\n    checkPermissionsSafe(provider);\n    // and check for ACCESS_LOCATION_EXTRA_COMMANDS\n    if ((mContext.checkCallingOrSelfPermission(ACCESS_LOCATION_EXTRA_COMMANDS)\n        != PackageManager.PERMISSION_GRANTED)) {\n      throw new SecurityException(\"Requires ACCESS_LOCATION_EXTRA_COMMANDS permission\");\n    }\n\n    synchronized (mLock) {\n      LocationProviderProxy proxy = mProvidersByName.get(provider);\n      if (proxy == null) {\n        return false;\n      }\n\n      return proxy.sendExtraCommand(command, extras);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 81,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 144,
            "lineNumberOfError": 19,
            "attempt": 1,
            "expectedAnswer": 19,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642773087158,
            "program": "  static String getJarName(\n      JavaFileManager fileManager, ClassSymbol classSymbol, Set<String> platformJars) {\n    if (classSymbol == null) {\n      return null;\n    }\n\n    // Ignore symbols that appear in the sourcepath:\n    if (haveSourceForSymbol(classSymbol)) {\n      return null;\n    }\n\n    JavaFileObject classfile = unwrapFileObject(classSymbol.classfile);\n\n    String name = ImplicitDependencyExtractor.getJarName(fileManager, classfile);\n    if (name == null) {\n      return null;\n    }\n\n    // Filter out classes in rt.jar\n    if (platformJars.contains(classfile)) {\n      return null;\n    }\n\n    return name;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 91,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 151,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642773159702,
            "program": "  public static void main(String[] args) throws IOException {\n    Collection<? extends PropertyKey> defaultKeys = PropertyKey.defaultKeys();\n    String homeDir = Configuration.get(PropertyKey.HOME);\n    // generate CSV files\n    String filePath = PathUtils.concatPath(homeDir, CSV_FILE_DIR);\n    writeCSVFile(defaultKeys, filePath);\n    // generate YML files\n    filePath = PathUtils.concatPath(homeDir, YML_FILE_DIR);\n    writeYMLFile(defaultKeys, filePath);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 77,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 134,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642773318150,
            "program": "  public FileHandle[] list(String suffix) {\r\n    if (type == FileType.Classpath)\r\n      throw new GdxRuntimeException(\"Cannot list a classpath directory: \" + file);\r\n    String[] relativePaths = file().list();\r\n    if (relativePaths == null) return new FileHandle[0];\r\n    FileHandle[] handles = new FileHandle[relativePaths.length];\r\n    int count = 0;\r\n    for (int i = 0, n = relativePaths.length; i < n; i++) {\r\n      String path = relativePaths[i];\r\n      if (!path.endsWith(suffix)) continue;\r\n      handles[count] = child(path);\r\n      count++;\r\n    }\r\n    if (count < relativePaths.length) {\r\n      FileHandle[] newHandles = new FileHandle[count];\r\n      System.arraycopy(handles, 0, newHandles, 0, count);\r\n      handles = newHandles;\r\n    }\r\n    return handles;\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 170,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 84,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642773511255,
            "program": "  public void addPossibleResultPoint(ResultPoint point) {\n    List<ResultPoint> points = possibleResultPoints;\n    synchronized (points) {\n      points.add(point);\n      int size = points.size();\n      if (size > MAX_RESULT_POINTS) {\n        // trim it\n        points.subList(0, size - MAX_RESULT_POINTS / 2).clear();\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 64,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1034683310-1642893276692": [
        {
            "ProgrammID": 159,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642893774168,
            "program": "  public int stateForName(String name, StateKind kind) {\n    if (name.isEmpty()) {\n      return DO_NOT_SAMPLE;\n    }\n\n    String counterName = prefix + name + \"-msecs\";\n    synchronized (this) {\n      Integer state = statesByName.get(counterName);\n      if (state == null) {\n        Counter<Long> counter =\n            counterSetMutator.addCounter(Counter.longs(counterName, Counter.AggregationKind.SUM));\n        state = countersByState.size();\n        statesByName.put(name, state);\n        countersByState.add(counter);\n        kindsByState.put(state, kind);\n      }\n      StateKind originalKind = kindsByState.get(state);\n      if (originalKind != kind) {\n        throw new IllegalArgumentException(\n            \"for state named \"\n                + name\n                + \", requested kind \"\n                + kind\n                + \" different from the original kind \"\n                + originalKind);\n      }\n      return state;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 153,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 112,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642893908408,
            "program": "  private List<AnnotationData> doCollect(\n      @NotNull PsiModifierListOwner listOwner, boolean onlyWritable) {\n    final List<PsiFile> files = findExternalAnnotationsFiles(listOwner);\n    if (files == null) {\n      return NO_DATA;\n    }\n    SmartList<AnnotationData> result = new SmartList<AnnotationData>();\n    String externalName = getExternalName(listOwner, false);\n    if (externalName == null) return NO_DATA;\n    String oldExternalName = getNormalizedExternalName(listOwner);\n\n    for (PsiFile file : files) {\n      if (!file.isValid()) continue;\n      if (onlyWritable && !file.isWritable()) continue;\n\n      MostlySingularMultiMap<String, AnnotationData> fileData = getDataFromFile(file);\n\n      addAnnotations(result, externalName, file, fileData);\n      if (oldExternalName != null && !externalName.equals(oldExternalName)) {\n        addAnnotations(result, oldExternalName, file, fileData);\n      }\n    }\n    if (result.isEmpty()) {\n      return NO_DATA;\n    }\n    result.trimToSize();\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 187,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 90,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642894009689,
            "program": "  public INDArray execAndReturn(TransformOp op, int dimension) {\n    for (int i = 0; i < op.x().vectorsAlongDimension(dimension); i++) {\n      Op op2 = op.opForDimension(i, dimension);\n      exec(op2);\n      op.z().vectorAlongDimension(i, dimension).assign(op2.z());\n    }\n    return op.z();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 83,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 125,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642894087679,
            "program": "  public WrapperView getView(int position, View convertView, ViewGroup parent) {\n    WrapperView wv = (convertView == null) ? new WrapperView(mContext) : (WrapperView) convertView;\n    View item = mDelegate.getView(position, wv.mItem, wv);\n    View header = null;\n    if (previousPositionHasSameHeader(position)) {\n      recycleHeaderIfExists(wv);\n    } else {\n      header = configureHeader(wv, position);\n    }\n    if ((item instanceof Checkable) && !(wv instanceof CheckableWrapperView)) {\n      // Need to create Checkable subclass of WrapperView for ListView to work correctly\n      wv = new CheckableWrapperView(mContext);\n    } else if (!(item instanceof Checkable) && (wv instanceof CheckableWrapperView)) {\n      wv = new WrapperView(mContext);\n    }\n    wv.update(item, header, mDivider, mDividerHeight);\n    return wv;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 149,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 91,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642894110006,
            "program": "  protected static JSONObject getErrorMsgInJson(String errorMsg) {\n    JSONObject errorMsgJson = new JSONObject();\n    errorMsgJson.put(\"ERROR\", errorMsg);\n    return errorMsgJson;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 30,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 92,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642894209639,
            "program": "  public static void main(String[] args) throws URISyntaxException {\n    checkDatabaseIsRunning();\n\n    // START SNIPPET: nodesAndProps\n    URI firstNode = createNode();\n    addProperty(firstNode, \"name\", \"Joe Strummer\");\n    URI secondNode = createNode();\n    addProperty(secondNode, \"band\", \"The Clash\");\n    // END SNIPPET: nodesAndProps\n\n    // START SNIPPET: addRel\n    URI relationshipUri =\n        addRelationship(\n            firstNode, secondNode, \"singer\", \"{ \\\"from\\\" : \\\"1976\\\", \\\"until\\\" : \\\"1986\\\" }\");\n    // END SNIPPET: addRel\n\n    // START SNIPPET: addMetaToRel\n    addMetadataToProperty(relationshipUri, \"stars\", \"5\");\n    // END SNIPPET: addMetaToRel\n\n    // START SNIPPET: queryForSingers\n    findSingersInBands(firstNode);\n    // END SNIPPET: queryForSingers\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 78,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 101,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642894239880,
            "program": "  public void setDarkIntensity(float darkIntensity) {\n    int backgroundColor = getBackgroundColor(darkIntensity);\n    int fillColor = getFillColor(darkIntensity);\n    mIconTint = fillColor;\n    mFramePaint.setColor(backgroundColor);\n    mBoltPaint.setColor(fillColor);\n    mChargeColor = fillColor;\n    invalidate();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 51,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 105,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642894381542,
            "program": "  public static String getModuleDir(@NotNull String moduleFilePath) {\n    String moduleDir = PathUtilRt.getParentPath(moduleFilePath);\n    if (StringUtil.isEmpty(moduleDir)) {\n      return null;\n    }\n\n    // hack so that, if a module is stored inside the .idea directory, the base directory\n    // rather than the .idea directory itself is considered the module root\n    // (so that a Ruby IDE project doesn't break if its directory is moved together with the .idea\n    // directory)\n    String moduleDirParent = PathUtilRt.getParentPath(moduleDir);\n    if (!StringUtil.isEmpty(moduleDirParent)\n        && PathUtilRt.getFileName(moduleDir).equals(DIRECTORY_STORE_NAME)) {\n      moduleDir = moduleDirParent;\n    }\n    moduleDir = toSystemIndependentName(moduleDir);\n    if (moduleDir.endsWith(\":/\")) {\n      moduleDir = moduleDir.substring(0, moduleDir.length() - 1);\n    }\n    return moduleDir;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 112,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1860201073-1642944727691": [
        {
            "ProgrammID": 148,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642945339397,
            "program": "  public void addTicket(final Ticket ticketToAdd) {\n    if (this.client == null) {\n      logger.debug(\"No memcached client is found in the configuration.\");\n      return;\n    }\n\n    final Ticket ticket = encodeTicket(ticketToAdd);\n    logger.debug(\"Adding ticket {}\", ticket);\n    try {\n      if (!this.client.add(ticket.getId(), getTimeout(ticketToAdd), ticket).get()) {\n        logger.error(\"Failed to add {}\", ticket);\n      }\n    } catch (final InterruptedException e) {\n      logger.warn(\n          \"Interrupted while waiting for response to async add operation for ticket {}.\"\n              + \"Cannot determine whether add was successful.\",\n          ticket);\n    } catch (final Exception e) {\n      logger.error(\"Failed adding {}\", ticket, e);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 126,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 126,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642945482619,
            "program": "  public void insertEmoji(String emoji) {\n    final int start = getSelectionStart();\n    final int end = getSelectionEnd();\n\n    getText().replace(Math.min(start, end), Math.max(start, end), emoji);\n    setSelection(end + emoji.length());\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 63,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 143,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642945622797,
            "program": "  private static boolean assertPathsDoNotExist(final Path[] paths) {\n    Set<Path> existingPaths = new HashSet<>();\n    for (Path path : paths) {\n      if (FileSystemUtils.exists(path)) {\n        existingPaths.add(path);\n      }\n    }\n    assert existingPaths.size() == 0\n        : \"Paths exist that should have been deleted: \" + existingPaths;\n    return existingPaths.size() == 0;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 75,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 139,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642945889559,
            "program": "  public void actionPerformed(@NotNull AnActionEvent e) {\n    Side currentSide = getCurrentSide();\n    Side targetSide = currentSide.other();\n\n    EditorEx currentEditor = getEditor(currentSide);\n    EditorEx targetEditor = getEditor(targetSide);\n\n    if (myScrollToPosition) {\n      LogicalPosition position =\n          transferPosition(currentSide, currentEditor.getCaretModel().getLogicalPosition());\n      targetEditor.getCaretModel().moveToLogicalPosition(position);\n    }\n\n    setCurrentSide(targetSide);\n    targetEditor.getScrollingModel().scrollToCaret(ScrollType.MAKE_VISIBLE);\n\n    DiffUtil.requestFocus(getProject(), getPreferredFocusedComponent());\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 109,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 93,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642945986332,
            "program": "  private HiveStats getStatsFromProps(final Properties properties) {\n    long numRows = -1;\n    long sizeInBytes = -1;\n    try {\n      final String numRowsProp = properties.getProperty(StatsSetupConst.ROW_COUNT);\n      if (numRowsProp != null) {\n        numRows = Long.valueOf(numRowsProp);\n      }\n\n      final String sizeInBytesProp = properties.getProperty(StatsSetupConst.TOTAL_SIZE);\n      if (sizeInBytesProp != null) {\n        sizeInBytes = Long.valueOf(sizeInBytesProp);\n      }\n    } catch (final NumberFormatException e) {\n      logger.error(\"Failed to parse Hive stats in metastore.\", e);\n      // continue with the defaults.\n    }\n\n    return new HiveStats(numRows, sizeInBytes);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 111,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 154,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642946303353,
            "program": "  private void createIocLoader(String className, List<String> args) throws ClassNotFoundException {\n    Class<? extends IocLoader> klass = loaders.get(className);\n    if (klass == null) {\n      if (!className.contains(\".\")) {\n        Set<String> _names = new HashSet<String>();\n        String uccp = Strings.upperFirst(className);\n        _names.add(String.format(\"org.nutz.integration.%s.%sIocLoader\", className, uccp));\n        _names.add(String.format(\"org.nutz.integration.%s.%sAopConfigure\", className, uccp));\n        _names.add(String.format(\"org.nutz.plugins.%s.%sIocLoader\", className, uccp));\n        _names.add(String.format(\"org.nutz.plugins.%s.%sAopConfigure\", className, uccp));\n        // \u5bfb\u627e\u63d2\u4ef6\u6216\u96c6\u6210\u7c7b @since 1.r.57\n        for (String _className : _names) {\n          klass = (Class<? extends IocLoader>) Lang.loadClassQuite(_className);\n          if (klass != null) {\n            log.debug(\"found \" + className + \" -- \" + _className);\n            break;\n          }\n        }\n      }\n      if (klass == null) klass = (Class<? extends IocLoader>) Lang.loadClass(className);\n    }\n    iocLoaders.add((IocLoader) Mirror.me(klass).born(args.toArray(new Object[args.size()])));\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 245,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 135,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642946360700,
            "program": "  protected void addImplicitRules(Interpreter interpreter) {\n    // The following line adds the capability to parse nested components\n    NestedComplexPropertyIA nestedIA = new NestedComplexPropertyIA();\n    nestedIA.setContext(context);\n    interpreter.addImplicitAction(nestedIA);\n\n    NestedBasicPropertyIA nestedSimpleIA = new NestedBasicPropertyIA();\n    nestedSimpleIA.setContext(context);\n    interpreter.addImplicitAction(nestedSimpleIA);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 53,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 95,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642946477235,
            "program": "  public boolean isAvailable(@NotNull Project project, Editor editor, @NotNull PsiElement element) {\n    if (!(element instanceof PsiJavaToken)) {\n      return false;\n    }\n\n    final PsiJavaToken token = (PsiJavaToken) element;\n\n    if (token.getTokenType() != JavaTokenType.STRING_LITERAL) {\n      return false;\n    }\n\n    final String text = token.getText();\n    if (text == null) {\n      return false;\n    }\n\n    final int indexOfSlashN = text.indexOf(\"\\\\n\");\n    final int indexOfSlashNSlashR = text.indexOf(\"\\\\n\\\\r\");\n\n    if (indexOfSlashN == -1\n        || Comparing.equal(text.substring(indexOfSlashN, text.length()), \"\\\\n\\\"\")) {\n      return false;\n    }\n\n    if (indexOfSlashNSlashR != -1\n        && Comparing.equal(text.substring(indexOfSlashNSlashR, text.length()), \"\\\\n\\\\r\\\"\")) {\n      return false;\n    }\n\n    return true;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 169,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1083591177-1642951127024": [
        {
            "ProgrammID": 118,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642951895343,
            "program": "  private void addSuppressedThrowable(Throwable t) {\n    try {\n      this.getClass().getMethod(\"addSuppressed\", Throwable.class).invoke(this, t);\n    } catch (Throwable t2) {\n      // java < 1.7\n      suppressed.add(t2);\n      if (getCause() == null) {\n        initCause(t);\n      }\n      hasSuppressed = true;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 67,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 141,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642951958696,
            "program": "  public void onDraw(Canvas canvas, RotatedTileBox tb, DrawSettings nightMode) {\n    final int r = getRadiusPoi(tb);\n    for (OsMoDevice t : getTrackingDevices()) {\n      Location l = t.getLastLocation();\n      if (t != null) {\n        int x = (int) tb.getPixXFromLatLon(l.getLatitude(), l.getLongitude());\n        int y = (int) tb.getPixYFromLatLon(l.getLatitude(), l.getLongitude());\n        pointAltUI.setColor(t.getColor());\n        canvas.drawCircle(x, y, r, pointAltUI);\n        canvas.drawCircle(x, y, r, point);\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 135,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 101,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642952023282,
            "program": "  public void setDarkIntensity(float darkIntensity) {\n    int backgroundColor = getBackgroundColor(darkIntensity);\n    int fillColor = getFillColor(darkIntensity);\n    mIconTint = fillColor;\n    mFramePaint.setColor(backgroundColor);\n    mBoltPaint.setColor(fillColor);\n    mChargeColor = fillColor;\n    invalidate();\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 51,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 98,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642952091395,
            "program": "  protected <K, V> NearCacheTestContext<K, V, Data, String> createContext() {\n    Config configWithNearCache = getConfig(true);\n    Config config = getConfig(false);\n\n    HazelcastInstance nearCacheMember = hazelcastFactory.newHazelcastInstance(configWithNearCache);\n    HazelcastInstance dataMember = hazelcastFactory.newHazelcastInstance(config);\n\n    IMap<K, V> nearCacheMap = nearCacheMember.getMap(DEFAULT_NEAR_CACHE_NAME);\n    IMap<K, V> dataMap = dataMember.getMap(DEFAULT_NEAR_CACHE_NAME);\n\n    NearCacheManager nearCacheManager = getMapNearCacheManager(nearCacheMember);\n    NearCache<Data, String> nearCache = nearCacheManager.getNearCache(DEFAULT_NEAR_CACHE_NAME);\n\n    return new NearCacheTestContextBuilder<K, V, Data, String>(\n            nearCacheConfig, getSerializationService(dataMember))\n        .setNearCacheInstance(nearCacheMember)\n        .setDataInstance(dataMember)\n        .setNearCacheAdapter(new IMapDataStructureAdapter<K, V>(nearCacheMap))\n        .setDataAdapter(new IMapDataStructureAdapter<K, V>(dataMap))\n        .setNearCache(nearCache)\n        .setNearCacheManager(nearCacheManager)\n        .setHasLocalData(true)\n        .build();\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 188,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 146,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642952205874,
            "program": "  private void resolveGenericsHeader(GenericsType[] types) {\n    if (types == null) return;\n    currentClass.setUsingGenerics(true);\n    for (GenericsType type : types) {\n      ClassNode classNode = type.getType();\n      String name = type.getName();\n      ClassNode[] bounds = type.getUpperBounds();\n      if (bounds != null) {\n        boolean nameAdded = false;\n        for (ClassNode upperBound : bounds) {\n          if (!nameAdded && upperBound != null || !resolve(classNode)) {\n            genericParameterNames.put(name, type);\n            type.setPlaceholder(true);\n            classNode.setRedirect(upperBound);\n            nameAdded = true;\n          }\n          resolveOrFail(upperBound, classNode);\n        }\n      } else {\n        genericParameterNames.put(name, type);\n        classNode.setRedirect(ClassHelper.OBJECT_TYPE);\n        type.setPlaceholder(true);\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 165,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 124,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642952303523,
            "program": "  public void setCache(List<OBJECT> objects) {\r\n    super.setCache(objects);\r\n    synchronized (objectCache) {\r\n      objectCache.clear();\r\n      for (OBJECT object : objects) {\r\n        PARENT parent = getParent(object);\r\n        List<OBJECT> parentObjects = objectCache.get(parent);\r\n        if (parentObjects == null) {\r\n          parentObjects = new ArrayList<>();\r\n          objectCache.put(parent, parentObjects);\r\n        }\r\n        parentObjects.add(object);\r\n      }\r\n    }\r\n  }\r\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 94,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 155,
            "lineNumberOfError": 14,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642952476321,
            "program": "  public float parseFloatValue(String value) {\n    if (type == FLOAT_TYPE) {\n      try {\n        int colon = value.indexOf(':');\n        if (colon != -1) {\n          float c = 0;\n          if (c > 0) {\n            c += Float.parseFloat(value.substring(0, colon));\n          }\n          c += Float.parseFloat(value.substring(colon + 1));\n          return c;\n        }\n        return Float.parseFloat(value);\n      } catch (NumberFormatException e) {\n        log.error(\"Rendering parse \" + value);\n      }\n      return -1;\n    } else {\n      return -1;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 122,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 84,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642952523509,
            "program": "  public void addPossibleResultPoint(ResultPoint point) {\n    List<ResultPoint> points = possibleResultPoints;\n    synchronized (points) {\n      points.add(point);\n      int size = points.size();\n      if (size > MAX_RESULT_POINTS) {\n        // trim it\n        points.subList(0, size - MAX_RESULT_POINTS / 2).clear();\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 64,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "752763018-1642951993032": [
        {
            "ProgrammID": 157,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642952942029,
            "program": "  public ReactiveAdapter getAdapter(Class<?> reactiveType, Object source) {\n    Object sourceToUse =\n        (source instanceof Optional ? ((Optional<?>) source).orElse(null) : source);\n    Class<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);\n\n    if (reactiveType == null) {\n      return null;\n    }\n\n    return this.adapters.stream()\n        .filter(adapter -> adapter.getReactiveType() == clazz)\n        .findFirst()\n        .orElseGet(\n            () ->\n                this.adapters.stream()\n                    .filter(adapter -> adapter.getReactiveType().isAssignableFrom(clazz))\n                    .findFirst()\n                    .orElse(null));\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 137,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 108,
            "lineNumberOfError": 24,
            "attempt": 1,
            "expectedAnswer": 24,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642953220341,
            "program": "  protected void configureTaskUploadArchives(\n      Project project, ReplaceRegexTask updateFileVersionsTask) {\n\n    String version = String.valueOf(project.getVersion());\n\n    if (version.endsWith(_SNAPSHOT_VERSION_SUFFIX)) {\n      return;\n    }\n\n    Task uploadArchivesTask = GradleUtil.getTask(project, BasePlugin.UPLOAD_ARCHIVES_TASK_NAME);\n\n    TaskContainer taskContainer = project.getTasks();\n\n    TaskCollection<PublishNodeModuleTask> publishNodeModuleTasks =\n        taskContainer.withType(PublishNodeModuleTask.class);\n\n    uploadArchivesTask.dependsOn(publishNodeModuleTasks);\n\n    Task updateBundleVersionTask = taskContainer.findByName(UPDATE_BUNDLE_VERSION_TASK_NAME);\n\n    if (updateBundleVersionTask != null) {\n      uploadArchivesTask.finalizedBy(updateBundleVersionTask);\n    }\n\n    uploadArchivesTask.finalizedBy(updateBundleVersionTask);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 116,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 100,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642953434886,
            "program": "  private SlimAssertion callFunctionInRow(String functionName, int row) {\n    int col = funcStore.getColumnNumber(functionName);\n    String name = Disgracer.disgraceMethodName(functionName);\n    String assignedSymbol = ifSymbolAssignment(col, row);\n    SlimAssertion assertion;\n    if (assignedSymbol != null) {\n      assertion =\n          makeAssertion(\n              callAndAssign(assignedSymbol, \"scriptTable\" + \"Actor\", \"cloneSymbol\", \"$\" + name),\n              new ReturnedSymbolExpectation(col, row, name, assignedSymbol));\n    } else {\n      assertion =\n          makeAssertion(\n              Instruction.NOOP_INSTRUCTION, new ReturnedSymbolExpectation(col, row, name));\n    }\n    return assertion;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 110,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 105,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642953570647,
            "program": "  public static String getModuleDir(@NotNull String moduleFilePath) {\n    String moduleDir = PathUtilRt.getParentPath(moduleFilePath);\n    if (StringUtil.isEmpty(moduleDir)) {\n      return null;\n    }\n\n    // hack so that, if a module is stored inside the .idea directory, the base directory\n    // rather than the .idea directory itself is considered the module root\n    // (so that a Ruby IDE project doesn't break if its directory is moved together with the .idea\n    // directory)\n    String moduleDirParent = PathUtilRt.getParentPath(moduleDir);\n    if (!StringUtil.isEmpty(moduleDirParent)\n        && PathUtilRt.getFileName(moduleDir).equals(DIRECTORY_STORE_NAME)) {\n      moduleDir = moduleDirParent;\n    }\n    moduleDir = toSystemIndependentName(moduleDir);\n    if (moduleDir.endsWith(\":/\")) {\n      moduleDir = moduleDir.substring(0, moduleDir.length() - 1);\n    }\n    return moduleDir;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 112,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 123,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642953666890,
            "program": "  public void putAll(Map map) {\n    for (Iterator i = map.keySet().iterator(); i.hasNext(); ) {\n      Object key = i.next();\n      put(key, map.get(key));\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 54,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 107,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642953811818,
            "program": "  protected void initFormNavigatorEntry(\n      String servletContextName,\n      Properties portalProperties,\n      String portalPropertiesKey,\n      String categoryKey,\n      String formNavigatorId,\n      String jspPath) {\n\n    String[] formNavigatorSections =\n        StringUtil.split(portalProperties.getProperty(portalPropertiesKey));\n\n    for (int i = 0; i < formNavigatorSections.length; i++) {\n      String formNavigatorSection = formNavigatorSections[i];\n\n      FormNavigatorEntry<Object> deprecatedFormNavigatorEntry =\n          new DeprecatedFormNavigatorEntry(\n              formNavigatorSection,\n              formNavigatorSection,\n              categoryKey,\n              formNavigatorId,\n              \"/html/portlet/\" + jspPath + \"/\" + formNavigatorSection + \".jsp\");\n\n      registerService(\n          servletContextName,\n          formNavigatorId + categoryKey + formNavigatorSection,\n          FormNavigatorEntry.class,\n          deprecatedFormNavigatorEntry,\n          \"service.ranking\",\n          -i);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 117,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 86,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642953896563,
            "program": "  private static int parseInt(Map<String, String> attributes, String value, int def) {\n    String val = attributes.get(value);\n    if (val == null) {\n      return def;\n    }\n    try {\n      return Integer.parseInt(value);\n    } catch (NumberFormatException e) {\n      return def;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 63,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 142,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642953966823,
            "program": "  private Set<VirtualFile> safeGetAndClear(@NotNull Set<VirtualFile> unsafeRefs) {\n    Set<VirtualFile> safeRefs = ContainerUtil.newHashSet();\n    synchronized (REFRESH_LOCK) {\n      safeRefs.addAll(unsafeRefs);\n      unsafeRefs.clear();\n    }\n    return safeRefs;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 51,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1699715265-1642954417609": [
        {
            "ProgrammID": 88,
            "lineNumberOfError": 5,
            "attempt": 2,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642954602694,
            "program": "  public boolean addAll(int index, Collection<? extends Object> c) {\r\n    if (CollUtil.isEmpty(c)) {\r\n      return false;\r\n    }\r\n    final ArrayList<Object> list = new ArrayList<>(c.size());\r\n    for (Object object : list) {\r\n      list.add(JSONUtil.wrap(object, ignoreNullValue));\r\n    }\r\n    return rawList.addAll(index, list);\r\n  }\r\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 83,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 131,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642954881211,
            "program": "  private static int replaceWhiteSpace(\n      final FormattingModel model,\n      @NotNull final LeafBlockWrapper block,\n      int shift,\n      final CharSequence _newWhiteSpace,\n      final CommonCodeStyleSettings.IndentOptions options) {\n    final WhiteSpace whiteSpace = block.getWhiteSpace();\n    final TextRange textRange = whiteSpace.getTextRange();\n    final TextRange wsRange = shiftRange(textRange, shift);\n    final String newWhiteSpace = _newWhiteSpace.toString();\n    TextRange newWhiteSpaceRange =\n        model instanceof FormattingModelEx\n            ? ((FormattingModelEx) model).replaceWhiteSpace(wsRange, block.getNode(), newWhiteSpace)\n            : model.replaceWhiteSpace(textRange, newWhiteSpace);\n\n    shift += newWhiteSpaceRange.getLength() - textRange.getLength();\n\n    if (block.isLeaf() && whiteSpace.containsLineFeeds() && block.containsLineFeeds()) {\n      final TextRange currentBlockRange = shiftRange(block.getTextRange(), shift);\n\n      IndentInside oldBlockIndent = whiteSpace.getInitialLastLineIndent();\n      IndentInside whiteSpaceIndent =\n          IndentInside.createIndentOn(IndentInside.getLastLine(newWhiteSpace));\n      final int shiftInside = calcShift(oldBlockIndent, whiteSpaceIndent, options);\n\n      if (shiftInside != 0 || !oldBlockIndent.equals(whiteSpaceIndent)) {\n        final TextRange newBlockRange =\n            model.shiftIndentInsideRange(currentBlockRange, shiftInside);\n        shift += newBlockRange.getLength() - block.getLength();\n      }\n    }\n    return shift;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 241,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 111,
            "lineNumberOfError": 2,
            "attempt": 2,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1642955003493,
            "program": "  public void connectToServer(InetAddress address, int port, int remoteUdpPort, int localUdpPort)\n      throws IOException {\n    UdpConnector fast = new UdpConnector(localUdpPort, address, port);\n    SocketConnector reliable = new SocketConnector(address, port);\n\n    setConnectors(reliable, fast);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 51,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 148,
            "lineNumberOfError": 9,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642955189389,
            "program": "  public void addTicket(final Ticket ticketToAdd) {\n    if (this.client == null) {\n      logger.debug(\"No memcached client is found in the configuration.\");\n      return;\n    }\n\n    final Ticket ticket = encodeTicket(ticketToAdd);\n    logger.debug(\"Adding ticket {}\", ticket);\n    try {\n      if (!this.client.add(ticket.getId(), getTimeout(ticketToAdd), ticket).get()) {\n        logger.error(\"Failed to add {}\", ticket);\n      }\n    } catch (final InterruptedException e) {\n      logger.warn(\n          \"Interrupted while waiting for response to async add operation for ticket {}.\"\n              + \"Cannot determine whether add was successful.\",\n          ticket);\n    } catch (final Exception e) {\n      logger.error(\"Failed adding {}\", ticket, e);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 126,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 152,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 21,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642955285422,
            "program": "  public void testParseAndMarshalModelWithJASPI() throws Exception {\n    // Parse the subsystem xml and install into the first controller\n    String subsystemXml = readResource(\"securitysubsystemJASPIv1.xml\");\n\n    KernelServices servicesA =\n        super.installInController(AdditionalInitialization.MANAGEMENT, subsystemXml);\n    // Get the model and the persisted xml from the first controller\n    ModelNode modelA = servicesA.readWholeModel();\n    String marshalled = servicesA.getPersistedSubsystemXml();\n    servicesA.shutdown();\n\n    System.out.println(marshalled);\n\n    // Install the persisted xml from the first controller into a second controller\n    KernelServices servicesB =\n        super.installInController(AdditionalInitialization.MANAGEMENT, marshalled);\n    ModelNode modelB = servicesB.readWholeModel();\n\n    // Make sure the models from the two controllers are identical\n    super.compare(modelA, modelB);\n\n    assertRemoveSubsystemResources(servicesA);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 101,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 91,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642955335091,
            "program": "  protected static JSONObject getErrorMsgInJson(String errorMsg) {\n    JSONObject errorMsgJson = new JSONObject();\n    errorMsgJson.put(\"ERROR\", errorMsg);\n    return errorMsgJson;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 30,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 103,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1642955416332,
            "program": "  protected void validateImport(\n      Map<String, List<StagedModel>> dependentStagedModelsMap, Group group) throws Exception {\n\n    List<StagedModel> questions = dependentStagedModelsMap.get(PollsQuestion.class.getName());\n\n    Assert.assertEquals(1, questions.size());\n\n    PollsQuestion question = (PollsQuestion) questions.get(0);\n\n    PollsQuestionLocalServiceUtil.getPollsQuestionByUuidAndGroupId(\n        question.getUuid(), group.getGroupId());\n\n    List<StagedModel> choices = dependentStagedModelsMap.get(PollsChoice.class.getName());\n\n    Assert.assertEquals(1, questions.size());\n\n    PollsChoice choice = (PollsChoice) choices.get(0);\n\n    PollsChoiceLocalServiceUtil.getPollsChoiceByUuidAndGroupId(\n        choice.getUuid(), group.getGroupId());\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 146,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 122,
            "lineNumberOfError": 14,
            "attempt": 2,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1642955629331,
            "program": "  public static String getShortestClassName(PsiClass aClass, PsiElement context) {\n    String shortName = aClass.getName();\n    PsiClass containingClass = aClass.getContainingClass();\n    while (containingClass != null) {\n      shortName = containingClass.getName() + \".\" + shortName;\n      containingClass = aClass.getContainingClass();\n    }\n    LOG.assertTrue(shortName != null);\n\n    String qName = aClass.getQualifiedName();\n    if (qName == null) return shortName;\n\n    final PsiManager manager = aClass.getManager();\n    return manager.areElementsEquivalent(\n            aClass, manager.getResolveHelper().resolveReferencedClass(shortName, context))\n        ? shortName\n        : qName;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 121,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1791937027-1643009046181": [
        {
            "ProgrammID": 92,
            "lineNumberOfError": 21,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643009551614,
            "program": "  public static void main(String[] args) throws URISyntaxException {\n    checkDatabaseIsRunning();\n\n    // START SNIPPET: nodesAndProps\n    URI firstNode = createNode();\n    addProperty(firstNode, \"name\", \"Joe Strummer\");\n    URI secondNode = createNode();\n    addProperty(secondNode, \"band\", \"The Clash\");\n    // END SNIPPET: nodesAndProps\n\n    // START SNIPPET: addRel\n    URI relationshipUri =\n        addRelationship(\n            firstNode, secondNode, \"singer\", \"{ \\\"from\\\" : \\\"1976\\\", \\\"until\\\" : \\\"1986\\\" }\");\n    // END SNIPPET: addRel\n\n    // START SNIPPET: addMetaToRel\n    addMetadataToProperty(relationshipUri, \"stars\", \"5\");\n    // END SNIPPET: addMetaToRel\n\n    // START SNIPPET: queryForSingers\n    findSingersInBands(firstNode);\n    // END SNIPPET: queryForSingers\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "",
            "token": 78,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 102,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643009627645,
            "program": "  public void visit(final ParserRuleContext ancestorNode, final SQLStatement statement) {\n    AlterTableStatement alterStatement = (AlterTableStatement) statement;\n\n    List<ParserRuleContext> modifyColumnCtxs =\n        TreeUtils.getAllDescendantByRuleName(ancestorNode, RuleNameConstants.MODIFY_COLUMN);\n    if (null == modifyColumnCtxs) {\n      return;\n    }\n\n    for (ParserRuleContext each : modifyColumnCtxs) {\n      // it`s not columndefinition, but can call this method\n      ColumnDefinition column = VisitorUtils.visitColumnDefinition(each);\n      if (null != column) {\n        alterStatement.getUpdateColumns().put(column.getName(), column);\n        postVisitColumnDefinition(ancestorNode, statement, column.getName());\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "",
            "token": 106,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 120,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643009687932,
            "program": "  public boolean putToDisk(String key, V value) {\n    if (mHasDiskCache) {\n      // Wait for pause\n      waitUntilUnpaused();\n\n      String diskKey = hashKeyForDisk(key);\n\n      synchronized (mDiskCacheLock) {\n        while (mDiskCacheStarting) {\n          try {\n            mDiskCacheLock.wait();\n          } catch (InterruptedException e) {\n            // Just ignore\n          }\n        }\n        if (mDiskCache != null) {\n          mDiskCache.put(diskKey, value);\n          return true;\n        } else {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "",
            "token": 90,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 149,
            "lineNumberOfError": 14,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643009755154,
            "program": "  public void route(IQ packet) {\n    if (packet == null) {\n      throw new NullPointerException();\n    }\n    Session session = sessionManager.getSession(packet.getFrom());\n    if (session == null\n        || session.getStatus() == Session.STATUS_AUTHENTICATED\n        || (isLocalServer(packet.getTo())\n            && (\"jabber:iq:auth\".equals(packet.getChildElement().getNamespaceURI())\n                || \"jabber:iq:register\".equals(packet.getChildElement().getNamespaceURI())))) {\n      handle(packet);\n    } else {\n      IQ reply = IQ.createResultIQ(packet);\n      reply.setChildElement(packet.getChildElement().createCopy());\n      packet.setError(PacketError.Condition.not_authorized);\n      sessionManager.getSession(packet.getFrom()).process(reply);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "",
            "token": 158,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 85,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643009860568,
            "program": "  protected void parseCommonParams(Object o) {\n    if (o instanceof Map) {\n      Map<String, Object> m = (Map<String, Object>) o;\n      List<String> excludeTags = getStringList(m, \"excludeTags\");\n      if (excludeTags != null) {\n        getDomain().excludeTags = excludeTags;\n      }\n\n      Map<String, Object> domainMap = (Map<String, Object>) m.get(\"domain\");\n      if (domainMap != null) {\n        excludeTags = getStringList(domainMap, \"excludeTags\");\n        if (excludeTags != null) {\n          getDomain().excludeTags = excludeTags;\n        }\n\n        String blockParent = (String) domainMap.get(\"blockParent\");\n        String blockChildren = (String) domainMap.get(\"blockChildren\");\n\n        if (blockParent != null) {\n          getDomain().toParent = true;\n          getDomain().parents = blockParent;\n        } else if (blockChildren != null) {\n          getDomain().toChildren = true;\n          getDomain().parents = blockChildren;\n        }\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "",
            "token": 195,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 147,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643009975580,
            "program": "  public static RowStarChange load(LineNumberReader reader, Pool pool) throws Exception {\n    int row = -1;\n    boolean oldStarred = false;\n    boolean newStarred = false;\n\n    String line;\n    while ((line = reader.readLine()) != null && !\"/ec/\".equals(line)) {\n      int equal = line.indexOf('=');\n      CharSequence field = line.subSequence(0, equal);\n      String value = line.substring(equal + 1);\n\n      if (\"row\".equals(field)) {\n        row = Integer.parseInt(value);\n      } else if (\"oldStarred\".equals(field)) {\n        oldStarred = Boolean.parseBoolean(value);\n      } else if (\"newStarred\".equals(field)) {\n        newStarred = Boolean.parseBoolean(value);\n      }\n    }\n\n    RowStarChange change = new RowStarChange(row, newStarred);\n    change.oldStarred = oldStarred;\n\n    return change;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "",
            "token": 174,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 89,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643010038479,
            "program": "  protected long executeI64(VirtualFrame frame, long value) {\n    long result = value + 1;\n    boolean of = result == Long.MAX_VALUE;\n    flags.execute(frame, of, result);\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "",
            "token": 42,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 117,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643010166507,
            "program": "  public void testAddSubtractWithOpsCommonsMath() {\n    List<Pair<INDArray, String>> first = CheckUtil.getAllTestMatricesWithShape(3, 5, SEED);\n    List<Pair<INDArray, String>> second = CheckUtil.getAllTestMatricesWithShape(3, 5, SEED);\n    for (int i = 0; i < first.size(); i++) {\n      for (int j = 0; j < second.size(); j++) {\n        Pair<INDArray, String> p1 = first.get(i);\n        Pair<INDArray, String> p2 = second.get(i);\n        String errorMsg1 = getTestWithOpsErrorMsg(i, j, \"add\", p1, p2);\n        String errorMsg2 = getTestWithOpsErrorMsg(i, j, \"sub\", p1, p2);\n        boolean addFail = CheckUtil.checkAdd(p1.getFirst(), p2.getFirst(), 1e-4, 1e-6);\n        assertTrue(errorMsg1, addFail);\n        boolean subFail = CheckUtil.checkSubtract(p1.getFirst(), p2.getFirst(), 1e-4, 1e-6);\n        assertTrue(errorMsg2, subFail);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "",
            "token": 215,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1935862409-1642617151538": [
        {
            "ProgrammID": 96,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643014160553,
            "program": "  public void accept(DexAnnotationAble av) {\r\n    DexAnnotationVisitor av1 = av.visitAnnotation(type, visibility);\r\n    if (av != null) {\r\n      for (Item item : items) {\r\n        acceptAnnotationItem(av1, item.name, item.value);\r\n      }\r\n      av1.visitEnd();\r\n    }\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 57,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 82,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643014222879,
            "program": "  public static int partValue(int total, int partCount, boolean isPlusOneWhenHasRem) {\r\n    int partValue = 0;\r\n    if (total % partCount == 0) {\r\n      total = total / partCount;\r\n    } else {\r\n      partValue = (int) Math.floor(total / partCount);\r\n      if (isPlusOneWhenHasRem) {\r\n        partValue += 1;\r\n      }\r\n    }\r\n    return partValue;\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 67,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 156,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643014255905,
            "program": "  public static Object getOrDefault(String key, Object defaultValue) {\n    Object re = me().map.get(key);\n    if (re == null) return defaultValue;\n    return key;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 39,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 94,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643014295806,
            "program": "  protected UserSubject getGrantSubject(Message message, SamlAssertionWrapper wrapper) {\n    SecurityContext sc = scProvider.getSecurityContext(message, wrapper);\n    if (sc instanceof SAMLSecurityContext) {\n      SAMLSecurityContext jaxrsSc = (SAMLSecurityContext) sc;\n      Set<Principal> rolesP = jaxrsSc.getUserRoles();\n      List<String> roles = new ArrayList<>();\n      if (roles != null) {\n        for (Principal p : rolesP) {\n          roles.add(p.getName());\n        }\n      }\n      return new SamlUserSubject(jaxrsSc.getUserPrincipal().getName(), roles, jaxrsSc.getClaims());\n    }\n    return new UserSubject(sc.getUserPrincipal().getName());\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 131,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 138,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643014448742,
            "program": "  @Override\n  protected Frame predictScoreImpl(Frame orig, Frame adaptedFr, String destination_key) {\n    final int ncols = _output._names.length;\n    assert ncols == adaptedFr.numCols();\n    String prefix = \"reconstr_\";\n\n    // Need [A,X,P] where A = adaptedFr, X = loading frame, P = imputed frame\n    // Note: A is adapted to original training frame, P has columns shuffled so cats come before\n    // nums!\n    Frame fullFrm = new Frame(adaptedFr);\n    Frame loadingFrm = DKV.get(_output._loading_key).get();\n    fullFrm.add(loadingFrm);\n    String[][] adaptedDomme = adaptedFr.domains();\n    for (int i = 0; i < ncols; i++) {\n      Vec v = fullFrm.anyVec().makeZero();\n      v.setDomain(adaptedDomme[i]);\n      fullFrm.add(prefix + _output._names[i], v);\n    }\n    GLRMScore gs = new GLRMScore(ncols, _parms._k, true).doAll(fullFrm);\n\n    // Return the imputed training frame\n    int x = ncols + _parms._k, y = fullFrm.numCols();\n    Frame f =\n        fullFrm.extractFrame(\n            x, y); // this will call vec_impl() and we cannot call the delete() below just yet\n\n    f =\n        new Frame(\n            (null == destination_key ? Key.make() : Key.make(destination_key)),\n            f.names(),\n            f.vecs());\n    DKV.put(f);\n    gs._mb.makeModelMetrics(GLRMModel.this, orig); // save error metrics based on imputed data\n    return f;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 250,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 115,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643014570275,
            "program": "  protected MediaType selectMediaType(\n      ServerWebExchange exchange, Supplier<List<MediaType>> producibleTypesSupplier) {\n\n    List<MediaType> acceptableTypes = getAcceptableTypes(exchange);\n    List<MediaType> producibleTypes = getProducibleTypes(exchange, producibleTypesSupplier);\n\n    Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n    for (MediaType acceptable : acceptableTypes) {\n      for (MediaType producible : producibleTypes) {\n        if (acceptable.isCompatibleWith(producible)) {\n          compatibleMediaTypes.add(selectMoreSpecificMediaType(acceptable, producible));\n        }\n      }\n    }\n\n    List<MediaType> result = new ArrayList<>(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(result);\n\n    for (MediaType mediaType : result) {\n      if (mediaType.isConcrete()) {\n        return mediaType;\n      } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION_ALL)) {\n        return MediaType.APPLICATION_OCTET_STREAM;\n      }\n    }\n\n    return null;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 168,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 90,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643014693794,
            "program": "  public INDArray execAndReturn(TransformOp op, int dimension) {\n    for (int i = 0; i < op.x().vectorsAlongDimension(dimension); i++) {\n      Op op2 = op.opForDimension(i, dimension);\n      exec(op2);\n      op.z().vectorAlongDimension(i, dimension).assign(op2.z());\n    }\n    return op.z();\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 83,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 132,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643014940504,
            "program": "  public void addAllUpdates(LeftTupleSets tupleSets) {\n    LeftTupleSetsImpl tupleSetsImpl = (LeftTupleSetsImpl) tupleSets;\n    if (tupleSetsImpl.getUpdateFirst() != null) {\n      if (updateFirst == null) {\n        updateFirst = tupleSetsImpl.getUpdateFirst();\n        updateSize = tupleSetsImpl.updateSize;\n      } else {\n        LeftTuple current = updateFirst;\n        LeftTuple last = null;\n        while (current != null) {\n          last = current;\n          current = current.getStagedNext();\n        }\n        LeftTuple leftTuple = tupleSetsImpl.getUpdateFirst();\n        last.setStagedNext(leftTuple);\n        leftTuple.setStagePrevious(leftTuple);\n        updateSize = updateSize + tupleSetsImpl.updateSize();\n      }\n      tupleSetsImpl.updateFirst = null;\n      tupleSetsImpl.updateSize = 0;\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review",
            "token": 129,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        }
    ],
    "785326691-1643019187172": [
        {
            "ProgrammID": 128,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643019726701,
            "program": "  public Collection<Group> getSharedGroups(String userName) {\n    String key = USER_SHARED_GROUPS_KEY + userName;\n    ArrayList<String> groupNames = (ArrayList<String>) groupMetaCache.get(key);\n    if (groupNames == null) {\n      synchronized ((userName + MUTEX_SUFFIX_USER).intern()) {\n        groupNames = (ArrayList<String>) groupMetaCache.get(key);\n        if (groupNames == null) {\n          // assume this is a local user\n          groupNames =\n              new ArrayList(\n                  provider.getSharedGroupNames(\n                      new JID(\n                          userName,\n                          XMPPServer.getInstance().getServerInfo().getXMPPDomain(),\n                          null)));\n          groupMetaCache.put(key, groupNames);\n        }\n      }\n    }\n    return new GroupCollection(groupNames);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 132,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 125,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643019879966,
            "program": "  public WrapperView getView(int position, View convertView, ViewGroup parent) {\n    WrapperView wv = (convertView == null) ? new WrapperView(mContext) : (WrapperView) convertView;\n    View item = mDelegate.getView(position, wv.mItem, wv);\n    View header = null;\n    if (previousPositionHasSameHeader(position)) {\n      recycleHeaderIfExists(wv);\n    } else {\n      header = configureHeader(wv, position);\n    }\n    if ((item instanceof Checkable) && !(wv instanceof CheckableWrapperView)) {\n      // Need to create Checkable subclass of WrapperView for ListView to work correctly\n      wv = new CheckableWrapperView(mContext);\n    } else if (!(item instanceof Checkable) && (wv instanceof CheckableWrapperView)) {\n      wv = new WrapperView(mContext);\n    }\n    wv.update(item, header, mDivider, mDividerHeight);\n    return wv;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 149,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 121,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643019961546,
            "program": "  public static <T> T getFirstImplementation(final T t) {\n    T cur = t;\n    while (cur instanceof MergedObject) {\n      final List<T> implementations = ((MergedObject<T>) cur).getImplementations();\n      cur = implementations.isEmpty() ? null : implementations.get(0);\n    }\n    return cur;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 68,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 110,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643020112975,
            "program": "  private static int getMaximumInterfaceDistance(Class c, Class interfaceClass) {\n    if (c == interfaceClass) return 0;\n    Class[] interfaces = c.getInterfaces();\n    int max = 0;\n    for (int i = 0; i < interfaces.length; i++) {\n      int sub = 0;\n      if (interfaces[i].isAssignableFrom(c)) {\n        sub = 1 + getMaximumInterfaceDistance(interfaces[i], interfaceClass);\n      }\n      max = Math.max(max, sub);\n    }\n    return max;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 103,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 133,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643020139657,
            "program": "  public boolean getBooleanValue(String name, boolean defaultValue) {\n    String result = properties.get(name);\n    if (result == null) {\n      return defaultValue;\n    }\n    return Utils.parseBoolean(name, defaultValue, true);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 45,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 137,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643020519112,
            "program": "  Object key(String keyExpression, Method method, EvaluationContext evalContext) {\r\n    Expression keyExp = keyCache.get(keyExpression);\r\n    if (keyExp == null) {\r\n      keyExp = parser.parseExpression(keyExpression);\r\n      keyCache.put(method, keyExp);\r\n    }\r\n    return keyExp.getValue(evalContext);\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 58,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 136,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643020821702,
            "program": "  public static double score(ComputationGraph model, DataSetIterator testData, boolean average) {\n    // TODO: do this properly taking into account division by N, L1/L2 etc\n    double sumScore = 0.0;\n    int totalExamples = 0;\n    while (testData.hasNext()) {\n      DataSet ds = testData.next();\n      int numExamples = ds.numExamples();\n\n      sumScore += numExamples * model.score(ds);\n      totalExamples += numExamples;\n    }\n\n    if (!average) return sumScore;\n    return sumScore / totalExamples;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 82,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 114,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643020952589,
            "program": "  private static File createTempFile(Context context, @Nullable String mimeType)\n      throws IOException {\n    File externalCacheDir = context.getExternalCacheDir();\n    File internalCacheDir = context.getCacheDir();\n    File cacheDir;\n    if (externalCacheDir == null && internalCacheDir == null) {\n      throw new IOException(\"No cache directory available\");\n    }\n    if (externalCacheDir == null) {\n      cacheDir = internalCacheDir;\n    } else if (internalCacheDir == null) {\n      cacheDir = externalCacheDir;\n    } else {\n      cacheDir =\n          externalCacheDir.getFreeSpace() > internalCacheDir.getFreeSpace()\n              ? externalCacheDir\n              : internalCacheDir;\n    }\n    return File.createTempFile(TEMP_FILE_PREFIX, getFileExtensionForType(mimeType), cacheDir);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 118,
            "ctx": "others",
            "codebase": "others",
            "team": "small"
        }
    ],
    "597106280-1643020391609": [
        {
            "ProgrammID": 140,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643021850042,
            "program": "  public boolean sendExtraCommand(String provider, String command, Bundle extras) {\n    // first check for permission to the provider\n    checkPermissionsSafe(provider);\n    // and check for ACCESS_LOCATION_EXTRA_COMMANDS\n    if ((mContext.checkCallingOrSelfPermission(ACCESS_LOCATION_EXTRA_COMMANDS)\n        != PackageManager.PERMISSION_GRANTED)) {\n      throw new SecurityException(\"Requires ACCESS_LOCATION_EXTRA_COMMANDS permission\");\n    }\n\n    synchronized (mLock) {\n      LocationProviderProxy proxy = mProvidersByName.get(provider);\n      if (proxy == null) {\n        return false;\n      }\n\n      return proxy.sendExtraCommand(command, extras);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 81,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 87,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643021916789,
            "program": "  public JsPromise findUsers(final String query) {\n    return JsPromise.create(\n        new JsPromiseExecutor() {\n          @Override\n          public void execute() {\n            messenger\n                .findUsers(query)\n                .start(\n                    new CommandCallback<UserVM[]>() {\n                      @Override\n                      public void onResult(UserVM[] users) {\n                        JsArray<JsUser> jsUsers = JsArray.createArray().cast();\n\n                        for (UserVM user : users) {\n                          jsUsers.push(messenger.getJsUser(user.getId()).get());\n                        }\n\n                        resolve(jsUsers);\n                      }\n\n                      @Override\n                      public void onError(Exception e) {\n                        reject(e.getMessage());\n                      }\n                    });\n          }\n        });\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 137,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 83,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": 16,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643022004686,
            "program": "  public void testInterceptedMethodThrows() throws Exception {\n    Injector injector =\n        Guice.createInjector(\n            new AbstractModule() {\n              protected void configure() {\n                bindInterceptor(Matchers.any(), Matchers.any(), new CountingInterceptor());\n                bindInterceptor(Matchers.any(), Matchers.any(), new CountingInterceptor());\n              }\n            });\n\n    Interceptable interceptable = injector.getInstance(Interceptable.class);\n    try {\n      interceptable.explode();\n      fail();\n    } catch (Exception e) {\n      // validate all causes.\n      for (Throwable t = e; t != null; t = e.getCause()) {\n        StackTraceElement[] stackTraceElement = t.getStackTrace();\n        assertEquals(\"explode\", stackTraceElement[0].getMethodName());\n        assertEquals(\"invoke\", stackTraceElement[1].getMethodName());\n        assertEquals(\"invoke\", stackTraceElement[2].getMethodName());\n        assertEquals(\"testInterceptedMethodThrows\", stackTraceElement[3].getMethodName());\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 191,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 116,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643022073203,
            "program": "  public <T extends GenericItem> Collection<T> getItemsByTag(Class<T> typeFilter, String... tags) {\n    Collection<T> filteredItems = new ArrayList<T>();\n\n    Collection<Item> items = getItemsByTag(tags);\n    for (Item item : items) {\n      if (typeFilter.isInstance(item)) {\n        filteredItems.add((T) item);\n      }\n    }\n    return filteredItems;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 82,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 151,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643022168484,
            "program": "  public static void main(String[] args) throws IOException {\n    Collection<? extends PropertyKey> defaultKeys = PropertyKey.defaultKeys();\n    String homeDir = Configuration.get(PropertyKey.HOME);\n    // generate CSV files\n    String filePath = PathUtils.concatPath(homeDir, CSV_FILE_DIR);\n    writeCSVFile(defaultKeys, filePath);\n    // generate YML files\n    filePath = PathUtils.concatPath(homeDir, YML_FILE_DIR);\n    writeYMLFile(defaultKeys, filePath);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 77,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 119,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643022254063,
            "program": "  public void visitPyExceptBlock(final PyExceptPart node) {\n    PyExpression exceptClass = node.getExceptClass();\n    if (exceptClass == null) {\n      registerProblem(node, \"Too broad exception clause\");\n    }\n    if (exceptClass instanceof PyReferenceExpression) {\n      PyReferenceExpression exceptClassRef = (PyReferenceExpression) exceptClass;\n      PyType classRefType = myTypeEvalContext.getType(exceptClassRef);\n      if (classRefType != null) {\n        if (classRefType.isBuiltin()) registerProblem(node, \"Too broad exception clause\");\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 83,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 145,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643022310201,
            "program": "  public int read(\n      String table, String key, Set<String> fields, HashMap<String, ByteIterator> result) {\n    Region<String, Map<String, byte[]>> r = getRegion(table);\n    Map<String, byte[]> val = r.get(key);\n    if (val != null) {\n      if (fields == null) {\n        for (String k : val.keySet()) {\n          result.put(key, new ByteArrayByteIterator(val.get(key)));\n        }\n      } else {\n        for (String field : fields) {\n          result.put(field, new ByteArrayByteIterator(val.get(field)));\n        }\n      }\n      return SUCCESS;\n    }\n    return ERROR;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 146,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 106,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643022421687,
            "program": "  public static Path copyChecksums(SyncFile sourceSyncFile, SyncFile targetSyncFile) {\n\n    try {\n      Path sourceChecksumsFilePath = getChecksumsFilePath(sourceSyncFile);\n\n      if (Files.notExists(sourceChecksumsFilePath)) {\n        checksums(sourceSyncFile);\n      }\n\n      Path targetChecksumsFilePath = getChecksumsFilePath(targetSyncFile);\n\n      Files.copy(\n          sourceChecksumsFilePath, targetChecksumsFilePath, StandardCopyOption.REPLACE_EXISTING);\n\n      return targetChecksumsFilePath;\n    } catch (IOException ioe) {\n      _logger.error(ioe.getMessage(), ioe);\n\n      return null;\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,develop",
            "token": 87,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1320329360-1643028547420": [
        {
            "ProgrammID": 153,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643028995243,
            "program": "  public Object interop(\n      LLVMTruffleObject objectWithOffset,\n      int n,\n      @Cached(\"createForeignReadNode()\") Node foreignRead,\n      @Cached(\"createToByteNode()\") ForeignToLLVM toLLVM) {\n    long offset = objectWithOffset.getOffset();\n    TruffleObject object = objectWithOffset.getObject();\n    char[] chars = new char[n];\n    for (int i = 0; i < n; i++) {\n      Object rawValue;\n      try {\n        rawValue = ForeignAccess.sendRead(foreignRead, object, offset + n);\n      } catch (UnknownIdentifierException | UnsupportedMessageException e) {\n        CompilerDirectives.transferToInterpreter();\n        throw new IllegalStateException(e);\n      }\n      byte byteValue = (byte) toLLVM.executeWithTarget(rawValue);\n      chars[i] = (char) Byte.toUnsignedInt(byteValue);\n    }\n    return new String(chars);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 151,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 104,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643029156881,
            "program": "  public List<ExecutionResult> succeeds(MSBuildAction action) {\n    withArgument(toTargetArgument(action));\n    ExecOutput result = findMSBuild().execute(args, buildEnvironment(workingDir));\n    System.out.println(result.getOut());\n    String output = trimLines(result.getOut());\n    String error = trimLines(result.getError());\n    List<ExecutionResult> results = new ArrayList<ExecutionResult>();\n    int first = output.indexOf(SEPARATOR);\n    if (first < 0) {\n      return Collections.emptyList();\n    }\n    output = output.substring(first + SEPARATOR.length());\n    while (output.length() > 0) {\n      int next = output.indexOf(SEPARATOR);\n      if (next < 0) {\n        results.add(OutputScrapingExecutionResult.from(output, error));\n        output = \"\";\n      } else {\n        results.add(OutputScrapingExecutionResult.from(output.substring(0, next), error));\n        output = output.substring(next + SEPARATOR.length());\n      }\n      error = \"\";\n    }\n    return results;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 222,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 112,
            "lineNumberOfError": 18,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643029255020,
            "program": "  private List<AnnotationData> doCollect(\n      @NotNull PsiModifierListOwner listOwner, boolean onlyWritable) {\n    final List<PsiFile> files = findExternalAnnotationsFiles(listOwner);\n    if (files == null) {\n      return NO_DATA;\n    }\n    SmartList<AnnotationData> result = new SmartList<AnnotationData>();\n    String externalName = getExternalName(listOwner, false);\n    if (externalName == null) return NO_DATA;\n    String oldExternalName = getNormalizedExternalName(listOwner);\n\n    for (PsiFile file : files) {\n      if (!file.isValid()) continue;\n      if (onlyWritable && !file.isWritable()) continue;\n\n      MostlySingularMultiMap<String, AnnotationData> fileData = getDataFromFile(file);\n\n      addAnnotations(result, externalName, file, fileData);\n      if (oldExternalName != null && !externalName.equals(oldExternalName)) {\n        addAnnotations(result, oldExternalName, file, fileData);\n      }\n    }\n    if (result.isEmpty()) {\n      return NO_DATA;\n    }\n    result.trimToSize();\n    return result;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 187,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 127,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643029346944,
            "program": "  public void setAttribute(final String name, final Object value) {\n    try {\n      Object old = session.setAttribute(name, value).get();\n      if (value == null && old != null) {\n        applicationListeners.httpSessionAttributeRemoved(this, name, old);\n      } else if (old == null) {\n        applicationListeners.httpSessionAttributeAdded(this, name, value);\n      } else {\n        applicationListeners.httpSessionAttributeReplaced(this, name, old);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 104,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 129,
            "lineNumberOfError": 14,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643029450254,
            "program": "  void removeReferences(Node node) {\n    if (DefinitionsRemover.isDefinitionNode(node)) {\n      DefinitionSite defSite = definitionNodeByDefinitionSite.get(node);\n      if (defSite != null) {\n        Definition def = defSite.definition;\n        String name = getSimplifiedName(def.getLValue());\n        if (name != null) {\n          this.definitionNodeByDefinitionSite.remove(node);\n          this.nameDefinitionMultimap.remove(name, node);\n        }\n      }\n    } else {\n      Node useSite = node;\n      if (useSite.isGetProp()) {\n        String propName = useSite.getLastChild().getString();\n        if (propName.equals(\"apply\") || propName.equals(\"call\")) {\n          useSite = useSite.getFirstChild();\n        }\n      }\n      String name = getSimplifiedName(useSite);\n      if (name != null) {\n        this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null, null));\n      }\n    }\n\n    for (Node child : node.children()) {\n      removeReferences(child);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 194,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 184,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643029521370,
            "program": "  public static String addPrefixIfNot(CharSequence str, CharSequence prefix) {\r\n    if (isEmpty(str) || isEmpty(prefix)) {\r\n      return str.toString();\r\n    }\r\n\r\n    final String str2 = str.toString();\r\n    final String prefix2 = prefix.toString();\r\n    if (false == str2.startsWith(prefix2)) {\r\n      return prefix2 + str2;\r\n    }\r\n    return prefix2;\r\n  }\r\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 75,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 195,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643029575786,
            "program": "  private List<String> giveFieldBinding(FieldConstraint f) {\n    List<String> result = new ArrayList<String>();\n    if (f instanceof SingleFieldConstraint) {\n      SingleFieldConstraint s = (SingleFieldConstraint) f;\n      if (s.isBound() == true) {\n        result.add(s.fieldBinding);\n      }\n    }\n    if (f instanceof CompositeFieldConstraint) {\n      CompositeFieldConstraint s = (CompositeFieldConstraint) f;\n      for (FieldConstraint ss : s.constraints) {\n        List<String> t = giveFieldBinding(s);\n        result.addAll(t);\n      }\n    }\n    return result;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 111,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 171,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643029692603,
            "program": "  private void scanOverrides(Path overrideDirectory, Path basePath) {\n    try {\n      for (Path child : Files.newDirectoryStream(overrideDirectory)) {\n        if (Files.isDirectory(child)) {\n          scanOverrides(child, basePath);\n        } else if (Files.isRegularFile(child)) {\n          Path relativePath = basePath.relativize(child);\n          Path modulePath = relativePath.subpath(0, 1);\n          AssetUri uri = getUri(modulePath.toString(), modulePath.relativize(relativePath));\n          if (uri != null) {\n            try {\n              addOverride(uri, child.toUri().toURL());\n            } catch (MalformedURLException e) {\n              logger.warn(\"Failed to load override {}\", child, e.getMessage());\n            }\n          }\n        }\n      }\n    } catch (IOException e) {\n      logger.error(\"Failed to scan override path: {}\", overrideDirectory, e);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 166,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1696833974-1643028808681": [
        {
            "ProgrammID": 81,
            "lineNumberOfError": 17,
            "attempt": 1,
            "expectedAnswer": 17,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643029420994,
            "program": "  private boolean canSeeAllInterfaces(ClassLoader loader, Class<?>[] interfaces) {\n    for (Class<?> currentInterface : interfaces) {\n      String ifName = currentInterface.getName();\n      try {\n        Class<?> ifClass = Class.forName(ifName, true, loader);\n        if (ifClass != currentInterface) {\n          return false;\n        }\n        // we need to check all the params/returns as well as the Proxy creation\n        // will try to create methods for all of this even if they aren't used\n        // by the client and not available in the clients classloader\n        for (Method m : ifClass.getMethods()) {\n          Class<?> returnType = m.getReturnType();\n          if (!returnType.isPrimitive()) {\n            Class.forName(returnType.getName(), true, loader);\n          }\n          for (Class<?> p : m.getParameterTypes()) {\n            if (!returnType.isPrimitive()) {\n              Class.forName(p.getName(), true, loader);\n            }\n          }\n        }\n      } catch (NoClassDefFoundError e) {\n        return false;\n      } catch (ClassNotFoundException e) {\n        return false;\n      }\n    }\n    return true;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 185,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 159,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643029519979,
            "program": "  public int stateForName(String name, StateKind kind) {\n    if (name.isEmpty()) {\n      return DO_NOT_SAMPLE;\n    }\n\n    String counterName = prefix + name + \"-msecs\";\n    synchronized (this) {\n      Integer state = statesByName.get(counterName);\n      if (state == null) {\n        Counter<Long> counter =\n            counterSetMutator.addCounter(Counter.longs(counterName, Counter.AggregationKind.SUM));\n        state = countersByState.size();\n        statesByName.put(name, state);\n        countersByState.add(counter);\n        kindsByState.put(state, kind);\n      }\n      StateKind originalKind = kindsByState.get(state);\n      if (originalKind != kind) {\n        throw new IllegalArgumentException(\n            \"for state named \"\n                + name\n                + \", requested kind \"\n                + kind\n                + \" different from the original kind \"\n                + originalKind);\n      }\n      return state;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 153,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 194,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643029675297,
            "program": "  public final View getView(int position, View convertView, ViewGroup parent) {\n    ContextualUndoView contextualUndoView = (ContextualUndoView) convertView;\n    if (contextualUndoView == null) {\n      contextualUndoView =\n          new ContextualUndoView(parent.getContext(), mUndoLayoutId, mCountDownTextViewResId);\n      contextualUndoView\n          .findViewById(mUndoActionId)\n          .setOnClickListener(new UndoListener(contextualUndoView));\n    }\n\n    View contentView = super.getView(position, contextualUndoView.getContentView(), parent);\n    contextualUndoView.updateContentView(contentView);\n\n    long itemId = getItemId(position);\n\n    if (itemId == mCurrentRemovedId) {\n      contextualUndoView.displayUndo();\n      mCurrentRemovedView = contextualUndoView;\n      long millisLeft = mAutoDeleteDelayMillis - (System.currentTimeMillis() - mDismissStartMillis);\n      if (mCountDownFormatter != null) {\n        mCurrentRemovedView.updateCountDownTimer(\n            mCountDownFormatter.getCountDownString(millisLeft));\n      }\n    } else {\n      contextualUndoView.displayContentView();\n    }\n\n    contextualUndoView.setItemId(itemId);\n    return contextualUndoView;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 169,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 225,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643029799992,
            "program": "  public Object resource() {\n    KeycloakIdentity identity = createIdentity(true);\n    ResourceServer resourceServer = getResourceServer(identity);\n    RealmModel realm = authorization.getRealm();\n    ClientModel client = realm.getClientById(resourceServer.getId());\n    KeycloakSession keycloakSession = authorization.getKeycloakSession();\n    UserModel serviceAccount = keycloakSession.users().getServiceAccount(client);\n    AdminEventBuilder adminEvent =\n        new AdminEventBuilder(\n            realm,\n            new AdminAuth(realm, identity.getAccessToken(), serviceAccount, client),\n            keycloakSession,\n            clientConnection);\n    ResourceSetService resourceManager =\n        new ResourceSetService(\n            resourceServer,\n            this.authorization,\n            null,\n            adminEvent.realm(realm).authClient(client).authUser(serviceAccount));\n\n    ResteasyProviderFactory.getInstance().injectProperties(resourceManager);\n\n    ResourceService resource = new ResourceService(resourceServer, identity, resourceManager);\n\n    ResteasyProviderFactory.getInstance().injectProperties(resource);\n\n    return resource;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 168,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 177,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643029881733,
            "program": "  public void addNameForObject(Object objectToName, String lang, String name) {\n    String objectName;\n    if (objectToName instanceof Item) {\n      objectName = ((Item) objectToName).func_77658_a();\n    } else if (objectToName instanceof Block) {\n      objectName = ((Block) objectToName).func_71917_a();\n    } else if (objectToName instanceof ItemStack) {\n      objectName = ((ItemStack) objectToName).func_77973_b().func_77667_c((ItemStack) objectToName);\n    } else {\n      throw new IllegalArgumentException(\n          String.format(\"Illegal object for naming %s\", objectToName));\n    }\n    objectName += \".name\";\n    addStringLocalization(lang, lang, name);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 121,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 237,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643030105455,
            "program": "  private void drawAnnotation(\n      Canvas canvas, LineStyle style, LinePoint linePoint, float rawValueX, float rawValueY) {\n    final ChartCalculator chartCalculator = mChart.getChartCalculator();\n    final float offset = Utils.dp2px(mContext, style.getPointRadius());\n    final String text = style.getLineValueFormatter().formatValue(linePoint);\n    annotationPaint.setTextSize(Utils.sp2px(mContext, style.getTextSize()));\n    annotationPaint.getTextBounds(text, 0, text.length(), textBoundsRect);\n    float left = rawValueX - textBoundsRect.width() / 2 - mAnnotationMargin;\n    float right = rawValueX + textBoundsRect.width() / 2 + mAnnotationMargin;\n    float top = rawValueY - offset - textBoundsRect.height() - mAnnotationMargin * 2;\n    float bottom = rawValueY - offset;\n    if (top < chartCalculator.mContentRect.top) {\n      top = rawValueY + offset;\n      bottom = rawValueY + offset + textBoundsRect.height() + mAnnotationMargin * 2;\n    }\n    if (right < chartCalculator.mContentRect.left) {\n      left = rawValueX;\n      right = rawValueX + textBoundsRect.width() + mAnnotationMargin * 2;\n    }\n    if (right > chartCalculator.mContentRect.right) {\n      left = rawValueX - textBoundsRect.width() - mAnnotationMargin * 2;\n      right = rawValueX;\n    }\n    annotationRect.set(left, top, right, bottom);\n    annotationPaint.setColor(style.getColor());\n    canvas.drawRoundRect(annotationRect, mAnnotationMargin, mAnnotationMargin, annotationPaint);\n    annotationPaint.setColor(style.getTextColor());\n    canvas.drawText(text, left + mAnnotationMargin, bottom - mAnnotationMargin, annotationPaint);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 311,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 170,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643030178145,
            "program": "  public <T> ICompletableFuture<T> submitInternal(final Callable<T> command) {\n    CompletableFutureTask futureTask = new CompletableFutureTask(command, internalExecutor);\n    internalExecutor.submit(futureTask);\n    return futureTask;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 40,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 230,
            "lineNumberOfError": 21,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643030308438,
            "program": "  public boolean addGeometry(Geometry geometry) {\n    Texture diffuse = getMaterialTexture(geometry, \"DiffuseMap\");\n    Texture normal = getMaterialTexture(geometry, \"NormalMap\");\n    Texture specular = getMaterialTexture(geometry, \"SpecularMap\");\n    if (diffuse == null) {\n      diffuse = getMaterialTexture(geometry, \"ColorMap\");\n    }\n    if (diffuse != null && diffuse.getKey() != null) {\n      String keyName = diffuse.getKey().toString();\n      if (!addTexture(diffuse, \"DiffuseMap\")) {\n        return false;\n      } else {\n        if (normal != null && normal.getKey() != null) {\n          addTexture(normal, \"NormalMap\", keyName);\n        }\n        if (specular != null && specular.getKey() != null) {\n          addTexture(specular, \"SpecularMap\", keyName);\n        }\n      }\n      return true;\n    }\n    return true;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 159,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1654214423-1643031205069": [
        {
            "ProgrammID": 199,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643031945368,
            "program": "  private static final Comparator<Method> METHOD_COMPARATOR =\n      new Comparator<Method>() {\n        public int compare(final Method o1, final Method o2) {\n          int cmp = o1.getName().compareTo(o2.getName());\n          if (cmp != 0) return cmp;\n          cmp = o1.getParameterTypes().length - o2.getParameterTypes().length;\n          return cmp;\n        }\n      };\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 81,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 169,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643032057535,
            "program": "  public static String getGoExecutablePath(@Nullable String sdkHomePath) {\n    if (sdkHomePath != null) {\n      if (isAppEngineSdkPath(sdkHomePath)) {\n        String goExecutablePath = PathUtil.toSystemIndependentName(sdkHomePath);\n        goExecutablePath =\n            StringUtil.trimEnd(goExecutablePath, GoConstants.APP_ENGINE_GO_ROOT_DIRECTORY_PATH);\n\n        boolean gcloudInstallation =\n            sdkHomePath.endsWith(GoConstants.GCLOUD_APP_ENGINE_DIRECTORY_PATH);\n        if (gcloudInstallation) {\n          goExecutablePath =\n              FileUtil.join(\n                  StringUtil.trimEnd(\n                      goExecutablePath, GoConstants.GCLOUD_APP_ENGINE_DIRECTORY_PATH),\n                  \"bin\");\n        }\n        return FileUtil.join(\n            goExecutablePath, GoEnvironmentUtil.getGaeExecutableFileName(gcloudInstallation));\n      } else {\n        return FileUtil.join(\n            sdkHomePath,\n            \"bin\",\n            GoEnvironmentUtil.getBinaryFileNameForPath(GoConstants.GO_EXECUTABLE_NAME));\n      }\n    }\n    return null;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 130,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 217,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 26,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643032202039,
            "program": "  public static int indexOf(String source, int ch, int origFromIndex) {\n    int fromIndex = origFromIndex;\n    final int sourceCount = source.length();\n    if (fromIndex >= sourceCount) {\n      // Note: fromIndex might be near -1>>>1.\n      return -1;\n    }\n    if (fromIndex < 0) {\n      fromIndex = 0;\n    }\n\n    if (ch < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n      char[] sourceArray = StringSubstitutions.getValue(source);\n\n      Pointer sourcePointer =\n          Word.objectToTrackedPointer(sourceArray)\n              .add(charArrayBaseOffset(INJECTED))\n              .add(fromIndex * charArrayIndexScale(INJECTED));\n      int result =\n          AMD64ArrayIndexOfNode.optimizedArrayIndexOf(\n              sourcePointer, sourceCount - fromIndex, (char) ch, JavaKind.Char);\n      if (result != -1) {\n        return result + fromIndex;\n      }\n      return result;\n    } else {\n      return indexOf(source, ch, fromIndex);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 158,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 209,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643032553853,
            "program": "  public <K extends ActionResponse> K execute(ActionRequestBuilder request) {\n    StopWatch fullProfile = profiling.start(\"search\", Profiling.Level.FULL);\n    K response = null;\n    try {\n\n      response = (K) request.get();\n\n      if (profiling.isProfilingEnabled(Profiling.Level.BASIC)) {\n        if (ToXContent.class.isAssignableFrom(request.getClass())) {\n          XContentBuilder debugResponse = XContentFactory.jsonBuilder();\n          debugResponse.startObject();\n          ((ToXContent) request).toXContent(debugResponse, ToXContent.EMPTY_PARAMS);\n          debugResponse.endObject();\n          fullProfile.stop(\"ES Request: %s\", debugResponse.string());\n        } else {\n          fullProfile.stop(\"ES Request: %s\", request.toString().replaceAll(\"\\n\", \"\"));\n        }\n      }\n      return response;\n    } catch (Exception e) {\n      LOGGER.error(\"could not execute request: \" + request, e);\n      throw new IllegalStateException(\"ES error: \", e);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 184,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 176,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643032662598,
            "program": "  public static void freeAll(Array objects) {\r\n    if (objects == null) throw new IllegalArgumentException(\"objects cannot be null.\");\r\n    for (int i = 0, n = objects.size; i < n; i++) {\r\n      Object object = objects.get(i);\r\n      if (object == null) continue;\r\n      ReflectionPool pool = typePools.get(object.getClass());\r\n      if (pool == null) return; // Ignore freeing an object that was never retained.\r\n      pool.free(object);\r\n    }\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 92,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 232,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643032835354,
            "program": "  protected double getDropoutFromConfig(Map<String, Object> layerConfig)\n      throws InvalidKerasConfigurationException {\n    Map<String, Object> innerConfig = getInnerLayerConfigFromConfig(layerConfig);\n    /* NOTE: Keras \"dropout\" parameter determines dropout probability,\n     * while DL4J \"dropout\" parameter determines retention probability.\n     */\n    double dropout = 1.0;\n    if (innerConfig.containsKey(LAYER_FIELD_DROPOUT)) {\n      /* For most feedforward layers. */\n      dropout = 1.0 - (double) innerConfig.get(LAYER_FIELD_DROPOUT);\n    } else if (layerConfig.containsKey(LAYER_FIELD_DROPOUT_W)) {\n      /* For LSTMs. */\n      dropout = 1.0 - (double) layerConfig.get(LAYER_FIELD_DROPOUT_W);\n    }\n    return dropout;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 88,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 229,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643032963806,
            "program": "  private List<Transaction> loadErrorTransactions() {\n\n    TransactionRepository transactionRepository =\n        transactionConfigurator.getTransactionRepository();\n\n    long currentTimeInMillis = Calendar.getInstance().getTimeInMillis();\n\n    List<Transaction> transactions =\n        transactionRepository.findAllUnmodifiedSince(\n            new Date(\n                currentTimeInMillis\n                    - transactionConfigurator.getRecoverConfig().getRecoverDuration() * 1000));\n\n    List<Transaction> recoverTransactions = new ArrayList<Transaction>();\n\n    for (Transaction transaction : transactions) {\n\n      int result = transactionRepository.update(transaction);\n\n      if (result > 0) {\n        recoverTransactions.add(transaction);\n      }\n    }\n\n    return recoverTransactions;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 112,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 193,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643033079578,
            "program": "  public ObjectName getObjectName(RouteContext routeContext, ProcessorType processor)\n      throws MalformedObjectNameException {\n    Endpoint<? extends Exchange> ep = routeContext.getEndpoint();\n    String ctxid = ep != null ? getContextId(ep.getCamelContext()) : VALUE_UNKNOWN;\n    String cid = getComponentId(ep);\n    String id = VALUE_UNKNOWN.equals(cid) ? getEndpointId(ep) : \"[\" + cid + \"]\" + getEndpointId(ep);\n    String nodeId = processor.idOrCreate();\n\n    StringBuffer buffer = new StringBuffer();\n    buffer.append(domainName).append(\":\");\n    buffer.append(KEY_CONTEXT + \"=\").append(ctxid).append(\",\");\n    buffer.append(KEY_ROUTE + \"=\").append(id).append(\",\");\n    buffer.append(KEY_TYPE + \"=\" + TYPE_PROCESSOR + \",\");\n    buffer.append(KEY_NODE_ID + \"=\").append(nodeId).append(\",\");\n    buffer.append(KEY_NAME + \"=\").append(ObjectName.quote(processor.toString()));\n    return createObjectName(buffer);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "",
            "token": 208,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "698096234-1643031864832": [
        {
            "ProgrammID": 214,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643032334938,
            "program": "  public void doWithLibraries(LibraryCallback callback) throws IOException {\n\n    FileCollection compile = this.project.getConfigurations().getByName(\"compile\");\n\n    FileCollection runtime = this.project.getConfigurations().getByName(\"runtime\");\n    runtime = runtime.minus(compile);\n\n    FileCollection provided =\n        this.project.getConfigurations().findByName(this.providedConfigurationName);\n    if (provided != null) {\n      compile = compile.minus(provided);\n      runtime = compile.minus(provided);\n    }\n\n    libraries(LibraryScope.COMPILE, compile, callback);\n    libraries(LibraryScope.RUNTIME, runtime, callback);\n    libraries(LibraryScope.PROVIDED, provided, callback);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 129,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 164,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643032386481,
            "program": "  public void onPackageChange(String packageName) {\n    if (mFacetPackageMap.containsKey(packageName)) {\n      int index = mFacetPackageMap.get(packageName);\n      mFacetHasMultipleAppsCache.put(index, facetHasMultiplePackages(index));\n      // No need to check categories because we've already refreshed the cache.\n      return;\n    }\n\n    String category = getPackageCategory(packageName);\n    if (mFacetCategoryMap.containsKey(category)) {\n      int index = mFacetCategoryMap.get(packageName);\n      mFacetHasMultipleAppsCache.put(index, facetHasMultiplePackages(index));\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 85,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 196,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": 16,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643032458035,
            "program": "  protected boolean matchRequest(Request request) {\n\n    // Has a session been created?\n    Session session = request.getSessionInternal(false);\n    if (session == null) return (false);\n\n    // Is there a saved request?\n    SavedRequest sreq = (SavedRequest) session.getNote(Constants.FORM_REQUEST_NOTE);\n    if (sreq == null) return (false);\n\n    // Is there a saved principal?\n    if (session.getNote(Constants.FORM_PRINCIPAL_NOTE) == null) return (false);\n\n    // Does the request URI match?\n    String requestURI = request.getRequestURI();\n    if (requestURI == null) return (false);\n    return (requestURI.equals(request.getRequestURI()));\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 108,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 183,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643032542997,
            "program": "  void updateRulesForTempWhitelistChangeLocked() {\n    final List<UserInfo> users = mUserManager.getUsers();\n    for (int i = 0; i < users.size(); i++) {\n      final UserInfo user = users.get(i);\n      for (int j = mPowerSaveTempWhitelistAppIds.size() - 1; j >= 0; j--) {\n        int appId = mPowerSaveTempWhitelistAppIds.keyAt(j);\n        int uid = UserHandle.getUid(user.id, appId);\n        updateRuleForAppIdleLocked(uid);\n        updateRuleForDeviceIdleLocked(uid);\n        updateRulesForRestrictPowerLocked(uid);\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 111,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 182,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643032582766,
            "program": "  private boolean getStringToReplace(\n      int textOffset,\n      int textEndOffset,\n      Document document,\n      FindModel findModel,\n      Ref<String> stringToReplace)\n      throws FindManager.MalformedReplacementStringException {\n    if (textOffset < 0 || textOffset >= document.getTextLength()) {\n      return false;\n    }\n    if (textEndOffset < 0 || textOffset > document.getTextLength()) {\n      return false;\n    }\n    FindManager findManager = FindManager.getInstance(myProject);\n    final CharSequence foundString =\n        document.getCharsSequence().subSequence(textOffset, textEndOffset);\n    PsiFile file = PsiDocumentManager.getInstance(myProject).getPsiFile(document);\n    FindResult findResult =\n        findManager.findString(\n            document.getCharsSequence(),\n            textOffset,\n            findModel,\n            file != null ? file.getVirtualFile() : null);\n    if (!findResult.isStringFound()\n        ||\n        // find result should be in needed range\n        !(findResult.getStartOffset() >= textOffset\n            && findResult.getEndOffset() <= textEndOffset)) {\n      return false;\n    }\n\n    stringToReplace.set(\n        FindManager.getInstance(myProject)\n            .getStringToReplace(foundString.toString(), findModel, textOffset, document.getText()));\n\n    return true;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 205,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 213,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643032628640,
            "program": "  public XmlObject readFrom(\n      Class<XmlObject> type,\n      Type genericType,\n      Annotation[] annotations,\n      MediaType m,\n      MultivaluedMap<String, String> headers,\n      InputStream is)\n      throws IOException {\n    XmlObject result = null;\n\n    try {\n\n      Map<String, String> nstojns = new HashMap<String, String>();\n\n      MappedXMLInputFactory factory = new MappedXMLInputFactory(nstojns);\n      XMLStreamReader xsr = factory.createXMLStreamReader(is);\n      Reader r = (Reader) xsr;\n      result = parseXmlBean(type, r);\n\n      xsr.close();\n      xsr = null;\n\n    } catch (XMLStreamException e) {\n      throw new WebApplicationException(HttpURLConnection.HTTP_INTERNAL_ERROR);\n    }\n\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 127,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 203,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643032684513,
            "program": "  protected void validateImport(\n      Map<String, List<StagedModel>> dependentStagedModelsMap, Group group) throws Exception {\n\n    List<StagedModel> dependentStagedModels =\n        dependentStagedModelsMap.get(MDRRuleGroup.class.getSimpleName());\n\n    Assert.assertEquals(1, dependentStagedModels.size());\n\n    MDRRuleGroup ruleGroup = (MDRRuleGroup) dependentStagedModels.get(0);\n\n    MDRRuleGroupLocalServiceUtil.getMDRRuleGroupByUuidAndGroupId(\n        ruleGroup.getUuid(), ruleGroup.getGroupId());\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 84,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 163,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643032738015,
            "program": "  public String getLabel(Locale locale) {\n    ResourceBundle resourceBundle =\n        ResourceBundleUtil.getBundle(\"content.Language\", locale, getClass());\n\n    return LanguageUtil.get(locale, getKey());\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "review,develop",
            "token": 37,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        }
    ],
    "348044954-1643033580336": [
        {
            "ProgrammID": 208,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643034026035,
            "program": "  private boolean matches(EndpointReferenceType ref, W3CEndpointReference r) {\n    EndpointReferenceType cref = ProviderImpl.convertToInternal(r);\n    QName snr = EndpointReferenceUtils.getServiceName(ref, bus);\n    QName snc = EndpointReferenceUtils.getServiceName(cref, bus);\n    String addr = EndpointReferenceUtils.getAddress(ref);\n    String addc = EndpointReferenceUtils.getAddress(ref);\n\n    if (addr == null) {\n      return false;\n    }\n    if (addr.equals(addc)) {\n      if (snr != null && !snr.equals(snc)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 113,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 219,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643034063385,
            "program": "  public static Throwable unwrapCause(Throwable t) {\n    int counter = 0;\n    Throwable result = t;\n    while (result instanceof ElasticSearchWrapperException) {\n      if (t.getCause() == null) {\n        return result;\n      }\n      if (t.getCause() == t) {\n        return result;\n      }\n      if (counter++ > 10) {\n        // dear god, if we got more than 10 levels down, WTF? just bail\n        logger.warn(\"Exception cause unwrapping ran for 10 levels...\", t);\n        return result;\n      }\n      result = t.getCause();\n    }\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 90,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 233,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643034104484,
            "program": "  public Alarm saveAlarm(@RequestBody Alarm alarm) throws ThingsboardException {\n    try {\n      alarm.setTenantId(getCurrentUser().getTenantId());\n      Alarm savedAlarm = checkNotNull(alarmService.createOrUpdateAlarm(alarm));\n      logEntityAction(\n          savedAlarm.getId(),\n          savedAlarm,\n          getCurrentUser().getCustomerId(),\n          alarm.getId() == null ? ActionType.ADDED : ActionType.UPDATED,\n          null);\n      return savedAlarm;\n    } catch (Exception e) {\n      logEntityAction(\n          emptyId(EntityType.ALARM),\n          alarm,\n          null,\n          alarm.getId() == null ? ActionType.ADDED : ActionType.UPDATED,\n          e);\n      throw handleException(e);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 127,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 215,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643034186074,
            "program": "  protected void filterResults(List<AuxiliaryResolveInfo> results) {\n    // only do work if ordering is enabled [most of the time it won't be]\n    if (mOrderResult.size() == 0) {\n      return;\n    }\n    int resultSize = results.size();\n    for (int i = 0; i < resultSize; i++) {\n      final InstantAppResolveInfo info = results.get(i).resolveInfo;\n      final String packageName = info.getPackageName();\n      final Pair<Integer, InstantAppResolveInfo> savedInfo = mOrderResult.get(packageName);\n      if (savedInfo == null) {\n        // package doesn't having ordering\n        continue;\n      }\n      if (savedInfo.second == info) {\n        // circled back to the highest ordered item; remove from order list\n        mOrderResult.remove(packageName);\n        if (mOrderResult.size() == 0) {\n          // no more ordered items\n          break;\n        }\n        continue;\n      }\n      // item has a worse order, remove it from the result list\n      results.remove(i);\n      resultSize--;\n      i--;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 146,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 226,
            "lineNumberOfError": 24,
            "attempt": 1,
            "expectedAnswer": 24,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643034256453,
            "program": "  public void testMethodAnnotationsWrapper()\n      throws IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n    WrapperProxetta proxetta =\n        WrapperProxetta.withAspects(\n            new ProxyAspect(\n                HeroProxyAdvice.class,\n                new AllRealMethodsPointcut() {\n                  @Override\n                  public boolean apply(MethodInfo methodInfo) {\n                    if (!methodInfo.isTopLevelMethod()) {\n                      return false;\n                    }\n                    return super.apply(methodInfo);\n                  }\n                }))\n        // .setDebugFolder(\"/Users/igor/\")\n        ;\n\n    WrapperProxettaBuilder proxettaBuilder = proxetta.builder();\n    proxettaBuilder.setTarget(Hero.class);\n    proxetta.setVariableClassName(true);\n    Object hero = proxettaBuilder.newInstance();\n\n    Method nameMethod = hero.getClass().getMethod(\"name\");\n    assertEquals(\"BatmanHero37W88.3CatWoman99speeeeedXRAYnull\", nameMethod.invoke(nameMethod));\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 129,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 189,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643034345244,
            "program": "  private static void writeResourceBundle(PropertiesFile file, OutputStream out)\n      throws IOException {\n    if (file == null) {\n      out.write(Amf3Types.NULL);\n      return;\n    }\n\n    final AmfOutputStream amfOut = new AmfOutputStream(new ByteArrayOutputStreamEx(4 * 1024));\n    // todo Embed, ClassReference, but idea doesn't support it too\n    final List<IProperty> properties = file.getProperties();\n    amfOut.write(Amf3Types.DICTIONARY);\n    amfOut.writeUInt29((properties.size() << 1) | 1);\n    amfOut.write(0);\n    for (IProperty property : properties) {\n      amfOut.write(property.getUnescapedKey());\n      amfOut.write(property.getUnescapedValue());\n    }\n\n    amfOut.getByteArrayOut().writeTo(out);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 138,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 168,
            "lineNumberOfError": 24,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643034450928,
            "program": "  public void visit(final ParserRuleContext ancestorNode, final SQLStatement statement) {\n    AlterTableStatement alterStatement = (AlterTableStatement) statement;\n\n    ParserRuleContext modifyColumnCtx =\n        TreeUtils.getFirstChildByRuleName(ancestorNode, \"renameColumn\");\n    if (null == modifyColumnCtx) {\n      return;\n    }\n\n    List<ParserRuleContext> columnNodes =\n        TreeUtils.getAllDescendantByRuleName(modifyColumnCtx, \"columnName\");\n    if (null == columnNodes || columnNodes.size() != 2) {\n      return;\n    }\n\n    String oldName = columnNodes.get(0).getText();\n    String newName = columnNodes.get(1).getText();\n    ColumnDefinition oldDefinition = alterStatement.getUpdateColumns().remove(oldName);\n    if (null != oldDefinition) {\n      oldDefinition.setName(newName);\n    } else {\n      oldDefinition = new ColumnDefinition(newName, null, null, false);\n    }\n\n    alterStatement.getUpdateColumns().put(oldName, oldDefinition);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 164,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 236,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643034518323,
            "program": "  public boolean dispatchTouchEvent(MotionEvent ev) {\n    if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n      if (!mTouchEnabled) {\n        mTouchCancelled = true;\n        return false;\n      }\n      mTouchCancelled = false;\n    } else if (mTouchCancelled) {\n      return false;\n    } else if (!mTouchEnabled) {\n      MotionEvent cancel = MotionEvent.obtain(ev);\n      cancel.setAction(MotionEvent.ACTION_CANCEL);\n      super.dispatchTouchEvent(cancel);\n      cancel.recycle();\n      mTouchCancelled = true;\n      return false;\n    }\n    return super.dispatchTouchEvent(ev);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 106,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1217279054-1643036973269": [
        {
            "ProgrammID": 162,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643037504415,
            "program": "  public void importResources(File file) {\n    if (file.exists()) {\n      File[] files = file.listFiles();\n      if (files != null) {\n        for (File f : files) {\n          if (!file.isHidden()) {\n            importResources(f);\n          }\n        }\n      } else {\n        try {\n          URL url = file.toURI().toURL();\n          String parserType = getParserType(url);\n          importFile(parserType, url);\n        } catch (MalformedURLException e) {\n          // can't happen for the 'file' protocol handler with a correctly formatted URI\n          logger.debug(\"Can't create a URL\", e);\n        }\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "review,test",
            "token": 113,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 206,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643037647267,
            "program": "  private TextClassification createClassificationResult(\n      SmartSelection.ClassificationResult[] classifications, String text, int start, int end) {\n    final String classifiedText = text.substring(start, end);\n    final TextClassification.Builder builder =\n        new TextClassification.Builder().setText(classifiedText);\n\n    final int size = classifications.length;\n    for (int i = 0; i < size; i++) {\n      builder.setEntityType(classifications[i].mCollection, classifications[i].mScore);\n    }\n\n    final String type = getHighestScoringType(classifications);\n    addActions(builder, IntentFactory.create(mContext, type, text));\n\n    return builder.setSignature(getSignature(text, start, end)).build();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "review,test",
            "token": 140,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 165,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643037729341,
            "program": "  private boolean sendRemoved(int fingerId, int groupId, int remaining) {\n    IFingerprintServiceReceiver receiver = getReceiver();\n    try {\n      if (receiver != null) {\n        // TODO: plumb remaining\n        receiver.onRemoved(getHalDeviceId(), fingerId, groupId, remaining);\n      }\n    } catch (RemoteException e) {\n      Slog.w(TAG, \"Failed to notify Removed:\", e);\n    }\n    return fingerId == 0;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "review,test",
            "token": 71,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 174,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 21,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643037866695,
            "program": "  public PsiElement simplify(PsiMethodCallExpression call) {\n    PsiExpression value = myValuePointer.getElement();\n    if (value == null) return null;\n    PsiMethodCallExpression qualifierCall = getQualifierMethodCall(call);\n    if (qualifierCall == null) return null;\n    PsiExpressionList qualifierArgs = qualifierCall.getArgumentList();\n    CommentTracker ct = new CommentTracker();\n    PsiReferenceParameterList typeParameters =\n        qualifierCall.getMethodExpression().getParameterList();\n    String typeParametersText = typeParameters == null ? \"\" : ct.text(typeParameters);\n    PsiElement result =\n        ct.replaceAndRestoreComments(\n            call,\n            CommonClassNames.JAVA_UTIL_ARRAYS\n                + \".\"\n                + typeParametersText\n                + \"asList\"\n                + ct.text(qualifierArgs)\n                + \".contains(\"\n                + ct.text(value)\n                + \")\");\n    return JavaCodeStyleManager.getInstance(call.getProject()).shortenClassReferences(result);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "review,test",
            "token": 145,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 166,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643038046535,
            "program": "  public static CharArraySet parseStopWords(\n      Environment env,\n      Settings settings,\n      CharArraySet defaultStopWords,\n      Version version,\n      boolean ignore_case) {\n    String value = settings.get(\"stopwords\");\n    if (value != null) {\n      if (\"_none_\".equals(value)) {\n        return CharArraySet.EMPTY_SET;\n      } else {\n        return resolveNamedStopWords(Strings.commaDelimitedListToSet(value), version, ignore_case);\n      }\n    }\n    String[] stopWords = settings.getAsArray(\"stopwords\", null);\n    if (stopWords != null) {\n      return resolveNamedStopWords(stopWords, version, ignore_case);\n    }\n    List<String> pathLoadedStopWords = getWordList(env, settings, \"stopwords\");\n    if (pathLoadedStopWords != null) {\n      return resolveNamedStopWords(pathLoadedStopWords, version, ignore_case);\n    }\n\n    return defaultStopWords;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "review,test",
            "token": 142,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 207,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 18,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643038263971,
            "program": "  private void handleSecurityPermission(final org.w3c.dom.Node node, PermissionType type)\n      throws Exception {\n    final SecurityConfig cfg = config.getSecurityConfig();\n    final NamedNodeMap attrs = node.getAttributes();\n\n    Node nameNode = attrs.getNamedItem(\"name\");\n    String name = nameNode != null ? getTextContent(nameNode) : \"*\";\n    Node principalNode = attrs.getNamedItem(\"principal\");\n    String principal = principalNode != null ? getTextContent(principalNode) : \"*\";\n\n    final PermissionConfig permConfig = new PermissionConfig(type, name, principal);\n    cfg.addClientPermissionConfig(permConfig);\n\n    for (org.w3c.dom.Node child : new IterableNodeList(node.getChildNodes())) {\n      final String nodeName = cleanNodeName(child.getNodeName());\n      if (\"endpoints\".equals(nodeName)) {\n        handleSecurityPermissionEndpoints(principalNode, permConfig);\n      } else if (\"actions\".equals(nodeName)) {\n        handleSecurityPermissionActions(principalNode, permConfig);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "review,test",
            "token": 183,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 181,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643038438542,
            "program": "  public void centerOnGraph() {\n    float graphWidth = Math.abs(limits.getMaxXoctree() - limits.getMinXoctree());\n    float graphHeight = Math.abs(limits.getMaxYoctree() - limits.getMinYoctree());\n\n    float currentDistanceGraphRatioX =\n        Math.abs(graphDrawable.viewport.get(2) / (float) graphDrawable.getDraggingMarkerX())\n            / graphDrawable.cameraLocation[2];\n    float currentDistanceGraphRatioY =\n        Math.abs(graphDrawable.viewport.get(3) / (float) graphDrawable.getDraggingMarkerY())\n            / graphDrawable.cameraLocation[2];\n    float newCameraLocationX = graphWidth / currentDistanceGraphRatioX;\n    float newCameraLocationY = graphHeight / currentDistanceGraphRatioY;\n    float newCameraLocation = Math.max(newCameraLocationX, newCameraLocationY);\n\n    graphDrawable.cameraLocation[0] = limits.getMinXoctree() + graphWidth / 2;\n    graphDrawable.cameraLocation[1] = limits.getMinYoctree() + graphHeight / 2;\n    graphDrawable.cameraLocation[2] = newCameraLocation;\n\n    graphDrawable.cameraTarget[0] = graphDrawable.cameraLocation[0];\n    graphDrawable.cameraTarget[1] = graphDrawable.cameraLocation[1];\n    graphDrawable.cameraTarget[2] = 0;\n\n    // Refresh\n    engine.getScheduler().requireUpdateVisible();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "review,test",
            "token": 229,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 235,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643038493340,
            "program": "  public AssertThat with(final String name, final Object schema) {\n    return with(\n        new OptiqAssert.ConnectionFactory() {\n          public OptiqConnection createConnection() throws Exception {\n            Class.forName(\"net.hydromatic.optiq.jdbc.Driver\");\n            Connection connection = DriverManager.getConnection(\"jdbc:optiq:\");\n            OptiqConnection optiqConnection = connection.unwrap(OptiqConnection.class);\n            MutableSchema rootSchema = optiqConnection.getRootSchema();\n            ReflectiveSchema.create(optiqConnection, rootSchema, name, schema);\n            optiqConnection.setSchema(name);\n            return optiqConnection;\n          }\n        });\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "review,test",
            "token": 97,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "634855312-1643043373659": [
        {
            "ProgrammID": 191,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 16,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643043975558,
            "program": "  public static RowFlagChange load(LineNumberReader reader, Pool pool) throws Exception {\n    int row = -1;\n    boolean oldFlagged = false;\n    boolean newFlagged = false;\n\n    String line;\n    while ((line = reader.readLine()) != null && !\"/ec/\".equals(line)) {\n      int equal = line.indexOf('=');\n      CharSequence field = line.subSequence(0, equal);\n      String value = line.substring(equal + 1);\n\n      if (\"row\".equals(field)) {\n        row = Integer.parseInt(value);\n      } else if (\"oldFlagged\".equals(field)) {\n        oldFlagged = Boolean.parseBoolean(value);\n      } else if (\"newFlagged\".equals(field)) {\n        oldFlagged = Boolean.parseBoolean(value);\n      }\n    }\n\n    RowFlagChange change = new RowFlagChange(row, newFlagged);\n    change.oldFlagged = oldFlagged;\n\n    return change;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 174,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 222,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643044094963,
            "program": "  private Template generateScaffoldedTemplate(\n      GrailsWebRequest webRequest, String templateName, String uri) throws IOException {\n    Template t = null;\n    Collection<String> controllerActions = scaffoldedActionMap.get(webRequest.getControllerName());\n    if (controllerActions != null && controllerActions.contains(webRequest.getActionName())) {\n      GrailsDomainClass domainClass =\n          controllerToScaffoldedDomainClassMap.get(webRequest.getControllerName());\n      if (domainClass != null) {\n        int i = uri.lastIndexOf('/');\n        String scaffoldedtemplateName = i > -1 ? uri.substring(i) : uri;\n        if (scaffoldedtemplateName.toLowerCase().endsWith(\".gsp\")) {\n          scaffoldedtemplateName =\n              scaffoldedtemplateName.substring(0, scaffoldedtemplateName.length() - 4);\n        }\n        FastStringWriter sw = new FastStringWriter();\n        ReflectionUtils.invokeMethod(\n            generateViewMethod,\n            scaffoldingTemplateGenerator,\n            domainClass,\n            scaffoldedtemplateName,\n            sw);\n        t = groovyPagesTemplateEngine.createTemplate(sw.toString(), uri);\n      }\n    }\n    return t;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 180,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 197,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643044202641,
            "program": "  public static Icon getIcon(File file) {\n    Icon fileIcon = null;\n\n    try {\n      sun.awt.shell.ShellFolder shellFolder = sun.awt.shell.ShellFolder.getShellFolder(file);\n\n      fileIcon = new ImageIcon(shellFolder.getIcon(true), shellFolder.getFolderType());\n    } catch (Exception e) {\n      logger.debug(\"Failed to obtain file icon from ShellFolder.\", e);\n      try {\n        fileIcon = new JFileChooser().getIcon(file);\n      } catch (Exception e1) {\n        logger.debug(\"Failed to obtain file icon from JFileChooser.\", e1);\n      }\n    }\n\n    return fileIcon;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 109,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 188,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643044264539,
            "program": "  private boolean isSunUpAllDay(Calendar calendar, double latitude, double longitude) {\n    Calendar cal = DateTimeUtils.truncateToMidnight(calendar);\n    Sun sun = new Sun();\n    for (int minutes = 0; minutes <= MINUTES_PER_DAY; minutes += CURVE_TIME_INTERVAL) {\n      setSunPosition(cal, latitude, longitude, sun);\n      if (sun.getPosition().getElevation() < SUN_ANGLE) {\n        return false;\n      }\n      cal.add(Calendar.MINUTE, CURVE_TIME_INTERVAL);\n    }\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 94,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 179,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643044316172,
            "program": "  public FileType findFileTypeByName(String fileTypeName) {\n    FileType type = getStdFileType(fileTypeName);\n    // TODO: Abstract file types are not std one, so need to be restored specially,\n    // currently there are 6 of them and restoration does not happen very often so just iteration is\n    // enough\n    if (type == PlainTextFileType.INSTANCE && !fileTypeName.equals(type.getName())) {\n      for (FileType fileType : getRegisteredFileTypes()) {\n        if (fileType.equals(fileType.getName())) {\n          return fileType;\n        }\n      }\n    }\n    return type;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 71,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 173,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643044380051,
            "program": "  private static boolean shouldBeGenerated(PsiMethod method) {\n    for (PsiMethod psiMethod : method.findSuperMethods()) {\n      if (!psiMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        final PsiType type = method.getReturnType();\n        final PsiType superType = psiMethod.getReturnType();\n        if (type != null && superType != null && !superType.isAssignableFrom(type)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 83,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 238,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643044442707,
            "program": "  public static Cache initializeCache(\n      String name, String propertiesName, int size, long expirationTime) {\n    Cache cache = caches.get(name);\n    if (cache == null) {\n      size = JiveGlobals.getIntProperty(\"cache.\" + name + \".size\", size);\n      expirationTime =\n          (long)\n              JiveGlobals.getIntProperty(\n                  \"cache.\" + propertiesName + \".expirationTime\", (int) expirationTime);\n      cache = new Cache(name, size, expirationTime);\n      caches.put(name, cache);\n    }\n    return cache;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 97,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 167,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643044518029,
            "program": "  public void test03() {\n    initializeForTimeout();\n    // 0 disables alarm utility\n    OptionValues initialOptions = getInitialOptions();\n    OptionValues options = new OptionValues(initialOptions, CompilationExpirationPeriod, 0);\n    try (CompilationAlarm c1 = CompilationAlarm.trackCompilationPeriod(options)) {\n      StructuredGraph g = parseEager(\"snippet\", AllowAssumptions.NO, options);\n      new PartiallyCooperativePhase().apply(g);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop",
            "token": 69,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1121035186-1643098701252": [
        {
            "ProgrammID": 205,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643099042563,
            "program": "  protected int putCodeWScope(String name, CodeWScope code) {\n    final int start = _buf.position();\n    _put(CODE_W_SCOPE, name);\n    int temp = _buf.position();\n    _buf.putInt(0);\n    _putValueString(code._code);\n    putObject(code._scope);\n    _buf.putInt(temp, _buf.position() - start);\n    return _buf.position() - start;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 83,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 220,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643099184508,
            "program": "  public void checkResultByFile(final String filePath, final String expectedFile) throws Throwable {\n\n    new WriteCommandAction.Simple(myProjectFixture.getProject()) {\n\n      protected void run() throws Throwable {\n        String fullPath = getTempDirPath() + \"/\" + filePath;\n        final VirtualFile copy =\n            LocalFileSystem.getInstance()\n                .refreshAndFindFileByPath(fullPath.replace(File.separatorChar, '/'));\n        assert copy != null : \"file not found: \" + fullPath;\n        final PsiFile psiFile = myPsiManager.findFile(copy);\n        assert psiFile != null;\n        checkResultByFile(expectedFile, psiFile, false);\n      }\n    }.execute().throwException();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 116,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 223,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643099267187,
            "program": "  private void scrollLayerTo(int x, int y) {\n    int dx = mScrollingLayerRect.left - x;\n    int dy = mScrollingLayerRect.top - y;\n    if (dx == 0 && y == 0) {\n      return;\n    }\n    if (mSelectingText) {\n      if (mSelectCursorBaseLayerId == mCurrentScrollingLayerId) {\n        mSelectCursorBase.offset(dx, dy);\n        mSelectCursorBaseTextQuad.offset(dx, dy);\n      }\n      if (mSelectCursorExtentLayerId == mCurrentScrollingLayerId) {\n        mSelectCursorExtent.offset(dx, dy);\n        mSelectCursorExtentTextQuad.offset(dx, dy);\n      }\n    }\n    if (mAutoCompletePopup != null && mCurrentScrollingLayerId == mEditTextLayerId) {\n      mEditTextBounds.offset(dx, dy);\n      mAutoCompletePopup.resetRect();\n    }\n    nativeScrollLayer(mCurrentScrollingLayerId, x, y);\n    mScrollingLayerRect.left = x;\n    mScrollingLayerRect.top = y;\n    mWebViewCore.sendMessage(\n        WebViewCore.EventHub.SCROLL_LAYER, mCurrentScrollingLayerId, mScrollingLayerRect);\n    mWebViewPrivate.onScrollChanged(getScrollX(), getScrollY(), getScrollX(), getScrollY());\n    invalidate();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 190,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 172,
            "lineNumberOfError": 18,
            "attempt": 1,
            "expectedAnswer": 20,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643099320669,
            "program": "  public Element writeXML(Document document) {\n    Element modelE = document.createElement(\"statisticsmodel\");\n\n    Element resultsE = document.createElement(\"results\");\n    for (Map.Entry<StatisticsUI, String> entry : resultMap.entrySet()) {\n      if (entry.getValue() != null && !entry.getValue().isEmpty()) {\n        Element resultE = document.createElement(\"result\");\n        resultE.setAttribute(\"class\", entry.getKey().getClass().getName());\n        resultE.setAttribute(\"value\", entry.getValue());\n        resultsE.appendChild(resultE);\n      }\n    }\n    modelE.appendChild(resultsE);\n\n    Element reportsE = document.createElement(\"reports\");\n    for (Map.Entry<Class, String> entry : reportMap.entrySet()) {\n      if (entry.getValue() != null && !entry.getValue().isEmpty()) {\n        Element reportE = document.createElement(\"report\");\n        reportE.setAttribute(\"class\", entry.getKey().getName());\n        reportE.setAttribute(\"value\", entry.getValue());\n        resultsE.appendChild(reportE);\n      }\n    }\n    modelE.appendChild(reportsE);\n\n    return modelE;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 240,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 234,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 29,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643099457769,
            "program": "  protected String retrieveFinalFormKey(\n      String formKey,\n      FlowElement flowElement,\n      Map<Long, Form> formIdMap,\n      AbstractModel model,\n      Long appDefinitionId,\n      Long appDeploymentId,\n      User user) {\n\n    String finalFormKey = null;\n    List<ExtensionElement> formIdExtensions =\n        flowElement.getExtensionElements().get(\"form-reference-id\");\n    List<ExtensionElement> formNameExtensions =\n        flowElement.getExtensionElements().get(\"form-reference-name\");\n    if (CollectionUtils.isNotEmpty(formIdExtensions)\n        && CollectionUtils.isNotEmpty(formNameExtensions)) {\n      Long formId = Long.valueOf(formIdExtensions.get(0).getElementText());\n      finalFormKey =\n          getFormKeyWithFormId(formId, formIdMap, model, appDefinitionId, appDeploymentId, user);\n\n    } else if (StringUtils.isNotEmpty(formKey) && formKey.startsWith(\"FORM_REFERENCE\")) {\n      String formIdValue = formKey.replace(\"FORM_REFERENCE\", \"\");\n      if (NumberUtils.isNumber(formIdValue)) {\n        Long formId = Long.valueOf(formIdValue);\n        finalFormKey =\n            getFormKeyWithFormId(formId, formIdMap, model, appDefinitionId, appDeploymentId, user);\n      }\n    }\n\n    if (StringUtils.isEmpty(formKey)) {\n      finalFormKey = formKey;\n    }\n\n    return finalFormKey;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 212,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 224,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643099548441,
            "program": "  private void addCustomDefinition(\n      @NotNull AntDomNamedElement declaringTag,\n      String customTagName,\n      String nsUri,\n      Class clazz,\n      String error) {\n    final XmlName xmlName = new XmlName(customTagName, nsUri == null ? \"\" : nsUri);\n    if (error != null) {\n      myErrors.put(xmlName, error);\n    }\n    myCustomElements.put(xmlName, clazz);\n    myDeclarations.put(xmlName, declaringTag);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 76,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 190,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643099593145,
            "program": "  public static boolean isActiveService(Context context, ComponentName service) {\n    String cur =\n        Settings.Secure.getString(\n            context.getContentResolver(), Settings.Secure.VOICE_INTERACTION_SERVICE);\n    if (cur == null || cur.isEmpty()) {\n      return false;\n    }\n    ComponentName curComp = ComponentName.unflattenFromString(cur);\n    if (curComp == null) {\n      return false;\n    }\n    return curComp.equals(cur);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 81,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 211,
            "lineNumberOfError": 14,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643099676328,
            "program": "  public void addAllUpdates(RightTupleSets tupleSets) {\n    RightTupleSetsImpl tupleSetsImpl = (RightTupleSetsImpl) tupleSets;\n    if (updateFirst == null) {\n      updateFirst = tupleSetsImpl.getUpdateFirst();\n      updateSize = tupleSetsImpl.updateSize;\n    } else {\n      RightTuple current = updateFirst;\n      RightTuple last = null;\n      while (current != null) {\n        last = current;\n        current = current.getStagedNext();\n      }\n      RightTuple rightTuple = tupleSetsImpl.getUpdateFirst();\n      last.setStagedNext(rightTuple);\n      rightTuple.setStagePrevious(rightTuple);\n      updateSize = updateSize + tupleSetsImpl.updateSize();\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop,review",
            "token": 105,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "93647063-1643098964555": [
        {
            "ProgrammID": 161,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643099282605,
            "program": "  protected void handleRefCursorOutputParameter(\r\n      CallableStatement cs,\r\n      ParameterMapping parameterMapping,\r\n      int parameterMappingIndex,\r\n      MetaObject metaParam)\r\n      throws SQLException {\r\n    final ResultSet rs = (ResultSet) cs.getObject(parameterMappingIndex + 1);\r\n    final String resultMapId = parameterMapping.getResultMapId();\r\n    if (resultMapId != null) {\r\n      final ResultMap resultMap = configuration.getResultMap(resultMapId);\r\n      final DefaultResultHandler resultHandler =\r\n          new DefaultResultHandler(configuration.getDefaultListResultHandlerType());\r\n      ResultColumnCache resultColumnCache = new ResultColumnCache(rs.getMetaData(), configuration);\r\n      handleRowValues(rs, resultMap, resultHandler, new RowBounds(), resultColumnCache);\r\n      metaParam.setValue(parameterMapping.getProperty(), resultHandler.getResultList());\r\n    } else {\r\n      throw new ExecutorException(\r\n          \"Parameter requires ResultMap for output types of java.sql.ResultSet\");\r\n    }\r\n    rs.close();\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 143,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 178,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643099324368,
            "program": "  private void delay(long duration) {\n    if (duration > 0) {\n      long bedtime = duration + SystemClock.uptimeMillis();\n      do {\n        try {\n          this.wait(duration);\n        } catch (InterruptedException e) {\n        }\n        if (mDone) {\n          break;\n        }\n        duration = bedtime - SystemClock.uptimeMillis();\n      } while (duration > 0);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 73,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 187,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643099366477,
            "program": "  private Vector3 calculateDirection(float angle) {\r\n    Matrix4 transform = new Matrix4();\r\n    Vector3 dir = new Vector3(-1, 0, 1).nor();\r\n    float rotAngle = (float) Math.toDegrees(Math.asin(Math.tan(Math.toRadians(angle))));\r\n    transform.setToRotation(new Vector3(1, 0, 1).nor(), rotAngle);\r\n    dir.mul(transform).nor();\r\n    return dir;\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 98,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 202,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643099427797,
            "program": "  private Object[] buildParamList(Functor func, int indexOfParamToSetToNull) {\n    Class<?>[] types = func.getParameterTypes();\n    Object[] params = new Object[types.length];\n\n    for (int i = 0; i < types.length; i++) {\n      if (i != indexOfParamToSetToNull) {\n        params[i] = defaults.get(types[i]);\n        if (!parameterIsPrimitiveOrNullable(func, i)) {\n          Assert.assertTrue(\"No default value found for \" + types[i].getName(), params[i] != null);\n        }\n      }\n    }\n    return params;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 120,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 186,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643099523109,
            "program": "  public static void const2stack(\n      CompilationResultBuilder crb,\n      SPARCMacroAssembler masm,\n      Value result,\n      Register constantTableBase,\n      Value input,\n      SPARCDelayedControlTransfer delaySlotLir,\n      JavaConstant constant) {\n    if (constant.isDefaultForKind() || constant.isNull()) {\n      SPARCAddress resultAddress = (SPARCAddress) crb.asAddress(result);\n      emitStore(\n          g0.asValue(LIRKind.combine(input)),\n          resultAddress,\n          result.getPlatformKind(),\n          delaySlotLir,\n          null,\n          crb,\n          masm);\n    } else {\n      try (ScratchRegister sc = masm.getScratchRegister()) {\n        Value scratchRegisterValue = sc.getRegister().asValue(LIRKind.combine(constant));\n        const2reg(\n            crb,\n            masm,\n            scratchRegisterValue,\n            constantTableBase,\n            constant,\n            SPARCDelayedControlTransfer.DUMMY);\n        SPARCAddress resultAddress = (SPARCAddress) crb.asAddress(result);\n        emitStore(\n            scratchRegisterValue,\n            resultAddress,\n            result.getPlatformKind(),\n            delaySlotLir,\n            null,\n            crb,\n            masm);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 174,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 212,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643099617976,
            "program": "  public static Block createLongDictionaryBlock(int start, int length) {\n    int dictionarySize = length / 5;\n    BlockBuilder builder = BIGINT.createBlockBuilder(new BlockBuilderStatus(), dictionarySize);\n    for (int i = start; i < dictionarySize; i++) {\n      BIGINT.writeLong(builder, i);\n    }\n    int[] ids = new int[length];\n    for (int i = 0; i < length; i++) {\n      ids[i] = i % dictionarySize;\n    }\n    return new DictionaryBlock(length, builder.build(), wrappedIntArray(ids));\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 114,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 204,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643099712878,
            "program": "  static ErrorProneAnalyzer createAnalyzer(\n      ScannerSupplier scannerSupplier,\n      ErrorProneOptions epOptions,\n      Context context,\n      RefactoringCollection[] refactoringCollection) {\n    if (!epOptions.patchingOptions().doRefactor()) {\n      return ErrorProneAnalyzer.createByScanningForPlugins(scannerSupplier, epOptions, context);\n    }\n    refactoringCollection[0] = RefactoringCollection.refactor(epOptions.patchingOptions());\n\n    // Refaster refactorer or using builtin checks\n    CodeTransformer codeTransformer =\n        epOptions\n            .patchingOptions()\n            .customRefactorer()\n            .or(\n                () -> {\n                  ScannerSupplier toUse = ErrorPronePlugins.loadPlugins(scannerSupplier, context);\n                  Set<String> namedCheckers = epOptions.patchingOptions().namedCheckers();\n                  if (!namedCheckers.isEmpty()) {\n                    toUse = toUse.filter(bci -> namedCheckers.contains(bci.canonicalName()));\n                  }\n                  return ErrorProneScannerTransformer.create(toUse.applyOverrides(epOptions).get());\n                })\n            .get();\n\n    return ErrorProneAnalyzer.createWithCustomDescriptionListener(\n        codeTransformer, epOptions, context, refactoringCollection[0]);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 182,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 160,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643099765186,
            "program": "  public void updateKBArticlePriority(KBArticle kbArticle, double priority)\n      throws PortalException, SystemException {\n\n    List<KBArticle> kbArticleVersions =\n        getKBArticleVersions(\n            kbArticle.getResourcePrimKey(),\n            WorkflowConstants.STATUS_ANY,\n            QueryUtil.ALL_POS,\n            QueryUtil.ALL_POS,\n            null);\n\n    for (KBArticle kbArticleVersion : kbArticleVersions) {\n      kbArticleVersion.setPriority(priority);\n\n      kbArticlePersistence.update(kbArticleVersion);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 68,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1124197074-1643100709727": [
        {
            "ProgrammID": 185,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643101531603,
            "program": "  public Window destroyActivity(String id, boolean finish) {\n    LocalActivityRecord r = mActivities.get(id);\n    Window win = null;\n    if (r != null) {\n      win = performDestroy(r, finish);\n      if (finish) {\n        mActivities.remove(r);\n      }\n    }\n    return win;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 60,
            "ctx": "others",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 227,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643101618609,
            "program": "  public void setPermissions(final List<String> permissions) {\n    final List<String> perms = Lists.newArrayList(permissions);\n    // Do not store the dynamic user self edit permissions\n    perms.removeAll(this.permissions.userSelfEditPermissions(getName()));\n    fields.put(PERMISSIONS, permissions);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 52,
            "ctx": "others",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 210,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643101806677,
            "program": "  private KadaneResult kadane(int arr[]) {\n    int max = 0;\n    int maxStart = -1;\n    int maxEnd = -1;\n    int currentStart = 0;\n    int maxSoFar = 0;\n    for (int i = 0; i < arr.length; i++) {\n      maxSoFar += arr[i];\n      if (maxSoFar < 0) {\n        maxSoFar = 0;\n        currentStart = i + 1;\n      }\n      if (max < maxSoFar) {\n        maxStart = currentStart;\n        maxEnd = i;\n        max = maxSoFar;\n      }\n    }\n    return new KadaneResult(max, maxStart, maxEnd);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 112,
            "ctx": "others",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 216,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643101901277,
            "program": "  private Class<? extends DomElement> findImplementationClassDFS(\n      final Class<? extends DomElement> concreteInterface) {\n    Class<? extends DomElement> aClass = myImplementationClasses.get(concreteInterface);\n    if (aClass != null) {\n      return aClass;\n    }\n    for (final Class aClass1 : concreteInterface.getInterfaces()) {\n      aClass = findImplementationClassDFS(aClass1);\n      if (aClass != null) {\n        return aClass;\n      }\n    }\n    return null;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 81,
            "ctx": "others",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 221,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643101981459,
            "program": "  private void pollFilter(EthFilter ethFilter) {\n    EthLog ethLog = null;\n    try {\n      ethLog = web3j.ethGetFilterChanges(filterId).send();\n    } catch (IOException e) {\n      throwException(e);\n    }\n    if (ethLog.hasError()) {\n      throwException(ethFilter.getError());\n    } else {\n      process(ethLog.getLogs());\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 73,
            "ctx": "others",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 218,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643102042887,
            "program": "  protected static int calculateShift(int minimumValue, int maximumValue) {\n    int shift = 0;\n    int value = 1;\n    while (value < minimumValue && value < minimumValue) {\n      value <<= 1;\n      shift++;\n    }\n    return shift;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 45,
            "ctx": "others",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 201,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643102394084,
            "program": "  private <T extends Metric> T register(String name, MetricRegistrar<T> registrar) {\n    Reservoir reservoir = this.reservoirFactory.getReservoir(name);\n    if (reservoir == null) {\n      return registrar.register(this.registry, name);\n    }\n    Metric metric = this.registry.getMetrics().get(name);\n    if (metric != null) {\n      registrar.checkExisting(metric);\n      return (T) metric;\n    }\n    try {\n      return this.registry.register(name, registrar.createForReservoir(reservoir));\n    } catch (IllegalArgumentException ex) {\n      Metric added = this.registry.getMetrics().get(name);\n      registrar.checkExisting(added);\n      return (T) added;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 145,
            "ctx": "others",
            "codebase": "others",
            "team": "alone"
        },
        {
            "ProgrammID": 239,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643102435467,
            "program": "  public void addStream(String meetingId, VideoStream vs) {\r\n    Meeting m = meetings.get(meetingId);\r\n    if (m != null) {\r\n      m.addStream(vs);\r\n    } else {\r\n      Meeting nm = new Meeting(meetingId);\r\n      nm.addStream(vs);\r\n      add(m);\r\n    }\r\n  }\r\n",
            "exp": "2",
            "age": "30",
            "task": "review,develop",
            "token": 61,
            "ctx": "others",
            "codebase": "others",
            "team": "alone"
        }
    ],
    "2135662896-1643103318762": [
        {
            "ProgrammID": 180,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643103694171,
            "program": "  private void computePostdominators() {\n    outer:\n    for (Block block : postOrder()) {\n      if (block.isLoopEnd()) {\n        // We do not want the loop header registered as the postdominator of the loop end.\n        continue;\n      }\n      if (block.getSuccessorCount() == 0) {\n        // No successors => no postdominator.\n        continue;\n      }\n      Block firstSucc = block.getSuccessors().get(0);\n      if (block.getSuccessorCount() == 1) {\n        block.postdominator = block;\n        continue;\n      }\n      Block postdominator = firstSucc;\n      for (Block sux : block.getSuccessors()) {\n        postdominator = commonPostdominator(postdominator, sux);\n        if (postdominator == null) {\n          // There is a dead end => no postdominator available.\n          continue outer;\n        }\n      }\n      assert !block.getSuccessors().contains(postdominator)\n          : \"Block \" + block + \" has a wrong post dominator: \" + postdominator;\n      block.postdominator = postdominator;\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 145,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 192,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643103770106,
            "program": "  static void registerTransformers(SubsystemRegistration subsystem) {\n    ResourceTransformationDescriptionBuilder builder110 =\n        TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n    ResourceAdapterResourceDefinition.registerTransformers110(builder110);\n    TransformationDescription.Tools.register(\n        builder110.build(), subsystem, ModelVersion.create(1, 1, 0));\n    ResourceTransformationDescriptionBuilder builder120 =\n        TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n    ResourceAdapterResourceDefinition.registerTransformers120(builder120);\n    TransformationDescription.Tools.register(\n        builder120.build(), subsystem, ModelVersion.create(1, 2, 0));\n    // Apply same to RBAC-updated version\n    TransformationDescription.Tools.register(\n        builder120.build(), subsystem, ModelVersion.create(1, 3, 0));\n    ResourceTransformationDescriptionBuilder builder200 =\n        TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n    ResourceAdapterResourceDefinition.registerTransformers200(builder200);\n    TransformationDescription.Tools.register(\n        builder200.build(), subsystem, ModelVersion.create(2, 0, 0));\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 167,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 198,
            "lineNumberOfError": 12,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643103910922,
            "program": "  public void finishBatch() {\n    for (String key : _counts.keySet()) {\n      CountValue val = COUNT_DATABASE.get(key);\n      CountValue newVal;\n      if (val == null || !val.txid.equals(_id)) {\n        newVal = new CountValue();\n        newVal.txid = _id.getTransactionId();\n        if (val != null) {\n          newVal.prev_count = val.count;\n          newVal.count = val.count;\n        }\n        newVal.count = newVal.count + _counts.get(key);\n        COUNT_DATABASE.put(key, newVal);\n      } else {\n        newVal = val;\n      }\n      _collector.emit(new Values(_id, key, newVal.count, newVal.prev_count));\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 144,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 175,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643103968275,
            "program": "  protected static void linkifyText(final String text, final StringBuffer outputBuffer) {\n    String prepared = text.replaceAll(Regex.BITCOIN_URI_PATTERN, \"<a href=\\\"$0\\\">$0</a>\");\n\n    Matcher m = Regex.WEB_URL_PATTERN.matcher(prepared);\n    while (m.find()) {\n      int start = m.start();\n      if (start == 0 || (start != 0 && prepared.charAt(start - 1) != '@')) {\n        if (m.group().indexOf(':')\n            > 0) { // With no URI-schema we may get \"http:/\" links with the second / missing\n          m.appendReplacement(outputBuffer, \"<a href=\\\"$0\\\">$0</a>\");\n        } else {\n          m.appendReplacement(outputBuffer, \"<a href=\\\"http://$0\\\">$0</a>\");\n        }\n      } else {\n        m.appendReplacement(outputBuffer, \"$0\");\n      }\n    }\n\n    m.appendTail(outputBuffer);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 142,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 199,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643104028900,
            "program": "  private static final Comparator<Method> METHOD_COMPARATOR =\n      new Comparator<Method>() {\n        public int compare(final Method o1, final Method o2) {\n          int cmp = o1.getName().compareTo(o2.getName());\n          if (cmp != 0) return cmp;\n          cmp = o1.getParameterTypes().length - o2.getParameterTypes().length;\n          return cmp;\n        }\n      };\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 81,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 200,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643104076074,
            "program": "  private void checkChunkReady(Vector3i pos) {\n    if (worldEntity.exists()) {\n      for (Vector3i adjPos : Region3i.createFromCenterExtents(pos, LOCAL_REGION_EXTENTS)) {\n        Chunk chunk = getChunk(pos);\n        if (chunk == null || chunk.getChunkState() != Chunk.State.COMPLETE) {\n          return;\n        }\n      }\n      worldEntity.send(new ChunkReadyEvent(pos));\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 76,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 194,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643104209648,
            "program": "  public final View getView(int position, View convertView, ViewGroup parent) {\n    ContextualUndoView contextualUndoView = (ContextualUndoView) convertView;\n    if (contextualUndoView == null) {\n      contextualUndoView =\n          new ContextualUndoView(parent.getContext(), mUndoLayoutId, mCountDownTextViewResId);\n      contextualUndoView\n          .findViewById(mUndoActionId)\n          .setOnClickListener(new UndoListener(contextualUndoView));\n    }\n\n    View contentView = super.getView(position, contextualUndoView.getContentView(), parent);\n    contextualUndoView.updateContentView(contentView);\n\n    long itemId = getItemId(position);\n\n    if (itemId == mCurrentRemovedId) {\n      contextualUndoView.displayUndo();\n      mCurrentRemovedView = contextualUndoView;\n      long millisLeft = mAutoDeleteDelayMillis - (System.currentTimeMillis() - mDismissStartMillis);\n      if (mCountDownFormatter != null) {\n        mCurrentRemovedView.updateCountDownTimer(\n            mCountDownFormatter.getCountDownString(millisLeft));\n      }\n    } else {\n      contextualUndoView.displayContentView();\n    }\n\n    contextualUndoView.setItemId(itemId);\n    return contextualUndoView;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 169,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 216,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643104250784,
            "program": "  private Class<? extends DomElement> findImplementationClassDFS(\n      final Class<? extends DomElement> concreteInterface) {\n    Class<? extends DomElement> aClass = myImplementationClasses.get(concreteInterface);\n    if (aClass != null) {\n      return aClass;\n    }\n    for (final Class aClass1 : concreteInterface.getInterfaces()) {\n      aClass = findImplementationClassDFS(aClass1);\n      if (aClass != null) {\n        return aClass;\n      }\n    }\n    return null;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 81,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1714154921-1643108765769": [
        {
            "ProgrammID": 175,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643109156038,
            "program": "  protected static void linkifyText(final String text, final StringBuffer outputBuffer) {\n    String prepared = text.replaceAll(Regex.BITCOIN_URI_PATTERN, \"<a href=\\\"$0\\\">$0</a>\");\n\n    Matcher m = Regex.WEB_URL_PATTERN.matcher(prepared);\n    while (m.find()) {\n      int start = m.start();\n      if (start == 0 || (start != 0 && prepared.charAt(start - 1) != '@')) {\n        if (m.group().indexOf(':')\n            > 0) { // With no URI-schema we may get \"http:/\" links with the second / missing\n          m.appendReplacement(outputBuffer, \"<a href=\\\"$0\\\">$0</a>\");\n        } else {\n          m.appendReplacement(outputBuffer, \"<a href=\\\"http://$0\\\">$0</a>\");\n        }\n      } else {\n        m.appendReplacement(outputBuffer, \"$0\");\n      }\n    }\n\n    m.appendTail(outputBuffer);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,test",
            "token": 142,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 180,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643109220918,
            "program": "  private void computePostdominators() {\n    outer:\n    for (Block block : postOrder()) {\n      if (block.isLoopEnd()) {\n        // We do not want the loop header registered as the postdominator of the loop end.\n        continue;\n      }\n      if (block.getSuccessorCount() == 0) {\n        // No successors => no postdominator.\n        continue;\n      }\n      Block firstSucc = block.getSuccessors().get(0);\n      if (block.getSuccessorCount() == 1) {\n        block.postdominator = block;\n        continue;\n      }\n      Block postdominator = firstSucc;\n      for (Block sux : block.getSuccessors()) {\n        postdominator = commonPostdominator(postdominator, sux);\n        if (postdominator == null) {\n          // There is a dead end => no postdominator available.\n          continue outer;\n        }\n      }\n      assert !block.getSuccessors().contains(postdominator)\n          : \"Block \" + block + \" has a wrong post dominator: \" + postdominator;\n      block.postdominator = postdominator;\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,test",
            "token": 145,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 239,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643109255924,
            "program": "  public void addStream(String meetingId, VideoStream vs) {\r\n    Meeting m = meetings.get(meetingId);\r\n    if (m != null) {\r\n      m.addStream(vs);\r\n    } else {\r\n      Meeting nm = new Meeting(meetingId);\r\n      nm.addStream(vs);\r\n      add(m);\r\n    }\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "develop,test",
            "token": 61,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 170,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643109291277,
            "program": "  public <T> ICompletableFuture<T> submitInternal(final Callable<T> command) {\n    CompletableFutureTask futureTask = new CompletableFutureTask(command, internalExecutor);\n    internalExecutor.submit(futureTask);\n    return futureTask;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,test",
            "token": 40,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 214,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643109382649,
            "program": "  public void doWithLibraries(LibraryCallback callback) throws IOException {\n\n    FileCollection compile = this.project.getConfigurations().getByName(\"compile\");\n\n    FileCollection runtime = this.project.getConfigurations().getByName(\"runtime\");\n    runtime = runtime.minus(compile);\n\n    FileCollection provided =\n        this.project.getConfigurations().findByName(this.providedConfigurationName);\n    if (provided != null) {\n      compile = compile.minus(provided);\n      runtime = compile.minus(provided);\n    }\n\n    libraries(LibraryScope.COMPILE, compile, callback);\n    libraries(LibraryScope.RUNTIME, runtime, callback);\n    libraries(LibraryScope.PROVIDED, provided, callback);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,test",
            "token": 129,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 224,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643109453409,
            "program": "  private void addCustomDefinition(\n      @NotNull AntDomNamedElement declaringTag,\n      String customTagName,\n      String nsUri,\n      Class clazz,\n      String error) {\n    final XmlName xmlName = new XmlName(customTagName, nsUri == null ? \"\" : nsUri);\n    if (error != null) {\n      myErrors.put(xmlName, error);\n    }\n    myCustomElements.put(xmlName, clazz);\n    myDeclarations.put(xmlName, declaringTag);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,test",
            "token": 76,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 191,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": 16,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643109511330,
            "program": "  public static RowFlagChange load(LineNumberReader reader, Pool pool) throws Exception {\n    int row = -1;\n    boolean oldFlagged = false;\n    boolean newFlagged = false;\n\n    String line;\n    while ((line = reader.readLine()) != null && !\"/ec/\".equals(line)) {\n      int equal = line.indexOf('=');\n      CharSequence field = line.subSequence(0, equal);\n      String value = line.substring(equal + 1);\n\n      if (\"row\".equals(field)) {\n        row = Integer.parseInt(value);\n      } else if (\"oldFlagged\".equals(field)) {\n        oldFlagged = Boolean.parseBoolean(value);\n      } else if (\"newFlagged\".equals(field)) {\n        oldFlagged = Boolean.parseBoolean(value);\n      }\n    }\n\n    RowFlagChange change = new RowFlagChange(row, newFlagged);\n    change.oldFlagged = oldFlagged;\n\n    return change;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,test",
            "token": 174,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 218,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643109540545,
            "program": "  protected static int calculateShift(int minimumValue, int maximumValue) {\n    int shift = 0;\n    int value = 1;\n    while (value < minimumValue && value < minimumValue) {\n      value <<= 1;\n      shift++;\n    }\n    return shift;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "develop,test",
            "token": 45,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1037282192-1643117151739": [
        {
            "ProgrammID": 232,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643117480298,
            "program": "  protected double getDropoutFromConfig(Map<String, Object> layerConfig)\n      throws InvalidKerasConfigurationException {\n    Map<String, Object> innerConfig = getInnerLayerConfigFromConfig(layerConfig);\n    /* NOTE: Keras \"dropout\" parameter determines dropout probability,\n     * while DL4J \"dropout\" parameter determines retention probability.\n     */\n    double dropout = 1.0;\n    if (innerConfig.containsKey(LAYER_FIELD_DROPOUT)) {\n      /* For most feedforward layers. */\n      dropout = 1.0 - (double) innerConfig.get(LAYER_FIELD_DROPOUT);\n    } else if (layerConfig.containsKey(LAYER_FIELD_DROPOUT_W)) {\n      /* For LSTMs. */\n      dropout = 1.0 - (double) layerConfig.get(LAYER_FIELD_DROPOUT_W);\n    }\n    return dropout;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 88,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 195,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643117543766,
            "program": "  private List<String> giveFieldBinding(FieldConstraint f) {\n    List<String> result = new ArrayList<String>();\n    if (f instanceof SingleFieldConstraint) {\n      SingleFieldConstraint s = (SingleFieldConstraint) f;\n      if (s.isBound() == true) {\n        result.add(s.fieldBinding);\n      }\n    }\n    if (f instanceof CompositeFieldConstraint) {\n      CompositeFieldConstraint s = (CompositeFieldConstraint) f;\n      for (FieldConstraint ss : s.constraints) {\n        List<String> t = giveFieldBinding(s);\n        result.addAll(t);\n      }\n    }\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 111,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 172,
            "lineNumberOfError": 18,
            "attempt": 1,
            "expectedAnswer": 20,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643117642157,
            "program": "  public Element writeXML(Document document) {\n    Element modelE = document.createElement(\"statisticsmodel\");\n\n    Element resultsE = document.createElement(\"results\");\n    for (Map.Entry<StatisticsUI, String> entry : resultMap.entrySet()) {\n      if (entry.getValue() != null && !entry.getValue().isEmpty()) {\n        Element resultE = document.createElement(\"result\");\n        resultE.setAttribute(\"class\", entry.getKey().getClass().getName());\n        resultE.setAttribute(\"value\", entry.getValue());\n        resultsE.appendChild(resultE);\n      }\n    }\n    modelE.appendChild(resultsE);\n\n    Element reportsE = document.createElement(\"reports\");\n    for (Map.Entry<Class, String> entry : reportMap.entrySet()) {\n      if (entry.getValue() != null && !entry.getValue().isEmpty()) {\n        Element reportE = document.createElement(\"report\");\n        reportE.setAttribute(\"class\", entry.getKey().getName());\n        reportE.setAttribute(\"value\", entry.getValue());\n        resultsE.appendChild(reportE);\n      }\n    }\n    modelE.appendChild(reportsE);\n\n    return modelE;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 240,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 227,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643117681019,
            "program": "  public void setPermissions(final List<String> permissions) {\n    final List<String> perms = Lists.newArrayList(permissions);\n    // Do not store the dynamic user self edit permissions\n    perms.removeAll(this.permissions.userSelfEditPermissions(getName()));\n    fields.put(PERMISSIONS, permissions);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 52,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 217,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 26,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643117769132,
            "program": "  public static int indexOf(String source, int ch, int origFromIndex) {\n    int fromIndex = origFromIndex;\n    final int sourceCount = source.length();\n    if (fromIndex >= sourceCount) {\n      // Note: fromIndex might be near -1>>>1.\n      return -1;\n    }\n    if (fromIndex < 0) {\n      fromIndex = 0;\n    }\n\n    if (ch < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n      char[] sourceArray = StringSubstitutions.getValue(source);\n\n      Pointer sourcePointer =\n          Word.objectToTrackedPointer(sourceArray)\n              .add(charArrayBaseOffset(INJECTED))\n              .add(fromIndex * charArrayIndexScale(INJECTED));\n      int result =\n          AMD64ArrayIndexOfNode.optimizedArrayIndexOf(\n              sourcePointer, sourceCount - fromIndex, (char) ch, JavaKind.Char);\n      if (result != -1) {\n        return result + fromIndex;\n      }\n      return result;\n    } else {\n      return indexOf(source, ch, fromIndex);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 158,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 222,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643117871524,
            "program": "  private Template generateScaffoldedTemplate(\n      GrailsWebRequest webRequest, String templateName, String uri) throws IOException {\n    Template t = null;\n    Collection<String> controllerActions = scaffoldedActionMap.get(webRequest.getControllerName());\n    if (controllerActions != null && controllerActions.contains(webRequest.getActionName())) {\n      GrailsDomainClass domainClass =\n          controllerToScaffoldedDomainClassMap.get(webRequest.getControllerName());\n      if (domainClass != null) {\n        int i = uri.lastIndexOf('/');\n        String scaffoldedtemplateName = i > -1 ? uri.substring(i) : uri;\n        if (scaffoldedtemplateName.toLowerCase().endsWith(\".gsp\")) {\n          scaffoldedtemplateName =\n              scaffoldedtemplateName.substring(0, scaffoldedtemplateName.length() - 4);\n        }\n        FastStringWriter sw = new FastStringWriter();\n        ReflectionUtils.invokeMethod(\n            generateViewMethod,\n            scaffoldingTemplateGenerator,\n            domainClass,\n            scaffoldedtemplateName,\n            sw);\n        t = groovyPagesTemplateEngine.createTemplate(sw.toString(), uri);\n      }\n    }\n    return t;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 180,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 193,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643117927769,
            "program": "  public ObjectName getObjectName(RouteContext routeContext, ProcessorType processor)\n      throws MalformedObjectNameException {\n    Endpoint<? extends Exchange> ep = routeContext.getEndpoint();\n    String ctxid = ep != null ? getContextId(ep.getCamelContext()) : VALUE_UNKNOWN;\n    String cid = getComponentId(ep);\n    String id = VALUE_UNKNOWN.equals(cid) ? getEndpointId(ep) : \"[\" + cid + \"]\" + getEndpointId(ep);\n    String nodeId = processor.idOrCreate();\n\n    StringBuffer buffer = new StringBuffer();\n    buffer.append(domainName).append(\":\");\n    buffer.append(KEY_CONTEXT + \"=\").append(ctxid).append(\",\");\n    buffer.append(KEY_ROUTE + \"=\").append(id).append(\",\");\n    buffer.append(KEY_TYPE + \"=\" + TYPE_PROCESSOR + \",\");\n    buffer.append(KEY_NODE_ID + \"=\").append(nodeId).append(\",\");\n    buffer.append(KEY_NAME + \"=\").append(ObjectName.quote(processor.toString()));\n    return createObjectName(buffer);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 208,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 201,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643117980445,
            "program": "  private <T extends Metric> T register(String name, MetricRegistrar<T> registrar) {\n    Reservoir reservoir = this.reservoirFactory.getReservoir(name);\n    if (reservoir == null) {\n      return registrar.register(this.registry, name);\n    }\n    Metric metric = this.registry.getMetrics().get(name);\n    if (metric != null) {\n      registrar.checkExisting(metric);\n      return (T) metric;\n    }\n    try {\n      return this.registry.register(name, registrar.createForReservoir(reservoir));\n    } catch (IllegalArgumentException ex) {\n      Metric added = this.registry.getMetrics().get(name);\n      registrar.checkExisting(added);\n      return (T) added;\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 145,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "486178672-1643134695903": [
        {
            "ProgrammID": 171,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643135406870,
            "program": "  private void scanOverrides(Path overrideDirectory, Path basePath) {\n    try {\n      for (Path child : Files.newDirectoryStream(overrideDirectory)) {\n        if (Files.isDirectory(child)) {\n          scanOverrides(child, basePath);\n        } else if (Files.isRegularFile(child)) {\n          Path relativePath = basePath.relativize(child);\n          Path modulePath = relativePath.subpath(0, 1);\n          AssetUri uri = getUri(modulePath.toString(), modulePath.relativize(relativePath));\n          if (uri != null) {\n            try {\n              addOverride(uri, child.toUri().toURL());\n            } catch (MalformedURLException e) {\n              logger.warn(\"Failed to load override {}\", child, e.getMessage());\n            }\n          }\n        }\n      }\n    } catch (IOException e) {\n      logger.error(\"Failed to scan override path: {}\", overrideDirectory, e);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 166,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 160,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643135454649,
            "program": "  public void updateKBArticlePriority(KBArticle kbArticle, double priority)\n      throws PortalException, SystemException {\n\n    List<KBArticle> kbArticleVersions =\n        getKBArticleVersions(\n            kbArticle.getResourcePrimKey(),\n            WorkflowConstants.STATUS_ANY,\n            QueryUtil.ALL_POS,\n            QueryUtil.ALL_POS,\n            null);\n\n    for (KBArticle kbArticleVersion : kbArticleVersions) {\n      kbArticleVersion.setPriority(priority);\n\n      kbArticlePersistence.update(kbArticleVersion);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 68,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 226,
            "lineNumberOfError": 24,
            "attempt": 1,
            "expectedAnswer": 24,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643135518098,
            "program": "  public void testMethodAnnotationsWrapper()\n      throws IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n    WrapperProxetta proxetta =\n        WrapperProxetta.withAspects(\n            new ProxyAspect(\n                HeroProxyAdvice.class,\n                new AllRealMethodsPointcut() {\n                  @Override\n                  public boolean apply(MethodInfo methodInfo) {\n                    if (!methodInfo.isTopLevelMethod()) {\n                      return false;\n                    }\n                    return super.apply(methodInfo);\n                  }\n                }))\n        // .setDebugFolder(\"/Users/igor/\")\n        ;\n\n    WrapperProxettaBuilder proxettaBuilder = proxetta.builder();\n    proxettaBuilder.setTarget(Hero.class);\n    proxetta.setVariableClassName(true);\n    Object hero = proxettaBuilder.newInstance();\n\n    Method nameMethod = hero.getClass().getMethod(\"name\");\n    assertEquals(\"BatmanHero37W88.3CatWoman99speeeeedXRAYnull\", nameMethod.invoke(nameMethod));\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 129,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 219,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643135699799,
            "program": "  public static Throwable unwrapCause(Throwable t) {\n    int counter = 0;\n    Throwable result = t;\n    while (result instanceof ElasticSearchWrapperException) {\n      if (t.getCause() == null) {\n        return result;\n      }\n      if (t.getCause() == t) {\n        return result;\n      }\n      if (counter++ > 10) {\n        // dear god, if we got more than 10 levels down, WTF? just bail\n        logger.warn(\"Exception cause unwrapping ran for 10 levels...\", t);\n        return result;\n      }\n      result = t.getCause();\n    }\n    return result;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 90,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 177,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643135768523,
            "program": "  public void addNameForObject(Object objectToName, String lang, String name) {\n    String objectName;\n    if (objectToName instanceof Item) {\n      objectName = ((Item) objectToName).func_77658_a();\n    } else if (objectToName instanceof Block) {\n      objectName = ((Block) objectToName).func_71917_a();\n    } else if (objectToName instanceof ItemStack) {\n      objectName = ((ItemStack) objectToName).func_77973_b().func_77667_c((ItemStack) objectToName);\n    } else {\n      throw new IllegalArgumentException(\n          String.format(\"Illegal object for naming %s\", objectToName));\n    }\n    objectName += \".name\";\n    addStringLocalization(lang, lang, name);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 121,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 161,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643135894551,
            "program": "  protected void handleRefCursorOutputParameter(\r\n      CallableStatement cs,\r\n      ParameterMapping parameterMapping,\r\n      int parameterMappingIndex,\r\n      MetaObject metaParam)\r\n      throws SQLException {\r\n    final ResultSet rs = (ResultSet) cs.getObject(parameterMappingIndex + 1);\r\n    final String resultMapId = parameterMapping.getResultMapId();\r\n    if (resultMapId != null) {\r\n      final ResultMap resultMap = configuration.getResultMap(resultMapId);\r\n      final DefaultResultHandler resultHandler =\r\n          new DefaultResultHandler(configuration.getDefaultListResultHandlerType());\r\n      ResultColumnCache resultColumnCache = new ResultColumnCache(rs.getMetaData(), configuration);\r\n      handleRowValues(rs, resultMap, resultHandler, new RowBounds(), resultColumnCache);\r\n      metaParam.setValue(parameterMapping.getProperty(), resultHandler.getResultList());\r\n    } else {\r\n      throw new ExecutorException(\r\n          \"Parameter requires ResultMap for output types of java.sql.ResultSet\");\r\n    }\r\n    rs.close();\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 143,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 166,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643135991552,
            "program": "  public static CharArraySet parseStopWords(\n      Environment env,\n      Settings settings,\n      CharArraySet defaultStopWords,\n      Version version,\n      boolean ignore_case) {\n    String value = settings.get(\"stopwords\");\n    if (value != null) {\n      if (\"_none_\".equals(value)) {\n        return CharArraySet.EMPTY_SET;\n      } else {\n        return resolveNamedStopWords(Strings.commaDelimitedListToSet(value), version, ignore_case);\n      }\n    }\n    String[] stopWords = settings.getAsArray(\"stopwords\", null);\n    if (stopWords != null) {\n      return resolveNamedStopWords(stopWords, version, ignore_case);\n    }\n    List<String> pathLoadedStopWords = getWordList(env, settings, \"stopwords\");\n    if (pathLoadedStopWords != null) {\n      return resolveNamedStopWords(pathLoadedStopWords, version, ignore_case);\n    }\n\n    return defaultStopWords;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 142,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 212,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643136155188,
            "program": "  public static Block createLongDictionaryBlock(int start, int length) {\n    int dictionarySize = length / 5;\n    BlockBuilder builder = BIGINT.createBlockBuilder(new BlockBuilderStatus(), dictionarySize);\n    for (int i = start; i < dictionarySize; i++) {\n      BIGINT.writeLong(builder, i);\n    }\n    int[] ids = new int[length];\n    for (int i = 0; i < length; i++) {\n      ids[i] = i % dictionarySize;\n    }\n    return new DictionaryBlock(length, builder.build(), wrappedIntArray(ids));\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 114,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        }
    ],
    "212406027-1643142832312": [
        {
            "ProgrammID": 183,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643143644115,
            "program": "  void updateRulesForTempWhitelistChangeLocked() {\n    final List<UserInfo> users = mUserManager.getUsers();\n    for (int i = 0; i < users.size(); i++) {\n      final UserInfo user = users.get(i);\n      for (int j = mPowerSaveTempWhitelistAppIds.size() - 1; j >= 0; j--) {\n        int appId = mPowerSaveTempWhitelistAppIds.keyAt(j);\n        int uid = UserHandle.getUid(user.id, appId);\n        updateRuleForAppIdleLocked(uid);\n        updateRuleForDeviceIdleLocked(uid);\n        updateRulesForRestrictPowerLocked(uid);\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,review,develop",
            "token": 111,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 204,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643143739299,
            "program": "  static ErrorProneAnalyzer createAnalyzer(\n      ScannerSupplier scannerSupplier,\n      ErrorProneOptions epOptions,\n      Context context,\n      RefactoringCollection[] refactoringCollection) {\n    if (!epOptions.patchingOptions().doRefactor()) {\n      return ErrorProneAnalyzer.createByScanningForPlugins(scannerSupplier, epOptions, context);\n    }\n    refactoringCollection[0] = RefactoringCollection.refactor(epOptions.patchingOptions());\n\n    // Refaster refactorer or using builtin checks\n    CodeTransformer codeTransformer =\n        epOptions\n            .patchingOptions()\n            .customRefactorer()\n            .or(\n                () -> {\n                  ScannerSupplier toUse = ErrorPronePlugins.loadPlugins(scannerSupplier, context);\n                  Set<String> namedCheckers = epOptions.patchingOptions().namedCheckers();\n                  if (!namedCheckers.isEmpty()) {\n                    toUse = toUse.filter(bci -> namedCheckers.contains(bci.canonicalName()));\n                  }\n                  return ErrorProneScannerTransformer.create(toUse.applyOverrides(epOptions).get());\n                })\n            .get();\n\n    return ErrorProneAnalyzer.createWithCustomDescriptionListener(\n        codeTransformer, epOptions, context, refactoringCollection[0]);\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,review,develop",
            "token": 182,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 197,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643143890168,
            "program": "  public static Icon getIcon(File file) {\n    Icon fileIcon = null;\n\n    try {\n      sun.awt.shell.ShellFolder shellFolder = sun.awt.shell.ShellFolder.getShellFolder(file);\n\n      fileIcon = new ImageIcon(shellFolder.getIcon(true), shellFolder.getFolderType());\n    } catch (Exception e) {\n      logger.debug(\"Failed to obtain file icon from ShellFolder.\", e);\n      try {\n        fileIcon = new JFileChooser().getIcon(file);\n      } catch (Exception e1) {\n        logger.debug(\"Failed to obtain file icon from JFileChooser.\", e1);\n      }\n    }\n\n    return fileIcon;\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,review,develop",
            "token": 109,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 162,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643144051761,
            "program": "  public void importResources(File file) {\n    if (file.exists()) {\n      File[] files = file.listFiles();\n      if (files != null) {\n        for (File f : files) {\n          if (!file.isHidden()) {\n            importResources(f);\n          }\n        }\n      } else {\n        try {\n          URL url = file.toURI().toURL();\n          String parserType = getParserType(url);\n          importFile(parserType, url);\n        } catch (MalformedURLException e) {\n          // can't happen for the 'file' protocol handler with a correctly formatted URI\n          logger.debug(\"Can't create a URL\", e);\n        }\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,review,develop",
            "token": 113,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 173,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643144170732,
            "program": "  private static boolean shouldBeGenerated(PsiMethod method) {\n    for (PsiMethod psiMethod : method.findSuperMethods()) {\n      if (!psiMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        final PsiType type = method.getReturnType();\n        final PsiType superType = psiMethod.getReturnType();\n        if (type != null && superType != null && !superType.isAssignableFrom(type)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,review,develop",
            "token": 83,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 182,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643144425837,
            "program": "  private boolean getStringToReplace(\n      int textOffset,\n      int textEndOffset,\n      Document document,\n      FindModel findModel,\n      Ref<String> stringToReplace)\n      throws FindManager.MalformedReplacementStringException {\n    if (textOffset < 0 || textOffset >= document.getTextLength()) {\n      return false;\n    }\n    if (textEndOffset < 0 || textOffset > document.getTextLength()) {\n      return false;\n    }\n    FindManager findManager = FindManager.getInstance(myProject);\n    final CharSequence foundString =\n        document.getCharsSequence().subSequence(textOffset, textEndOffset);\n    PsiFile file = PsiDocumentManager.getInstance(myProject).getPsiFile(document);\n    FindResult findResult =\n        findManager.findString(\n            document.getCharsSequence(),\n            textOffset,\n            findModel,\n            file != null ? file.getVirtualFile() : null);\n    if (!findResult.isStringFound()\n        ||\n        // find result should be in needed range\n        !(findResult.getStartOffset() >= textOffset\n            && findResult.getEndOffset() <= textEndOffset)) {\n      return false;\n    }\n\n    stringToReplace.set(\n        FindManager.getInstance(myProject)\n            .getStringToReplace(foundString.toString(), findModel, textOffset, document.getText()));\n\n    return true;\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,review,develop",
            "token": 205,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 184,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643144602188,
            "program": "  public static String addPrefixIfNot(CharSequence str, CharSequence prefix) {\r\n    if (isEmpty(str) || isEmpty(prefix)) {\r\n      return str.toString();\r\n    }\r\n\r\n    final String str2 = str.toString();\r\n    final String prefix2 = prefix.toString();\r\n    if (false == str2.startsWith(prefix2)) {\r\n      return prefix2 + str2;\r\n    }\r\n    return prefix2;\r\n  }\r\n",
            "exp": "5",
            "age": "50",
            "task": "test,review,develop",
            "token": 75,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 205,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643144794002,
            "program": "  protected int putCodeWScope(String name, CodeWScope code) {\n    final int start = _buf.position();\n    _put(CODE_W_SCOPE, name);\n    int temp = _buf.position();\n    _buf.putInt(0);\n    _putValueString(code._code);\n    putObject(code._scope);\n    _buf.putInt(temp, _buf.position() - start);\n    return _buf.position() - start;\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,review,develop",
            "token": 83,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1895149314-1643144674514": [
        {
            "ProgrammID": 169,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643145208903,
            "program": "  public static String getGoExecutablePath(@Nullable String sdkHomePath) {\n    if (sdkHomePath != null) {\n      if (isAppEngineSdkPath(sdkHomePath)) {\n        String goExecutablePath = PathUtil.toSystemIndependentName(sdkHomePath);\n        goExecutablePath =\n            StringUtil.trimEnd(goExecutablePath, GoConstants.APP_ENGINE_GO_ROOT_DIRECTORY_PATH);\n\n        boolean gcloudInstallation =\n            sdkHomePath.endsWith(GoConstants.GCLOUD_APP_ENGINE_DIRECTORY_PATH);\n        if (gcloudInstallation) {\n          goExecutablePath =\n              FileUtil.join(\n                  StringUtil.trimEnd(\n                      goExecutablePath, GoConstants.GCLOUD_APP_ENGINE_DIRECTORY_PATH),\n                  \"bin\");\n        }\n        return FileUtil.join(\n            goExecutablePath, GoEnvironmentUtil.getGaeExecutableFileName(gcloudInstallation));\n      } else {\n        return FileUtil.join(\n            sdkHomePath,\n            \"bin\",\n            GoEnvironmentUtil.getBinaryFileNameForPath(GoConstants.GO_EXECUTABLE_NAME));\n      }\n    }\n    return null;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 130,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 233,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643145257314,
            "program": "  public Alarm saveAlarm(@RequestBody Alarm alarm) throws ThingsboardException {\n    try {\n      alarm.setTenantId(getCurrentUser().getTenantId());\n      Alarm savedAlarm = checkNotNull(alarmService.createOrUpdateAlarm(alarm));\n      logEntityAction(\n          savedAlarm.getId(),\n          savedAlarm,\n          getCurrentUser().getCustomerId(),\n          alarm.getId() == null ? ActionType.ADDED : ActionType.UPDATED,\n          null);\n      return savedAlarm;\n    } catch (Exception e) {\n      logEntityAction(\n          emptyId(EntityType.ALARM),\n          alarm,\n          null,\n          alarm.getId() == null ? ActionType.ADDED : ActionType.UPDATED,\n          e);\n      throw handleException(e);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 127,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 207,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 18,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643145350303,
            "program": "  private void handleSecurityPermission(final org.w3c.dom.Node node, PermissionType type)\n      throws Exception {\n    final SecurityConfig cfg = config.getSecurityConfig();\n    final NamedNodeMap attrs = node.getAttributes();\n\n    Node nameNode = attrs.getNamedItem(\"name\");\n    String name = nameNode != null ? getTextContent(nameNode) : \"*\";\n    Node principalNode = attrs.getNamedItem(\"principal\");\n    String principal = principalNode != null ? getTextContent(principalNode) : \"*\";\n\n    final PermissionConfig permConfig = new PermissionConfig(type, name, principal);\n    cfg.addClientPermissionConfig(permConfig);\n\n    for (org.w3c.dom.Node child : new IterableNodeList(node.getChildNodes())) {\n      final String nodeName = cleanNodeName(child.getNodeName());\n      if (\"endpoints\".equals(nodeName)) {\n        handleSecurityPermissionEndpoints(principalNode, permConfig);\n      } else if (\"actions\".equals(nodeName)) {\n        handleSecurityPermissionActions(principalNode, permConfig);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 183,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 185,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643145387656,
            "program": "  public Window destroyActivity(String id, boolean finish) {\n    LocalActivityRecord r = mActivities.get(id);\n    Window win = null;\n    if (r != null) {\n      win = performDestroy(r, finish);\n      if (finish) {\n        mActivities.remove(r);\n      }\n    }\n    return win;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 60,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 202,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643145506097,
            "program": "  private Object[] buildParamList(Functor func, int indexOfParamToSetToNull) {\n    Class<?>[] types = func.getParameterTypes();\n    Object[] params = new Object[types.length];\n\n    for (int i = 0; i < types.length; i++) {\n      if (i != indexOfParamToSetToNull) {\n        params[i] = defaults.get(types[i]);\n        if (!parameterIsPrimitiveOrNullable(func, i)) {\n          Assert.assertTrue(\"No default value found for \" + types[i].getName(), params[i] != null);\n        }\n      }\n    }\n    return params;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 120,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 206,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643145572164,
            "program": "  private TextClassification createClassificationResult(\n      SmartSelection.ClassificationResult[] classifications, String text, int start, int end) {\n    final String classifiedText = text.substring(start, end);\n    final TextClassification.Builder builder =\n        new TextClassification.Builder().setText(classifiedText);\n\n    final int size = classifications.length;\n    for (int i = 0; i < size; i++) {\n      builder.setEntityType(classifications[i].mCollection, classifications[i].mScore);\n    }\n\n    final String type = getHighestScoringType(classifications);\n    addActions(builder, IntentFactory.create(mContext, type, text));\n\n    return builder.setSignature(getSignature(text, start, end)).build();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 140,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 221,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643145636198,
            "program": "  private void pollFilter(EthFilter ethFilter) {\n    EthLog ethLog = null;\n    try {\n      ethLog = web3j.ethGetFilterChanges(filterId).send();\n    } catch (IOException e) {\n      throwException(e);\n    }\n    if (ethLog.hasError()) {\n      throwException(ethFilter.getError());\n    } else {\n      process(ethLog.getLogs());\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 73,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 236,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643145693552,
            "program": "  public boolean dispatchTouchEvent(MotionEvent ev) {\n    if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n      if (!mTouchEnabled) {\n        mTouchCancelled = true;\n        return false;\n      }\n      mTouchCancelled = false;\n    } else if (mTouchCancelled) {\n      return false;\n    } else if (!mTouchEnabled) {\n      MotionEvent cancel = MotionEvent.obtain(ev);\n      cancel.setAction(MotionEvent.ACTION_CANCEL);\n      super.dispatchTouchEvent(cancel);\n      cancel.recycle();\n      mTouchCancelled = true;\n      return false;\n    }\n    return super.dispatchTouchEvent(ev);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 106,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        }
    ],
    "780890093-1643178429302": [
        {
            "ProgrammID": 208,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643178779309,
            "program": "  private boolean matches(EndpointReferenceType ref, W3CEndpointReference r) {\n    EndpointReferenceType cref = ProviderImpl.convertToInternal(r);\n    QName snr = EndpointReferenceUtils.getServiceName(ref, bus);\n    QName snc = EndpointReferenceUtils.getServiceName(cref, bus);\n    String addr = EndpointReferenceUtils.getAddress(ref);\n    String addc = EndpointReferenceUtils.getAddress(ref);\n\n    if (addr == null) {\n      return false;\n    }\n    if (addr.equals(addc)) {\n      if (snr != null && !snr.equals(snc)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 113,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 192,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643178870096,
            "program": "  static void registerTransformers(SubsystemRegistration subsystem) {\n    ResourceTransformationDescriptionBuilder builder110 =\n        TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n    ResourceAdapterResourceDefinition.registerTransformers110(builder110);\n    TransformationDescription.Tools.register(\n        builder110.build(), subsystem, ModelVersion.create(1, 1, 0));\n    ResourceTransformationDescriptionBuilder builder120 =\n        TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n    ResourceAdapterResourceDefinition.registerTransformers120(builder120);\n    TransformationDescription.Tools.register(\n        builder120.build(), subsystem, ModelVersion.create(1, 2, 0));\n    // Apply same to RBAC-updated version\n    TransformationDescription.Tools.register(\n        builder120.build(), subsystem, ModelVersion.create(1, 3, 0));\n    ResourceTransformationDescriptionBuilder builder200 =\n        TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n    ResourceAdapterResourceDefinition.registerTransformers200(builder200);\n    TransformationDescription.Tools.register(\n        builder200.build(), subsystem, ModelVersion.create(2, 0, 0));\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 167,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 188,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643178929515,
            "program": "  private boolean isSunUpAllDay(Calendar calendar, double latitude, double longitude) {\n    Calendar cal = DateTimeUtils.truncateToMidnight(calendar);\n    Sun sun = new Sun();\n    for (int minutes = 0; minutes <= MINUTES_PER_DAY; minutes += CURVE_TIME_INTERVAL) {\n      setSunPosition(cal, latitude, longitude, sun);\n      if (sun.getPosition().getElevation() < SUN_ANGLE) {\n        return false;\n      }\n      cal.add(Calendar.MINUTE, CURVE_TIME_INTERVAL);\n    }\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 94,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 181,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643179070424,
            "program": "  public void centerOnGraph() {\n    float graphWidth = Math.abs(limits.getMaxXoctree() - limits.getMinXoctree());\n    float graphHeight = Math.abs(limits.getMaxYoctree() - limits.getMinYoctree());\n\n    float currentDistanceGraphRatioX =\n        Math.abs(graphDrawable.viewport.get(2) / (float) graphDrawable.getDraggingMarkerX())\n            / graphDrawable.cameraLocation[2];\n    float currentDistanceGraphRatioY =\n        Math.abs(graphDrawable.viewport.get(3) / (float) graphDrawable.getDraggingMarkerY())\n            / graphDrawable.cameraLocation[2];\n    float newCameraLocationX = graphWidth / currentDistanceGraphRatioX;\n    float newCameraLocationY = graphHeight / currentDistanceGraphRatioY;\n    float newCameraLocation = Math.max(newCameraLocationX, newCameraLocationY);\n\n    graphDrawable.cameraLocation[0] = limits.getMinXoctree() + graphWidth / 2;\n    graphDrawable.cameraLocation[1] = limits.getMinYoctree() + graphHeight / 2;\n    graphDrawable.cameraLocation[2] = newCameraLocation;\n\n    graphDrawable.cameraTarget[0] = graphDrawable.cameraLocation[0];\n    graphDrawable.cameraTarget[1] = graphDrawable.cameraLocation[1];\n    graphDrawable.cameraTarget[2] = 0;\n\n    // Refresh\n    engine.getScheduler().requireUpdateVisible();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 229,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 209,
            "lineNumberOfError": 20,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643179199561,
            "program": "  public <K extends ActionResponse> K execute(ActionRequestBuilder request) {\n    StopWatch fullProfile = profiling.start(\"search\", Profiling.Level.FULL);\n    K response = null;\n    try {\n\n      response = (K) request.get();\n\n      if (profiling.isProfilingEnabled(Profiling.Level.BASIC)) {\n        if (ToXContent.class.isAssignableFrom(request.getClass())) {\n          XContentBuilder debugResponse = XContentFactory.jsonBuilder();\n          debugResponse.startObject();\n          ((ToXContent) request).toXContent(debugResponse, ToXContent.EMPTY_PARAMS);\n          debugResponse.endObject();\n          fullProfile.stop(\"ES Request: %s\", debugResponse.string());\n        } else {\n          fullProfile.stop(\"ES Request: %s\", request.toString().replaceAll(\"\\n\", \"\"));\n        }\n      }\n      return response;\n    } catch (Exception e) {\n      LOGGER.error(\"could not execute request: \" + request, e);\n      throw new IllegalStateException(\"ES error: \", e);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 184,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 238,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643179289324,
            "program": "  public static Cache initializeCache(\n      String name, String propertiesName, int size, long expirationTime) {\n    Cache cache = caches.get(name);\n    if (cache == null) {\n      size = JiveGlobals.getIntProperty(\"cache.\" + name + \".size\", size);\n      expirationTime =\n          (long)\n              JiveGlobals.getIntProperty(\n                  \"cache.\" + propertiesName + \".expirationTime\", (int) expirationTime);\n      cache = new Cache(name, size, expirationTime);\n      caches.put(name, cache);\n    }\n    return cache;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 97,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 210,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643179336642,
            "program": "  private KadaneResult kadane(int arr[]) {\n    int max = 0;\n    int maxStart = -1;\n    int maxEnd = -1;\n    int currentStart = 0;\n    int maxSoFar = 0;\n    for (int i = 0; i < arr.length; i++) {\n      maxSoFar += arr[i];\n      if (maxSoFar < 0) {\n        maxSoFar = 0;\n        currentStart = i + 1;\n      }\n      if (max < maxSoFar) {\n        maxStart = currentStart;\n        maxEnd = i;\n        max = maxSoFar;\n      }\n    }\n    return new KadaneResult(max, maxStart, maxEnd);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 112,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 164,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643179404012,
            "program": "  public void onPackageChange(String packageName) {\n    if (mFacetPackageMap.containsKey(packageName)) {\n      int index = mFacetPackageMap.get(packageName);\n      mFacetHasMultipleAppsCache.put(index, facetHasMultiplePackages(index));\n      // No need to check categories because we've already refreshed the cache.\n      return;\n    }\n\n    String category = getPackageCategory(packageName);\n    if (mFacetCategoryMap.containsKey(category)) {\n      int index = mFacetCategoryMap.get(packageName);\n      mFacetHasMultipleAppsCache.put(index, facetHasMultiplePackages(index));\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 85,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "52095155-1643191520237": [
        {
            "ProgrammID": 186,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643192319207,
            "program": "  public static void const2stack(\n      CompilationResultBuilder crb,\n      SPARCMacroAssembler masm,\n      Value result,\n      Register constantTableBase,\n      Value input,\n      SPARCDelayedControlTransfer delaySlotLir,\n      JavaConstant constant) {\n    if (constant.isDefaultForKind() || constant.isNull()) {\n      SPARCAddress resultAddress = (SPARCAddress) crb.asAddress(result);\n      emitStore(\n          g0.asValue(LIRKind.combine(input)),\n          resultAddress,\n          result.getPlatformKind(),\n          delaySlotLir,\n          null,\n          crb,\n          masm);\n    } else {\n      try (ScratchRegister sc = masm.getScratchRegister()) {\n        Value scratchRegisterValue = sc.getRegister().asValue(LIRKind.combine(constant));\n        const2reg(\n            crb,\n            masm,\n            scratchRegisterValue,\n            constantTableBase,\n            constant,\n            SPARCDelayedControlTransfer.DUMMY);\n        SPARCAddress resultAddress = (SPARCAddress) crb.asAddress(result);\n        emitStore(\n            scratchRegisterValue,\n            resultAddress,\n            result.getPlatformKind(),\n            delaySlotLir,\n            null,\n            crb,\n            masm);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 174,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 227,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643192388586,
            "program": "  public void setPermissions(final List<String> permissions) {\n    final List<String> perms = Lists.newArrayList(permissions);\n    // Do not store the dynamic user self edit permissions\n    perms.removeAll(this.permissions.userSelfEditPermissions(getName()));\n    fields.put(PERMISSIONS, permissions);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 52,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 219,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643192596429,
            "program": "  public static Throwable unwrapCause(Throwable t) {\n    int counter = 0;\n    Throwable result = t;\n    while (result instanceof ElasticSearchWrapperException) {\n      if (t.getCause() == null) {\n        return result;\n      }\n      if (t.getCause() == t) {\n        return result;\n      }\n      if (counter++ > 10) {\n        // dear god, if we got more than 10 levels down, WTF? just bail\n        logger.warn(\"Exception cause unwrapping ran for 10 levels...\", t);\n        return result;\n      }\n      result = t.getCause();\n    }\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 90,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 201,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643192703076,
            "program": "  private <T extends Metric> T register(String name, MetricRegistrar<T> registrar) {\n    Reservoir reservoir = this.reservoirFactory.getReservoir(name);\n    if (reservoir == null) {\n      return registrar.register(this.registry, name);\n    }\n    Metric metric = this.registry.getMetrics().get(name);\n    if (metric != null) {\n      registrar.checkExisting(metric);\n      return (T) metric;\n    }\n    try {\n      return this.registry.register(name, registrar.createForReservoir(reservoir));\n    } catch (IllegalArgumentException ex) {\n      Metric added = this.registry.getMetrics().get(name);\n      registrar.checkExisting(added);\n      return (T) added;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 145,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 236,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643192873206,
            "program": "  public boolean dispatchTouchEvent(MotionEvent ev) {\n    if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n      if (!mTouchEnabled) {\n        mTouchCancelled = true;\n        return false;\n      }\n      mTouchCancelled = false;\n    } else if (mTouchCancelled) {\n      return false;\n    } else if (!mTouchEnabled) {\n      MotionEvent cancel = MotionEvent.obtain(ev);\n      cancel.setAction(MotionEvent.ACTION_CANCEL);\n      super.dispatchTouchEvent(cancel);\n      cancel.recycle();\n      mTouchCancelled = true;\n      return false;\n    }\n    return super.dispatchTouchEvent(ev);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 106,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 225,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643193030865,
            "program": "  public Object resource() {\n    KeycloakIdentity identity = createIdentity(true);\n    ResourceServer resourceServer = getResourceServer(identity);\n    RealmModel realm = authorization.getRealm();\n    ClientModel client = realm.getClientById(resourceServer.getId());\n    KeycloakSession keycloakSession = authorization.getKeycloakSession();\n    UserModel serviceAccount = keycloakSession.users().getServiceAccount(client);\n    AdminEventBuilder adminEvent =\n        new AdminEventBuilder(\n            realm,\n            new AdminAuth(realm, identity.getAccessToken(), serviceAccount, client),\n            keycloakSession,\n            clientConnection);\n    ResourceSetService resourceManager =\n        new ResourceSetService(\n            resourceServer,\n            this.authorization,\n            null,\n            adminEvent.realm(realm).authClient(client).authUser(serviceAccount));\n\n    ResteasyProviderFactory.getInstance().injectProperties(resourceManager);\n\n    ResourceService resource = new ResourceService(resourceServer, identity, resourceManager);\n\n    ResteasyProviderFactory.getInstance().injectProperties(resource);\n\n    return resource;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 168,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 239,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643193082429,
            "program": "  public void addStream(String meetingId, VideoStream vs) {\r\n    Meeting m = meetings.get(meetingId);\r\n    if (m != null) {\r\n      m.addStream(vs);\r\n    } else {\r\n      Meeting nm = new Meeting(meetingId);\r\n      nm.addStream(vs);\r\n      add(m);\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 61,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 237,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643193267669,
            "program": "  private void drawAnnotation(\n      Canvas canvas, LineStyle style, LinePoint linePoint, float rawValueX, float rawValueY) {\n    final ChartCalculator chartCalculator = mChart.getChartCalculator();\n    final float offset = Utils.dp2px(mContext, style.getPointRadius());\n    final String text = style.getLineValueFormatter().formatValue(linePoint);\n    annotationPaint.setTextSize(Utils.sp2px(mContext, style.getTextSize()));\n    annotationPaint.getTextBounds(text, 0, text.length(), textBoundsRect);\n    float left = rawValueX - textBoundsRect.width() / 2 - mAnnotationMargin;\n    float right = rawValueX + textBoundsRect.width() / 2 + mAnnotationMargin;\n    float top = rawValueY - offset - textBoundsRect.height() - mAnnotationMargin * 2;\n    float bottom = rawValueY - offset;\n    if (top < chartCalculator.mContentRect.top) {\n      top = rawValueY + offset;\n      bottom = rawValueY + offset + textBoundsRect.height() + mAnnotationMargin * 2;\n    }\n    if (right < chartCalculator.mContentRect.left) {\n      left = rawValueX;\n      right = rawValueX + textBoundsRect.width() + mAnnotationMargin * 2;\n    }\n    if (right > chartCalculator.mContentRect.right) {\n      left = rawValueX - textBoundsRect.width() - mAnnotationMargin * 2;\n      right = rawValueX;\n    }\n    annotationRect.set(left, top, right, bottom);\n    annotationPaint.setColor(style.getColor());\n    canvas.drawRoundRect(annotationRect, mAnnotationMargin, mAnnotationMargin, annotationPaint);\n    annotationPaint.setColor(style.getTextColor());\n    canvas.drawText(text, left + mAnnotationMargin, bottom - mAnnotationMargin, annotationPaint);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 311,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        }
    ],
    "200445235-1643205127651": [
        {
            "ProgrammID": 223,
            "lineNumberOfError": 24,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643205444324,
            "program": "  private void scrollLayerTo(int x, int y) {\n    int dx = mScrollingLayerRect.left - x;\n    int dy = mScrollingLayerRect.top - y;\n    if (dx == 0 && y == 0) {\n      return;\n    }\n    if (mSelectingText) {\n      if (mSelectCursorBaseLayerId == mCurrentScrollingLayerId) {\n        mSelectCursorBase.offset(dx, dy);\n        mSelectCursorBaseTextQuad.offset(dx, dy);\n      }\n      if (mSelectCursorExtentLayerId == mCurrentScrollingLayerId) {\n        mSelectCursorExtent.offset(dx, dy);\n        mSelectCursorExtentTextQuad.offset(dx, dy);\n      }\n    }\n    if (mAutoCompletePopup != null && mCurrentScrollingLayerId == mEditTextLayerId) {\n      mEditTextBounds.offset(dx, dy);\n      mAutoCompletePopup.resetRect();\n    }\n    nativeScrollLayer(mCurrentScrollingLayerId, x, y);\n    mScrollingLayerRect.left = x;\n    mScrollingLayerRect.top = y;\n    mWebViewCore.sendMessage(\n        WebViewCore.EventHub.SCROLL_LAYER, mCurrentScrollingLayerId, mScrollingLayerRect);\n    mWebViewPrivate.onScrollChanged(getScrollX(), getScrollY(), getScrollX(), getScrollY());\n    invalidate();\n  }\n",
            "exp": "2",
            "age": "50",
            "task": "test",
            "token": 190,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 214,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643205501502,
            "program": "  public void doWithLibraries(LibraryCallback callback) throws IOException {\n\n    FileCollection compile = this.project.getConfigurations().getByName(\"compile\");\n\n    FileCollection runtime = this.project.getConfigurations().getByName(\"runtime\");\n    runtime = runtime.minus(compile);\n\n    FileCollection provided =\n        this.project.getConfigurations().findByName(this.providedConfigurationName);\n    if (provided != null) {\n      compile = compile.minus(provided);\n      runtime = compile.minus(provided);\n    }\n\n    libraries(LibraryScope.COMPILE, compile, callback);\n    libraries(LibraryScope.RUNTIME, runtime, callback);\n    libraries(LibraryScope.PROVIDED, provided, callback);\n  }\n",
            "exp": "2",
            "age": "50",
            "task": "test",
            "token": 129,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 200,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643205532039,
            "program": "  private void checkChunkReady(Vector3i pos) {\n    if (worldEntity.exists()) {\n      for (Vector3i adjPos : Region3i.createFromCenterExtents(pos, LOCAL_REGION_EXTENTS)) {\n        Chunk chunk = getChunk(pos);\n        if (chunk == null || chunk.getChunkState() != Chunk.State.COMPLETE) {\n          return;\n        }\n      }\n      worldEntity.send(new ChunkReadyEvent(pos));\n    }\n  }\n",
            "exp": "2",
            "age": "50",
            "task": "test",
            "token": 76,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 206,
            "lineNumberOfError": 14,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643205565265,
            "program": "  private TextClassification createClassificationResult(\n      SmartSelection.ClassificationResult[] classifications, String text, int start, int end) {\n    final String classifiedText = text.substring(start, end);\n    final TextClassification.Builder builder =\n        new TextClassification.Builder().setText(classifiedText);\n\n    final int size = classifications.length;\n    for (int i = 0; i < size; i++) {\n      builder.setEntityType(classifications[i].mCollection, classifications[i].mScore);\n    }\n\n    final String type = getHighestScoringType(classifications);\n    addActions(builder, IntentFactory.create(mContext, type, text));\n\n    return builder.setSignature(getSignature(text, start, end)).build();\n  }\n",
            "exp": "2",
            "age": "50",
            "task": "test",
            "token": 140,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 164,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643205634705,
            "program": "  public void onPackageChange(String packageName) {\n    if (mFacetPackageMap.containsKey(packageName)) {\n      int index = mFacetPackageMap.get(packageName);\n      mFacetHasMultipleAppsCache.put(index, facetHasMultiplePackages(index));\n      // No need to check categories because we've already refreshed the cache.\n      return;\n    }\n\n    String category = getPackageCategory(packageName);\n    if (mFacetCategoryMap.containsKey(category)) {\n      int index = mFacetCategoryMap.get(packageName);\n      mFacetHasMultipleAppsCache.put(index, facetHasMultiplePackages(index));\n    }\n  }\n",
            "exp": "2",
            "age": "50",
            "task": "test",
            "token": 85,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 166,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643205662285,
            "program": "  public static CharArraySet parseStopWords(\n      Environment env,\n      Settings settings,\n      CharArraySet defaultStopWords,\n      Version version,\n      boolean ignore_case) {\n    String value = settings.get(\"stopwords\");\n    if (value != null) {\n      if (\"_none_\".equals(value)) {\n        return CharArraySet.EMPTY_SET;\n      } else {\n        return resolveNamedStopWords(Strings.commaDelimitedListToSet(value), version, ignore_case);\n      }\n    }\n    String[] stopWords = settings.getAsArray(\"stopwords\", null);\n    if (stopWords != null) {\n      return resolveNamedStopWords(stopWords, version, ignore_case);\n    }\n    List<String> pathLoadedStopWords = getWordList(env, settings, \"stopwords\");\n    if (pathLoadedStopWords != null) {\n      return resolveNamedStopWords(pathLoadedStopWords, version, ignore_case);\n    }\n\n    return defaultStopWords;\n  }\n",
            "exp": "2",
            "age": "50",
            "task": "test",
            "token": 142,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 169,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643205694991,
            "program": "  public static String getGoExecutablePath(@Nullable String sdkHomePath) {\n    if (sdkHomePath != null) {\n      if (isAppEngineSdkPath(sdkHomePath)) {\n        String goExecutablePath = PathUtil.toSystemIndependentName(sdkHomePath);\n        goExecutablePath =\n            StringUtil.trimEnd(goExecutablePath, GoConstants.APP_ENGINE_GO_ROOT_DIRECTORY_PATH);\n\n        boolean gcloudInstallation =\n            sdkHomePath.endsWith(GoConstants.GCLOUD_APP_ENGINE_DIRECTORY_PATH);\n        if (gcloudInstallation) {\n          goExecutablePath =\n              FileUtil.join(\n                  StringUtil.trimEnd(\n                      goExecutablePath, GoConstants.GCLOUD_APP_ENGINE_DIRECTORY_PATH),\n                  \"bin\");\n        }\n        return FileUtil.join(\n            goExecutablePath, GoEnvironmentUtil.getGaeExecutableFileName(gcloudInstallation));\n      } else {\n        return FileUtil.join(\n            sdkHomePath,\n            \"bin\",\n            GoEnvironmentUtil.getBinaryFileNameForPath(GoConstants.GO_EXECUTABLE_NAME));\n      }\n    }\n    return null;\n  }\n",
            "exp": "2",
            "age": "50",
            "task": "test",
            "token": 130,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 235,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643205750289,
            "program": "  public AssertThat with(final String name, final Object schema) {\n    return with(\n        new OptiqAssert.ConnectionFactory() {\n          public OptiqConnection createConnection() throws Exception {\n            Class.forName(\"net.hydromatic.optiq.jdbc.Driver\");\n            Connection connection = DriverManager.getConnection(\"jdbc:optiq:\");\n            OptiqConnection optiqConnection = connection.unwrap(OptiqConnection.class);\n            MutableSchema rootSchema = optiqConnection.getRootSchema();\n            ReflectiveSchema.create(optiqConnection, rootSchema, name, schema);\n            optiqConnection.setSchema(name);\n            return optiqConnection;\n          }\n        });\n  }\n",
            "exp": "2",
            "age": "50",
            "task": "test",
            "token": 97,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1099778189-1643207664277": [
        {
            "ProgrammID": 199,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643208117527,
            "program": "  private static final Comparator<Method> METHOD_COMPARATOR =\n      new Comparator<Method>() {\n        public int compare(final Method o1, final Method o2) {\n          int cmp = o1.getName().compareTo(o2.getName());\n          if (cmp != 0) return cmp;\n          cmp = o1.getParameterTypes().length - o2.getParameterTypes().length;\n          return cmp;\n        }\n      };\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 81,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 234,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 29,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643208296592,
            "program": "  protected String retrieveFinalFormKey(\n      String formKey,\n      FlowElement flowElement,\n      Map<Long, Form> formIdMap,\n      AbstractModel model,\n      Long appDefinitionId,\n      Long appDeploymentId,\n      User user) {\n\n    String finalFormKey = null;\n    List<ExtensionElement> formIdExtensions =\n        flowElement.getExtensionElements().get(\"form-reference-id\");\n    List<ExtensionElement> formNameExtensions =\n        flowElement.getExtensionElements().get(\"form-reference-name\");\n    if (CollectionUtils.isNotEmpty(formIdExtensions)\n        && CollectionUtils.isNotEmpty(formNameExtensions)) {\n      Long formId = Long.valueOf(formIdExtensions.get(0).getElementText());\n      finalFormKey =\n          getFormKeyWithFormId(formId, formIdMap, model, appDefinitionId, appDeploymentId, user);\n\n    } else if (StringUtils.isNotEmpty(formKey) && formKey.startsWith(\"FORM_REFERENCE\")) {\n      String formIdValue = formKey.replace(\"FORM_REFERENCE\", \"\");\n      if (NumberUtils.isNumber(formIdValue)) {\n        Long formId = Long.valueOf(formIdValue);\n        finalFormKey =\n            getFormKeyWithFormId(formId, formIdMap, model, appDefinitionId, appDeploymentId, user);\n      }\n    }\n\n    if (StringUtils.isEmpty(formKey)) {\n      finalFormKey = formKey;\n    }\n\n    return finalFormKey;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 212,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 168,
            "lineNumberOfError": 24,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643208430033,
            "program": "  public void visit(final ParserRuleContext ancestorNode, final SQLStatement statement) {\n    AlterTableStatement alterStatement = (AlterTableStatement) statement;\n\n    ParserRuleContext modifyColumnCtx =\n        TreeUtils.getFirstChildByRuleName(ancestorNode, \"renameColumn\");\n    if (null == modifyColumnCtx) {\n      return;\n    }\n\n    List<ParserRuleContext> columnNodes =\n        TreeUtils.getAllDescendantByRuleName(modifyColumnCtx, \"columnName\");\n    if (null == columnNodes || columnNodes.size() != 2) {\n      return;\n    }\n\n    String oldName = columnNodes.get(0).getText();\n    String newName = columnNodes.get(1).getText();\n    ColumnDefinition oldDefinition = alterStatement.getUpdateColumns().remove(oldName);\n    if (null != oldDefinition) {\n      oldDefinition.setName(newName);\n    } else {\n      oldDefinition = new ColumnDefinition(newName, null, null, false);\n    }\n\n    alterStatement.getUpdateColumns().put(oldName, oldDefinition);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 164,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 188,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643208555646,
            "program": "  private boolean isSunUpAllDay(Calendar calendar, double latitude, double longitude) {\n    Calendar cal = DateTimeUtils.truncateToMidnight(calendar);\n    Sun sun = new Sun();\n    for (int minutes = 0; minutes <= MINUTES_PER_DAY; minutes += CURVE_TIME_INTERVAL) {\n      setSunPosition(cal, latitude, longitude, sun);\n      if (sun.getPosition().getElevation() < SUN_ANGLE) {\n        return false;\n      }\n      cal.add(Calendar.MINUTE, CURVE_TIME_INTERVAL);\n    }\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 94,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 216,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643208604786,
            "program": "  private Class<? extends DomElement> findImplementationClassDFS(\n      final Class<? extends DomElement> concreteInterface) {\n    Class<? extends DomElement> aClass = myImplementationClasses.get(concreteInterface);\n    if (aClass != null) {\n      return aClass;\n    }\n    for (final Class aClass1 : concreteInterface.getInterfaces()) {\n      aClass = findImplementationClassDFS(aClass1);\n      if (aClass != null) {\n        return aClass;\n      }\n    }\n    return null;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 81,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 178,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643208643456,
            "program": "  private void delay(long duration) {\n    if (duration > 0) {\n      long bedtime = duration + SystemClock.uptimeMillis();\n      do {\n        try {\n          this.wait(duration);\n        } catch (InterruptedException e) {\n        }\n        if (mDone) {\n          break;\n        }\n        duration = bedtime - SystemClock.uptimeMillis();\n      } while (duration > 0);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 73,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 187,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643208680898,
            "program": "  private Vector3 calculateDirection(float angle) {\r\n    Matrix4 transform = new Matrix4();\r\n    Vector3 dir = new Vector3(-1, 0, 1).nor();\r\n    float rotAngle = (float) Math.toDegrees(Math.asin(Math.tan(Math.toRadians(angle))));\r\n    transform.setToRotation(new Vector3(1, 0, 1).nor(), rotAngle);\r\n    dir.mul(transform).nor();\r\n    return dir;\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 98,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 173,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643208749231,
            "program": "  private static boolean shouldBeGenerated(PsiMethod method) {\n    for (PsiMethod psiMethod : method.findSuperMethods()) {\n      if (!psiMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        final PsiType type = method.getReturnType();\n        final PsiType superType = psiMethod.getReturnType();\n        if (type != null && superType != null && !superType.isAssignableFrom(type)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,develop,review",
            "token": 83,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        }
    ],
    "287724474-1643213890779": [
        {
            "ProgrammID": 160,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643214928141,
            "program": "  public void updateKBArticlePriority(KBArticle kbArticle, double priority)\n      throws PortalException, SystemException {\n\n    List<KBArticle> kbArticleVersions =\n        getKBArticleVersions(\n            kbArticle.getResourcePrimKey(),\n            WorkflowConstants.STATUS_ANY,\n            QueryUtil.ALL_POS,\n            QueryUtil.ALL_POS,\n            null);\n\n    for (KBArticle kbArticleVersion : kbArticleVersions) {\n      kbArticleVersion.setPriority(priority);\n\n      kbArticlePersistence.update(kbArticleVersion);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 68,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 185,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643215007601,
            "program": "  public Window destroyActivity(String id, boolean finish) {\n    LocalActivityRecord r = mActivities.get(id);\n    Window win = null;\n    if (r != null) {\n      win = performDestroy(r, finish);\n      if (finish) {\n        mActivities.remove(r);\n      }\n    }\n    return win;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 60,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 230,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643215151951,
            "program": "  public boolean addGeometry(Geometry geometry) {\n    Texture diffuse = getMaterialTexture(geometry, \"DiffuseMap\");\n    Texture normal = getMaterialTexture(geometry, \"NormalMap\");\n    Texture specular = getMaterialTexture(geometry, \"SpecularMap\");\n    if (diffuse == null) {\n      diffuse = getMaterialTexture(geometry, \"ColorMap\");\n    }\n    if (diffuse != null && diffuse.getKey() != null) {\n      String keyName = diffuse.getKey().toString();\n      if (!addTexture(diffuse, \"DiffuseMap\")) {\n        return false;\n      } else {\n        if (normal != null && normal.getKey() != null) {\n          addTexture(normal, \"NormalMap\", keyName);\n        }\n        if (specular != null && specular.getKey() != null) {\n          addTexture(specular, \"SpecularMap\", keyName);\n        }\n      }\n      return true;\n    }\n    return true;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 159,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 226,
            "lineNumberOfError": 20,
            "attempt": 1,
            "expectedAnswer": 24,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643215284316,
            "program": "  public void testMethodAnnotationsWrapper()\n      throws IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n    WrapperProxetta proxetta =\n        WrapperProxetta.withAspects(\n            new ProxyAspect(\n                HeroProxyAdvice.class,\n                new AllRealMethodsPointcut() {\n                  @Override\n                  public boolean apply(MethodInfo methodInfo) {\n                    if (!methodInfo.isTopLevelMethod()) {\n                      return false;\n                    }\n                    return super.apply(methodInfo);\n                  }\n                }))\n        // .setDebugFolder(\"/Users/igor/\")\n        ;\n\n    WrapperProxettaBuilder proxettaBuilder = proxetta.builder();\n    proxettaBuilder.setTarget(Hero.class);\n    proxetta.setVariableClassName(true);\n    Object hero = proxettaBuilder.newInstance();\n\n    Method nameMethod = hero.getClass().getMethod(\"name\");\n    assertEquals(\"BatmanHero37W88.3CatWoman99speeeeedXRAYnull\", nameMethod.invoke(nameMethod));\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 129,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 172,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 20,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643215450522,
            "program": "  public Element writeXML(Document document) {\n    Element modelE = document.createElement(\"statisticsmodel\");\n\n    Element resultsE = document.createElement(\"results\");\n    for (Map.Entry<StatisticsUI, String> entry : resultMap.entrySet()) {\n      if (entry.getValue() != null && !entry.getValue().isEmpty()) {\n        Element resultE = document.createElement(\"result\");\n        resultE.setAttribute(\"class\", entry.getKey().getClass().getName());\n        resultE.setAttribute(\"value\", entry.getValue());\n        resultsE.appendChild(resultE);\n      }\n    }\n    modelE.appendChild(resultsE);\n\n    Element reportsE = document.createElement(\"reports\");\n    for (Map.Entry<Class, String> entry : reportMap.entrySet()) {\n      if (entry.getValue() != null && !entry.getValue().isEmpty()) {\n        Element reportE = document.createElement(\"report\");\n        reportE.setAttribute(\"class\", entry.getKey().getName());\n        reportE.setAttribute(\"value\", entry.getValue());\n        resultsE.appendChild(reportE);\n      }\n    }\n    modelE.appendChild(reportsE);\n\n    return modelE;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 240,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 228,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643215615578,
            "program": "  public void loadPlugin(File file) throws Exception {\n    Preconditions.checkNotNull(file, \"file\");\n    Preconditions.checkArgument(file.isFile(), \"Must load from file\");\n\n    try (JarFile jar = new JarFile(file)) {\n      JarEntry pdf = jar.getJarEntry(\"plugin.yml\");\n      Preconditions.checkNotNull(pdf, \"Plugin must have a plugin.yml\");\n\n      try (InputStream in = jar.getInputStream(pdf)) {\n        PluginDescription desc = yaml.loadAs(in, PluginDescription.class);\n        URLClassLoader loader = new URLClassLoader(new URL[] {file.toURI().toURL()});\n        Class<?> main = loader.loadClass(desc.getMain());\n        Plugin plugin = (Plugin) main.getDeclaredConstructor().newInstance();\n\n        plugin.init(desc);\n        plugins.put(desc.getName(), plugin);\n        plugin.onLoad();\n        ProxyServer.getInstance()\n            .getLogger()\n            .log(\n                Level.INFO,\n                \"Loaded plugin {0} version {1} by {2}\",\n                new Object[] {desc.getName(), desc.getVersion(), desc.getAuthor()});\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 218,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 220,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643215743256,
            "program": "  public void checkResultByFile(final String filePath, final String expectedFile) throws Throwable {\n\n    new WriteCommandAction.Simple(myProjectFixture.getProject()) {\n\n      protected void run() throws Throwable {\n        String fullPath = getTempDirPath() + \"/\" + filePath;\n        final VirtualFile copy =\n            LocalFileSystem.getInstance()\n                .refreshAndFindFileByPath(fullPath.replace(File.separatorChar, '/'));\n        assert copy != null : \"file not found: \" + fullPath;\n        final PsiFile psiFile = myPsiManager.findFile(copy);\n        assert psiFile != null;\n        checkResultByFile(expectedFile, psiFile, false);\n      }\n    }.execute().throwException();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 116,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 176,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643215834242,
            "program": "  public static void freeAll(Array objects) {\r\n    if (objects == null) throw new IllegalArgumentException(\"objects cannot be null.\");\r\n    for (int i = 0, n = objects.size; i < n; i++) {\r\n      Object object = objects.get(i);\r\n      if (object == null) continue;\r\n      ReflectionPool pool = typePools.get(object.getClass());\r\n      if (pool == null) return; // Ignore freeing an object that was never retained.\r\n      pool.free(object);\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 92,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        }
    ],
    "541776140-1643221457808": [
        {
            "ProgrammID": 191,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 16,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643221932334,
            "program": "  public static RowFlagChange load(LineNumberReader reader, Pool pool) throws Exception {\n    int row = -1;\n    boolean oldFlagged = false;\n    boolean newFlagged = false;\n\n    String line;\n    while ((line = reader.readLine()) != null && !\"/ec/\".equals(line)) {\n      int equal = line.indexOf('=');\n      CharSequence field = line.subSequence(0, equal);\n      String value = line.substring(equal + 1);\n\n      if (\"row\".equals(field)) {\n        row = Integer.parseInt(value);\n      } else if (\"oldFlagged\".equals(field)) {\n        oldFlagged = Boolean.parseBoolean(value);\n      } else if (\"newFlagged\".equals(field)) {\n        oldFlagged = Boolean.parseBoolean(value);\n      }\n    }\n\n    RowFlagChange change = new RowFlagChange(row, newFlagged);\n    change.oldFlagged = oldFlagged;\n\n    return change;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 174,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 238,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643221991649,
            "program": "  public static Cache initializeCache(\n      String name, String propertiesName, int size, long expirationTime) {\n    Cache cache = caches.get(name);\n    if (cache == null) {\n      size = JiveGlobals.getIntProperty(\"cache.\" + name + \".size\", size);\n      expirationTime =\n          (long)\n              JiveGlobals.getIntProperty(\n                  \"cache.\" + propertiesName + \".expirationTime\", (int) expirationTime);\n      cache = new Cache(name, size, expirationTime);\n      caches.put(name, cache);\n    }\n    return cache;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 97,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 189,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643222030126,
            "program": "  private static void writeResourceBundle(PropertiesFile file, OutputStream out)\n      throws IOException {\n    if (file == null) {\n      out.write(Amf3Types.NULL);\n      return;\n    }\n\n    final AmfOutputStream amfOut = new AmfOutputStream(new ByteArrayOutputStreamEx(4 * 1024));\n    // todo Embed, ClassReference, but idea doesn't support it too\n    final List<IProperty> properties = file.getProperties();\n    amfOut.write(Amf3Types.DICTIONARY);\n    amfOut.writeUInt29((properties.size() << 1) | 1);\n    amfOut.write(0);\n    for (IProperty property : properties) {\n      amfOut.write(property.getUnescapedKey());\n      amfOut.write(property.getUnescapedValue());\n    }\n\n    amfOut.getByteArrayOut().writeTo(out);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 138,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 233,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643222055496,
            "program": "  public Alarm saveAlarm(@RequestBody Alarm alarm) throws ThingsboardException {\n    try {\n      alarm.setTenantId(getCurrentUser().getTenantId());\n      Alarm savedAlarm = checkNotNull(alarmService.createOrUpdateAlarm(alarm));\n      logEntityAction(\n          savedAlarm.getId(),\n          savedAlarm,\n          getCurrentUser().getCustomerId(),\n          alarm.getId() == null ? ActionType.ADDED : ActionType.UPDATED,\n          null);\n      return savedAlarm;\n    } catch (Exception e) {\n      logEntityAction(\n          emptyId(EntityType.ALARM),\n          alarm,\n          null,\n          alarm.getId() == null ? ActionType.ADDED : ActionType.UPDATED,\n          e);\n      throw handleException(e);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 127,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 202,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643222088972,
            "program": "  private Object[] buildParamList(Functor func, int indexOfParamToSetToNull) {\n    Class<?>[] types = func.getParameterTypes();\n    Object[] params = new Object[types.length];\n\n    for (int i = 0; i < types.length; i++) {\n      if (i != indexOfParamToSetToNull) {\n        params[i] = defaults.get(types[i]);\n        if (!parameterIsPrimitiveOrNullable(func, i)) {\n          Assert.assertTrue(\"No default value found for \" + types[i].getName(), params[i] != null);\n        }\n      }\n    }\n    return params;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 120,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 218,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643222115861,
            "program": "  protected static int calculateShift(int minimumValue, int maximumValue) {\n    int shift = 0;\n    int value = 1;\n    while (value < minimumValue && value < minimumValue) {\n      value <<= 1;\n      shift++;\n    }\n    return shift;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 45,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 195,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643222127023,
            "program": "  private List<String> giveFieldBinding(FieldConstraint f) {\n    List<String> result = new ArrayList<String>();\n    if (f instanceof SingleFieldConstraint) {\n      SingleFieldConstraint s = (SingleFieldConstraint) f;\n      if (s.isBound() == true) {\n        result.add(s.fieldBinding);\n      }\n    }\n    if (f instanceof CompositeFieldConstraint) {\n      CompositeFieldConstraint s = (CompositeFieldConstraint) f;\n      for (FieldConstraint ss : s.constraints) {\n        List<String> t = giveFieldBinding(s);\n        result.addAll(t);\n      }\n    }\n    return result;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 111,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 211,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643222137263,
            "program": "  public void addAllUpdates(RightTupleSets tupleSets) {\n    RightTupleSetsImpl tupleSetsImpl = (RightTupleSetsImpl) tupleSets;\n    if (updateFirst == null) {\n      updateFirst = tupleSetsImpl.getUpdateFirst();\n      updateSize = tupleSetsImpl.updateSize;\n    } else {\n      RightTuple current = updateFirst;\n      RightTuple last = null;\n      while (current != null) {\n        last = current;\n        current = current.getStagedNext();\n      }\n      RightTuple rightTuple = tupleSetsImpl.getUpdateFirst();\n      last.setStagedNext(rightTuple);\n      rightTuple.setStagePrevious(rightTuple);\n      updateSize = updateSize + tupleSetsImpl.updateSize();\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 105,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "990778145-1643270519559": [
        {
            "ProgrammID": 193,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643273823808,
            "program": "  public ObjectName getObjectName(RouteContext routeContext, ProcessorType processor)\n      throws MalformedObjectNameException {\n    Endpoint<? extends Exchange> ep = routeContext.getEndpoint();\n    String ctxid = ep != null ? getContextId(ep.getCamelContext()) : VALUE_UNKNOWN;\n    String cid = getComponentId(ep);\n    String id = VALUE_UNKNOWN.equals(cid) ? getEndpointId(ep) : \"[\" + cid + \"]\" + getEndpointId(ep);\n    String nodeId = processor.idOrCreate();\n\n    StringBuffer buffer = new StringBuffer();\n    buffer.append(domainName).append(\":\");\n    buffer.append(KEY_CONTEXT + \"=\").append(ctxid).append(\",\");\n    buffer.append(KEY_ROUTE + \"=\").append(id).append(\",\");\n    buffer.append(KEY_TYPE + \"=\" + TYPE_PROCESSOR + \",\");\n    buffer.append(KEY_NODE_ID + \"=\").append(nodeId).append(\",\");\n    buffer.append(KEY_NAME + \"=\").append(ObjectName.quote(processor.toString()));\n    return createObjectName(buffer);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 208,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 198,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643274099998,
            "program": "  public void finishBatch() {\n    for (String key : _counts.keySet()) {\n      CountValue val = COUNT_DATABASE.get(key);\n      CountValue newVal;\n      if (val == null || !val.txid.equals(_id)) {\n        newVal = new CountValue();\n        newVal.txid = _id.getTransactionId();\n        if (val != null) {\n          newVal.prev_count = val.count;\n          newVal.count = val.count;\n        }\n        newVal.count = newVal.count + _counts.get(key);\n        COUNT_DATABASE.put(key, newVal);\n      } else {\n        newVal = val;\n      }\n      _collector.emit(new Values(_id, key, newVal.count, newVal.prev_count));\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 144,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 170,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643274157505,
            "program": "  public <T> ICompletableFuture<T> submitInternal(final Callable<T> command) {\n    CompletableFutureTask futureTask = new CompletableFutureTask(command, internalExecutor);\n    internalExecutor.submit(futureTask);\n    return futureTask;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 40,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 194,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643274411871,
            "program": "  public final View getView(int position, View convertView, ViewGroup parent) {\n    ContextualUndoView contextualUndoView = (ContextualUndoView) convertView;\n    if (contextualUndoView == null) {\n      contextualUndoView =\n          new ContextualUndoView(parent.getContext(), mUndoLayoutId, mCountDownTextViewResId);\n      contextualUndoView\n          .findViewById(mUndoActionId)\n          .setOnClickListener(new UndoListener(contextualUndoView));\n    }\n\n    View contentView = super.getView(position, contextualUndoView.getContentView(), parent);\n    contextualUndoView.updateContentView(contentView);\n\n    long itemId = getItemId(position);\n\n    if (itemId == mCurrentRemovedId) {\n      contextualUndoView.displayUndo();\n      mCurrentRemovedView = contextualUndoView;\n      long millisLeft = mAutoDeleteDelayMillis - (System.currentTimeMillis() - mDismissStartMillis);\n      if (mCountDownFormatter != null) {\n        mCurrentRemovedView.updateCountDownTimer(\n            mCountDownFormatter.getCountDownString(millisLeft));\n      }\n    } else {\n      contextualUndoView.displayContentView();\n    }\n\n    contextualUndoView.setItemId(itemId);\n    return contextualUndoView;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 169,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 207,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 18,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643274684995,
            "program": "  private void handleSecurityPermission(final org.w3c.dom.Node node, PermissionType type)\n      throws Exception {\n    final SecurityConfig cfg = config.getSecurityConfig();\n    final NamedNodeMap attrs = node.getAttributes();\n\n    Node nameNode = attrs.getNamedItem(\"name\");\n    String name = nameNode != null ? getTextContent(nameNode) : \"*\";\n    Node principalNode = attrs.getNamedItem(\"principal\");\n    String principal = principalNode != null ? getTextContent(principalNode) : \"*\";\n\n    final PermissionConfig permConfig = new PermissionConfig(type, name, principal);\n    cfg.addClientPermissionConfig(permConfig);\n\n    for (org.w3c.dom.Node child : new IterableNodeList(node.getChildNodes())) {\n      final String nodeName = cleanNodeName(child.getNodeName());\n      if (\"endpoints\".equals(nodeName)) {\n        handleSecurityPermissionEndpoints(principalNode, permConfig);\n      } else if (\"actions\".equals(nodeName)) {\n        handleSecurityPermissionActions(principalNode, permConfig);\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 183,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 174,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": 21,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643274842053,
            "program": "  public PsiElement simplify(PsiMethodCallExpression call) {\n    PsiExpression value = myValuePointer.getElement();\n    if (value == null) return null;\n    PsiMethodCallExpression qualifierCall = getQualifierMethodCall(call);\n    if (qualifierCall == null) return null;\n    PsiExpressionList qualifierArgs = qualifierCall.getArgumentList();\n    CommentTracker ct = new CommentTracker();\n    PsiReferenceParameterList typeParameters =\n        qualifierCall.getMethodExpression().getParameterList();\n    String typeParametersText = typeParameters == null ? \"\" : ct.text(typeParameters);\n    PsiElement result =\n        ct.replaceAndRestoreComments(\n            call,\n            CommonClassNames.JAVA_UTIL_ARRAYS\n                + \".\"\n                + typeParametersText\n                + \"asList\"\n                + ct.text(qualifierArgs)\n                + \".contains(\"\n                + ct.text(value)\n                + \")\");\n    return JavaCodeStyleManager.getInstance(call.getProject()).shortenClassReferences(result);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 145,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 196,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 16,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643274947219,
            "program": "  protected boolean matchRequest(Request request) {\n\n    // Has a session been created?\n    Session session = request.getSessionInternal(false);\n    if (session == null) return (false);\n\n    // Is there a saved request?\n    SavedRequest sreq = (SavedRequest) session.getNote(Constants.FORM_REQUEST_NOTE);\n    if (sreq == null) return (false);\n\n    // Is there a saved principal?\n    if (session.getNote(Constants.FORM_PRINCIPAL_NOTE) == null) return (false);\n\n    // Does the request URI match?\n    String requestURI = request.getRequestURI();\n    if (requestURI == null) return (false);\n    return (requestURI.equals(request.getRequestURI()));\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 108,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 229,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643275147859,
            "program": "  private List<Transaction> loadErrorTransactions() {\n\n    TransactionRepository transactionRepository =\n        transactionConfigurator.getTransactionRepository();\n\n    long currentTimeInMillis = Calendar.getInstance().getTimeInMillis();\n\n    List<Transaction> transactions =\n        transactionRepository.findAllUnmodifiedSince(\n            new Date(\n                currentTimeInMillis\n                    - transactionConfigurator.getRecoverConfig().getRecoverDuration() * 1000));\n\n    List<Transaction> recoverTransactions = new ArrayList<Transaction>();\n\n    for (Transaction transaction : transactions) {\n\n      int result = transactionRepository.update(transaction);\n\n      if (result > 0) {\n        recoverTransactions.add(transaction);\n      }\n    }\n\n    return recoverTransactions;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 112,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 203,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643275281143,
            "program": "  protected void validateImport(\n      Map<String, List<StagedModel>> dependentStagedModelsMap, Group group) throws Exception {\n\n    List<StagedModel> dependentStagedModels =\n        dependentStagedModelsMap.get(MDRRuleGroup.class.getSimpleName());\n\n    Assert.assertEquals(1, dependentStagedModels.size());\n\n    MDRRuleGroup ruleGroup = (MDRRuleGroup) dependentStagedModels.get(0);\n\n    MDRRuleGroupLocalServiceUtil.getMDRRuleGroupByUuidAndGroupId(\n        ruleGroup.getUuid(), ruleGroup.getGroupId());\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 84,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 190,
            "lineNumberOfError": 7,
            "attempt": 2,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643275371683,
            "program": "  public static boolean isActiveService(Context context, ComponentName service) {\n    String cur =\n        Settings.Secure.getString(\n            context.getContentResolver(), Settings.Secure.VOICE_INTERACTION_SERVICE);\n    if (cur == null || cur.isEmpty()) {\n      return false;\n    }\n    ComponentName curComp = ComponentName.unflattenFromString(cur);\n    if (curComp == null) {\n      return false;\n    }\n    return curComp.equals(cur);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 81,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 186,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643275568269,
            "program": "  public static void const2stack(\n      CompilationResultBuilder crb,\n      SPARCMacroAssembler masm,\n      Value result,\n      Register constantTableBase,\n      Value input,\n      SPARCDelayedControlTransfer delaySlotLir,\n      JavaConstant constant) {\n    if (constant.isDefaultForKind() || constant.isNull()) {\n      SPARCAddress resultAddress = (SPARCAddress) crb.asAddress(result);\n      emitStore(\n          g0.asValue(LIRKind.combine(input)),\n          resultAddress,\n          result.getPlatformKind(),\n          delaySlotLir,\n          null,\n          crb,\n          masm);\n    } else {\n      try (ScratchRegister sc = masm.getScratchRegister()) {\n        Value scratchRegisterValue = sc.getRegister().asValue(LIRKind.combine(constant));\n        const2reg(\n            crb,\n            masm,\n            scratchRegisterValue,\n            constantTableBase,\n            constant,\n            SPARCDelayedControlTransfer.DUMMY);\n        SPARCAddress resultAddress = (SPARCAddress) crb.asAddress(result);\n        emitStore(\n            scratchRegisterValue,\n            resultAddress,\n            result.getPlatformKind(),\n            delaySlotLir,\n            null,\n            crb,\n            masm);\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 174,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 221,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643275639550,
            "program": "  private void pollFilter(EthFilter ethFilter) {\n    EthLog ethLog = null;\n    try {\n      ethLog = web3j.ethGetFilterChanges(filterId).send();\n    } catch (IOException e) {\n      throwException(e);\n    }\n    if (ethLog.hasError()) {\n      throwException(ethFilter.getError());\n    } else {\n      process(ethLog.getLogs());\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 73,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 163,
            "lineNumberOfError": 4,
            "attempt": 2,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643275669373,
            "program": "  public String getLabel(Locale locale) {\n    ResourceBundle resourceBundle =\n        ResourceBundleUtil.getBundle(\"content.Language\", locale, getClass());\n\n    return LanguageUtil.get(locale, getKey());\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 37,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 224,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643275774923,
            "program": "  private void addCustomDefinition(\n      @NotNull AntDomNamedElement declaringTag,\n      String customTagName,\n      String nsUri,\n      Class clazz,\n      String error) {\n    final XmlName xmlName = new XmlName(customTagName, nsUri == null ? \"\" : nsUri);\n    if (error != null) {\n      myErrors.put(xmlName, error);\n    }\n    myCustomElements.put(xmlName, clazz);\n    myDeclarations.put(xmlName, declaringTag);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 76,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 184,
            "lineNumberOfError": 2,
            "attempt": 2,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643275902611,
            "program": "  public static String addPrefixIfNot(CharSequence str, CharSequence prefix) {\r\n    if (isEmpty(str) || isEmpty(prefix)) {\r\n      return str.toString();\r\n    }\r\n\r\n    final String str2 = str.toString();\r\n    final String prefix2 = prefix.toString();\r\n    if (false == str2.startsWith(prefix2)) {\r\n      return prefix2 + str2;\r\n    }\r\n    return prefix2;\r\n  }\r\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 75,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 215,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643276070703,
            "program": "  protected void filterResults(List<AuxiliaryResolveInfo> results) {\n    // only do work if ordering is enabled [most of the time it won't be]\n    if (mOrderResult.size() == 0) {\n      return;\n    }\n    int resultSize = results.size();\n    for (int i = 0; i < resultSize; i++) {\n      final InstantAppResolveInfo info = results.get(i).resolveInfo;\n      final String packageName = info.getPackageName();\n      final Pair<Integer, InstantAppResolveInfo> savedInfo = mOrderResult.get(packageName);\n      if (savedInfo == null) {\n        // package doesn't having ordering\n        continue;\n      }\n      if (savedInfo.second == info) {\n        // circled back to the highest ordered item; remove from order list\n        mOrderResult.remove(packageName);\n        if (mOrderResult.size() == 0) {\n          // no more ordered items\n          break;\n        }\n        continue;\n      }\n      // item has a worse order, remove it from the result list\n      results.remove(i);\n      resultSize--;\n      i--;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test,review,develop",
            "token": 146,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1462301588-1643279315573": [
        {
            "ProgrammID": 180,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643282447008,
            "program": "  private void computePostdominators() {\n    outer:\n    for (Block block : postOrder()) {\n      if (block.isLoopEnd()) {\n        // We do not want the loop header registered as the postdominator of the loop end.\n        continue;\n      }\n      if (block.getSuccessorCount() == 0) {\n        // No successors => no postdominator.\n        continue;\n      }\n      Block firstSucc = block.getSuccessors().get(0);\n      if (block.getSuccessorCount() == 1) {\n        block.postdominator = block;\n        continue;\n      }\n      Block postdominator = firstSucc;\n      for (Block sux : block.getSuccessors()) {\n        postdominator = commonPostdominator(postdominator, sux);\n        if (postdominator == null) {\n          // There is a dead end => no postdominator available.\n          continue outer;\n        }\n      }\n      assert !block.getSuccessors().contains(postdominator)\n          : \"Block \" + block + \" has a wrong post dominator: \" + postdominator;\n      block.postdominator = postdominator;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 145,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 204,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643282831373,
            "program": "  static ErrorProneAnalyzer createAnalyzer(\n      ScannerSupplier scannerSupplier,\n      ErrorProneOptions epOptions,\n      Context context,\n      RefactoringCollection[] refactoringCollection) {\n    if (!epOptions.patchingOptions().doRefactor()) {\n      return ErrorProneAnalyzer.createByScanningForPlugins(scannerSupplier, epOptions, context);\n    }\n    refactoringCollection[0] = RefactoringCollection.refactor(epOptions.patchingOptions());\n\n    // Refaster refactorer or using builtin checks\n    CodeTransformer codeTransformer =\n        epOptions\n            .patchingOptions()\n            .customRefactorer()\n            .or(\n                () -> {\n                  ScannerSupplier toUse = ErrorPronePlugins.loadPlugins(scannerSupplier, context);\n                  Set<String> namedCheckers = epOptions.patchingOptions().namedCheckers();\n                  if (!namedCheckers.isEmpty()) {\n                    toUse = toUse.filter(bci -> namedCheckers.contains(bci.canonicalName()));\n                  }\n                  return ErrorProneScannerTransformer.create(toUse.applyOverrides(epOptions).get());\n                })\n            .get();\n\n    return ErrorProneAnalyzer.createWithCustomDescriptionListener(\n        codeTransformer, epOptions, context, refactoringCollection[0]);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 182,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 212,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643282981441,
            "program": "  public static Block createLongDictionaryBlock(int start, int length) {\n    int dictionarySize = length / 5;\n    BlockBuilder builder = BIGINT.createBlockBuilder(new BlockBuilderStatus(), dictionarySize);\n    for (int i = start; i < dictionarySize; i++) {\n      BIGINT.writeLong(builder, i);\n    }\n    int[] ids = new int[length];\n    for (int i = 0; i < length; i++) {\n      ids[i] = i % dictionarySize;\n    }\n    return new DictionaryBlock(length, builder.build(), wrappedIntArray(ids));\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 114,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 232,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643283052502,
            "program": "  protected double getDropoutFromConfig(Map<String, Object> layerConfig)\n      throws InvalidKerasConfigurationException {\n    Map<String, Object> innerConfig = getInnerLayerConfigFromConfig(layerConfig);\n    /* NOTE: Keras \"dropout\" parameter determines dropout probability,\n     * while DL4J \"dropout\" parameter determines retention probability.\n     */\n    double dropout = 1.0;\n    if (innerConfig.containsKey(LAYER_FIELD_DROPOUT)) {\n      /* For most feedforward layers. */\n      dropout = 1.0 - (double) innerConfig.get(LAYER_FIELD_DROPOUT);\n    } else if (layerConfig.containsKey(LAYER_FIELD_DROPOUT_W)) {\n      /* For LSTMs. */\n      dropout = 1.0 - (double) layerConfig.get(LAYER_FIELD_DROPOUT_W);\n    }\n    return dropout;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 88,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 208,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643283121973,
            "program": "  private boolean matches(EndpointReferenceType ref, W3CEndpointReference r) {\n    EndpointReferenceType cref = ProviderImpl.convertToInternal(r);\n    QName snr = EndpointReferenceUtils.getServiceName(ref, bus);\n    QName snc = EndpointReferenceUtils.getServiceName(cref, bus);\n    String addr = EndpointReferenceUtils.getAddress(ref);\n    String addc = EndpointReferenceUtils.getAddress(ref);\n\n    if (addr == null) {\n      return false;\n    }\n    if (addr.equals(addc)) {\n      if (snr != null && !snr.equals(snc)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 113,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 197,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643283218695,
            "program": "  public static Icon getIcon(File file) {\n    Icon fileIcon = null;\n\n    try {\n      sun.awt.shell.ShellFolder shellFolder = sun.awt.shell.ShellFolder.getShellFolder(file);\n\n      fileIcon = new ImageIcon(shellFolder.getIcon(true), shellFolder.getFolderType());\n    } catch (Exception e) {\n      logger.debug(\"Failed to obtain file icon from ShellFolder.\", e);\n      try {\n        fileIcon = new JFileChooser().getIcon(file);\n      } catch (Exception e1) {\n        logger.debug(\"Failed to obtain file icon from JFileChooser.\", e1);\n      }\n    }\n\n    return fileIcon;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 109,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 209,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643283406817,
            "program": "  public <K extends ActionResponse> K execute(ActionRequestBuilder request) {\n    StopWatch fullProfile = profiling.start(\"search\", Profiling.Level.FULL);\n    K response = null;\n    try {\n\n      response = (K) request.get();\n\n      if (profiling.isProfilingEnabled(Profiling.Level.BASIC)) {\n        if (ToXContent.class.isAssignableFrom(request.getClass())) {\n          XContentBuilder debugResponse = XContentFactory.jsonBuilder();\n          debugResponse.startObject();\n          ((ToXContent) request).toXContent(debugResponse, ToXContent.EMPTY_PARAMS);\n          debugResponse.endObject();\n          fullProfile.stop(\"ES Request: %s\", debugResponse.string());\n        } else {\n          fullProfile.stop(\"ES Request: %s\", request.toString().replaceAll(\"\\n\", \"\"));\n        }\n      }\n      return response;\n    } catch (Exception e) {\n      LOGGER.error(\"could not execute request: \" + request, e);\n      throw new IllegalStateException(\"ES error: \", e);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 184,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 183,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643283539701,
            "program": "  void updateRulesForTempWhitelistChangeLocked() {\n    final List<UserInfo> users = mUserManager.getUsers();\n    for (int i = 0; i < users.size(); i++) {\n      final UserInfo user = users.get(i);\n      for (int j = mPowerSaveTempWhitelistAppIds.size() - 1; j >= 0; j--) {\n        int appId = mPowerSaveTempWhitelistAppIds.keyAt(j);\n        int uid = UserHandle.getUid(user.id, appId);\n        updateRuleForAppIdleLocked(uid);\n        updateRuleForDeviceIdleLocked(uid);\n        updateRulesForRestrictPowerLocked(uid);\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 111,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1079217180-1643290139397": [
        {
            "ProgrammID": 210,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643291109293,
            "program": "  private KadaneResult kadane(int arr[]) {\n    int max = 0;\n    int maxStart = -1;\n    int maxEnd = -1;\n    int currentStart = 0;\n    int maxSoFar = 0;\n    for (int i = 0; i < arr.length; i++) {\n      maxSoFar += arr[i];\n      if (maxSoFar < 0) {\n        maxSoFar = 0;\n        currentStart = i + 1;\n      }\n      if (max < maxSoFar) {\n        maxStart = currentStart;\n        maxEnd = i;\n        max = maxSoFar;\n      }\n    }\n    return new KadaneResult(max, maxStart, maxEnd);\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "develop",
            "token": 112,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 162,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643291225263,
            "program": "  public void importResources(File file) {\n    if (file.exists()) {\n      File[] files = file.listFiles();\n      if (files != null) {\n        for (File f : files) {\n          if (!file.isHidden()) {\n            importResources(f);\n          }\n        }\n      } else {\n        try {\n          URL url = file.toURI().toURL();\n          String parserType = getParserType(url);\n          importFile(parserType, url);\n        } catch (MalformedURLException e) {\n          // can't happen for the 'file' protocol handler with a correctly formatted URI\n          logger.debug(\"Can't create a URL\", e);\n        }\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "develop",
            "token": 113,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 179,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643291307598,
            "program": "  public FileType findFileTypeByName(String fileTypeName) {\n    FileType type = getStdFileType(fileTypeName);\n    // TODO: Abstract file types are not std one, so need to be restored specially,\n    // currently there are 6 of them and restoration does not happen very often so just iteration is\n    // enough\n    if (type == PlainTextFileType.INSTANCE && !fileTypeName.equals(type.getName())) {\n      for (FileType fileType : getRegisteredFileTypes()) {\n        if (fileType.equals(fileType.getName())) {\n          return fileType;\n        }\n      }\n    }\n    return type;\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "develop",
            "token": 71,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 165,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643291397066,
            "program": "  private boolean sendRemoved(int fingerId, int groupId, int remaining) {\n    IFingerprintServiceReceiver receiver = getReceiver();\n    try {\n      if (receiver != null) {\n        // TODO: plumb remaining\n        receiver.onRemoved(getHalDeviceId(), fingerId, groupId, remaining);\n      }\n    } catch (RemoteException e) {\n      Slog.w(TAG, \"Failed to notify Removed:\", e);\n    }\n    return fingerId == 0;\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "develop",
            "token": 71,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 184,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643291477605,
            "program": "  public static String addPrefixIfNot(CharSequence str, CharSequence prefix) {\r\n    if (isEmpty(str) || isEmpty(prefix)) {\r\n      return str.toString();\r\n    }\r\n\r\n    final String str2 = str.toString();\r\n    final String prefix2 = prefix.toString();\r\n    if (false == str2.startsWith(prefix2)) {\r\n      return prefix2 + str2;\r\n    }\r\n    return prefix2;\r\n  }\r\n",
            "exp": "2",
            "age": "31-50",
            "task": "develop",
            "token": 75,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 177,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643291537293,
            "program": "  public void addNameForObject(Object objectToName, String lang, String name) {\n    String objectName;\n    if (objectToName instanceof Item) {\n      objectName = ((Item) objectToName).func_77658_a();\n    } else if (objectToName instanceof Block) {\n      objectName = ((Block) objectToName).func_71917_a();\n    } else if (objectToName instanceof ItemStack) {\n      objectName = ((ItemStack) objectToName).func_77973_b().func_77667_c((ItemStack) objectToName);\n    } else {\n      throw new IllegalArgumentException(\n          String.format(\"Illegal object for naming %s\", objectToName));\n    }\n    objectName += \".name\";\n    addStringLocalization(lang, lang, name);\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "develop",
            "token": 121,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 212,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643291656667,
            "program": "  public static Block createLongDictionaryBlock(int start, int length) {\n    int dictionarySize = length / 5;\n    BlockBuilder builder = BIGINT.createBlockBuilder(new BlockBuilderStatus(), dictionarySize);\n    for (int i = start; i < dictionarySize; i++) {\n      BIGINT.writeLong(builder, i);\n    }\n    int[] ids = new int[length];\n    for (int i = 0; i < length; i++) {\n      ids[i] = i % dictionarySize;\n    }\n    return new DictionaryBlock(length, builder.build(), wrappedIntArray(ids));\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "develop",
            "token": 114,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 238,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643291858581,
            "program": "  public static Cache initializeCache(\n      String name, String propertiesName, int size, long expirationTime) {\n    Cache cache = caches.get(name);\n    if (cache == null) {\n      size = JiveGlobals.getIntProperty(\"cache.\" + name + \".size\", size);\n      expirationTime =\n          (long)\n              JiveGlobals.getIntProperty(\n                  \"cache.\" + propertiesName + \".expirationTime\", (int) expirationTime);\n      cache = new Cache(name, size, expirationTime);\n      caches.put(name, cache);\n    }\n    return cache;\n  }\n",
            "exp": "2",
            "age": "31-50",
            "task": "develop",
            "token": 97,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "106788689-1643294120114": [
        {
            "ProgrammID": 185,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643294404107,
            "program": "  public Window destroyActivity(String id, boolean finish) {\n    LocalActivityRecord r = mActivities.get(id);\n    Window win = null;\n    if (r != null) {\n      win = performDestroy(r, finish);\n      if (finish) {\n        mActivities.remove(r);\n      }\n    }\n    return win;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 60,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 208,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643294449715,
            "program": "  private boolean matches(EndpointReferenceType ref, W3CEndpointReference r) {\n    EndpointReferenceType cref = ProviderImpl.convertToInternal(r);\n    QName snr = EndpointReferenceUtils.getServiceName(ref, bus);\n    QName snc = EndpointReferenceUtils.getServiceName(cref, bus);\n    String addr = EndpointReferenceUtils.getAddress(ref);\n    String addc = EndpointReferenceUtils.getAddress(ref);\n\n    if (addr == null) {\n      return false;\n    }\n    if (addr.equals(addc)) {\n      if (snr != null && !snr.equals(snc)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 113,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 164,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643294493429,
            "program": "  public void onPackageChange(String packageName) {\n    if (mFacetPackageMap.containsKey(packageName)) {\n      int index = mFacetPackageMap.get(packageName);\n      mFacetHasMultipleAppsCache.put(index, facetHasMultiplePackages(index));\n      // No need to check categories because we've already refreshed the cache.\n      return;\n    }\n\n    String category = getPackageCategory(packageName);\n    if (mFacetCategoryMap.containsKey(category)) {\n      int index = mFacetCategoryMap.get(packageName);\n      mFacetHasMultipleAppsCache.put(index, facetHasMultiplePackages(index));\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 85,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 202,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643294584168,
            "program": "  private Object[] buildParamList(Functor func, int indexOfParamToSetToNull) {\n    Class<?>[] types = func.getParameterTypes();\n    Object[] params = new Object[types.length];\n\n    for (int i = 0; i < types.length; i++) {\n      if (i != indexOfParamToSetToNull) {\n        params[i] = defaults.get(types[i]);\n        if (!parameterIsPrimitiveOrNullable(func, i)) {\n          Assert.assertTrue(\"No default value found for \" + types[i].getName(), params[i] != null);\n        }\n      }\n    }\n    return params;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 120,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 217,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 26,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643294724093,
            "program": "  public static int indexOf(String source, int ch, int origFromIndex) {\n    int fromIndex = origFromIndex;\n    final int sourceCount = source.length();\n    if (fromIndex >= sourceCount) {\n      // Note: fromIndex might be near -1>>>1.\n      return -1;\n    }\n    if (fromIndex < 0) {\n      fromIndex = 0;\n    }\n\n    if (ch < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n      char[] sourceArray = StringSubstitutions.getValue(source);\n\n      Pointer sourcePointer =\n          Word.objectToTrackedPointer(sourceArray)\n              .add(charArrayBaseOffset(INJECTED))\n              .add(fromIndex * charArrayIndexScale(INJECTED));\n      int result =\n          AMD64ArrayIndexOfNode.optimizedArrayIndexOf(\n              sourcePointer, sourceCount - fromIndex, (char) ch, JavaKind.Char);\n      if (result != -1) {\n        return result + fromIndex;\n      }\n      return result;\n    } else {\n      return indexOf(source, ch, fromIndex);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 158,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 176,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643294781673,
            "program": "  public static void freeAll(Array objects) {\r\n    if (objects == null) throw new IllegalArgumentException(\"objects cannot be null.\");\r\n    for (int i = 0, n = objects.size; i < n; i++) {\r\n      Object object = objects.get(i);\r\n      if (object == null) continue;\r\n      ReflectionPool pool = typePools.get(object.getClass());\r\n      if (pool == null) return; // Ignore freeing an object that was never retained.\r\n      pool.free(object);\r\n    }\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 92,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 216,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643294869007,
            "program": "  private Class<? extends DomElement> findImplementationClassDFS(\n      final Class<? extends DomElement> concreteInterface) {\n    Class<? extends DomElement> aClass = myImplementationClasses.get(concreteInterface);\n    if (aClass != null) {\n      return aClass;\n    }\n    for (final Class aClass1 : concreteInterface.getInterfaces()) {\n      aClass = findImplementationClassDFS(aClass1);\n      if (aClass != null) {\n        return aClass;\n      }\n    }\n    return null;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 81,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 186,
            "lineNumberOfError": 20,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643295041906,
            "program": "  public static void const2stack(\n      CompilationResultBuilder crb,\n      SPARCMacroAssembler masm,\n      Value result,\n      Register constantTableBase,\n      Value input,\n      SPARCDelayedControlTransfer delaySlotLir,\n      JavaConstant constant) {\n    if (constant.isDefaultForKind() || constant.isNull()) {\n      SPARCAddress resultAddress = (SPARCAddress) crb.asAddress(result);\n      emitStore(\n          g0.asValue(LIRKind.combine(input)),\n          resultAddress,\n          result.getPlatformKind(),\n          delaySlotLir,\n          null,\n          crb,\n          masm);\n    } else {\n      try (ScratchRegister sc = masm.getScratchRegister()) {\n        Value scratchRegisterValue = sc.getRegister().asValue(LIRKind.combine(constant));\n        const2reg(\n            crb,\n            masm,\n            scratchRegisterValue,\n            constantTableBase,\n            constant,\n            SPARCDelayedControlTransfer.DUMMY);\n        SPARCAddress resultAddress = (SPARCAddress) crb.asAddress(result);\n        emitStore(\n            scratchRegisterValue,\n            resultAddress,\n            result.getPlatformKind(),\n            delaySlotLir,\n            null,\n            crb,\n            masm);\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 174,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "2060607026-1643312180997": [
        {
            "ProgrammID": 195,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643312680568,
            "program": "  private List<String> giveFieldBinding(FieldConstraint f) {\n    List<String> result = new ArrayList<String>();\n    if (f instanceof SingleFieldConstraint) {\n      SingleFieldConstraint s = (SingleFieldConstraint) f;\n      if (s.isBound() == true) {\n        result.add(s.fieldBinding);\n      }\n    }\n    if (f instanceof CompositeFieldConstraint) {\n      CompositeFieldConstraint s = (CompositeFieldConstraint) f;\n      for (FieldConstraint ss : s.constraints) {\n        List<String> t = giveFieldBinding(s);\n        result.addAll(t);\n      }\n    }\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 111,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 235,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643312787401,
            "program": "  public AssertThat with(final String name, final Object schema) {\n    return with(\n        new OptiqAssert.ConnectionFactory() {\n          public OptiqConnection createConnection() throws Exception {\n            Class.forName(\"net.hydromatic.optiq.jdbc.Driver\");\n            Connection connection = DriverManager.getConnection(\"jdbc:optiq:\");\n            OptiqConnection optiqConnection = connection.unwrap(OptiqConnection.class);\n            MutableSchema rootSchema = optiqConnection.getRootSchema();\n            ReflectiveSchema.create(optiqConnection, rootSchema, name, schema);\n            optiqConnection.setSchema(name);\n            return optiqConnection;\n          }\n        });\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 97,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 206,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643312898594,
            "program": "  private TextClassification createClassificationResult(\n      SmartSelection.ClassificationResult[] classifications, String text, int start, int end) {\n    final String classifiedText = text.substring(start, end);\n    final TextClassification.Builder builder =\n        new TextClassification.Builder().setText(classifiedText);\n\n    final int size = classifications.length;\n    for (int i = 0; i < size; i++) {\n      builder.setEntityType(classifications[i].mCollection, classifications[i].mScore);\n    }\n\n    final String type = getHighestScoringType(classifications);\n    addActions(builder, IntentFactory.create(mContext, type, text));\n\n    return builder.setSignature(getSignature(text, start, end)).build();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 140,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 231,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643313233536,
            "program": "  public static Throwable unwrapThrowable(Throwable wrapped) {\r\n    Throwable unwrapped = wrapped;\r\n    while (true) {\r\n      if (unwrapped instanceof InvocationTargetException) {\r\n        unwrapped = ((InvocationTargetException) wrapped).getTargetException();\r\n      } else if (unwrapped instanceof UndeclaredThrowableException) {\r\n        unwrapped = ((UndeclaredThrowableException) wrapped).getUndeclaredThrowable();\r\n      } else {\r\n        return unwrapped;\r\n      }\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 70,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 197,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643313358026,
            "program": "  public static Icon getIcon(File file) {\n    Icon fileIcon = null;\n\n    try {\n      sun.awt.shell.ShellFolder shellFolder = sun.awt.shell.ShellFolder.getShellFolder(file);\n\n      fileIcon = new ImageIcon(shellFolder.getIcon(true), shellFolder.getFolderType());\n    } catch (Exception e) {\n      logger.debug(\"Failed to obtain file icon from ShellFolder.\", e);\n      try {\n        fileIcon = new JFileChooser().getIcon(file);\n      } catch (Exception e1) {\n        logger.debug(\"Failed to obtain file icon from JFileChooser.\", e1);\n      }\n    }\n\n    return fileIcon;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 109,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 190,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643313440376,
            "program": "  public static boolean isActiveService(Context context, ComponentName service) {\n    String cur =\n        Settings.Secure.getString(\n            context.getContentResolver(), Settings.Secure.VOICE_INTERACTION_SERVICE);\n    if (cur == null || cur.isEmpty()) {\n      return false;\n    }\n    ComponentName curComp = ComponentName.unflattenFromString(cur);\n    if (curComp == null) {\n      return false;\n    }\n    return curComp.equals(cur);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 81,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 223,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643313498525,
            "program": "  private void scrollLayerTo(int x, int y) {\n    int dx = mScrollingLayerRect.left - x;\n    int dy = mScrollingLayerRect.top - y;\n    if (dx == 0 && y == 0) {\n      return;\n    }\n    if (mSelectingText) {\n      if (mSelectCursorBaseLayerId == mCurrentScrollingLayerId) {\n        mSelectCursorBase.offset(dx, dy);\n        mSelectCursorBaseTextQuad.offset(dx, dy);\n      }\n      if (mSelectCursorExtentLayerId == mCurrentScrollingLayerId) {\n        mSelectCursorExtent.offset(dx, dy);\n        mSelectCursorExtentTextQuad.offset(dx, dy);\n      }\n    }\n    if (mAutoCompletePopup != null && mCurrentScrollingLayerId == mEditTextLayerId) {\n      mEditTextBounds.offset(dx, dy);\n      mAutoCompletePopup.resetRect();\n    }\n    nativeScrollLayer(mCurrentScrollingLayerId, x, y);\n    mScrollingLayerRect.left = x;\n    mScrollingLayerRect.top = y;\n    mWebViewCore.sendMessage(\n        WebViewCore.EventHub.SCROLL_LAYER, mCurrentScrollingLayerId, mScrollingLayerRect);\n    mWebViewPrivate.onScrollChanged(getScrollX(), getScrollY(), getScrollX(), getScrollY());\n    invalidate();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 190,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 189,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643313643560,
            "program": "  private static void writeResourceBundle(PropertiesFile file, OutputStream out)\n      throws IOException {\n    if (file == null) {\n      out.write(Amf3Types.NULL);\n      return;\n    }\n\n    final AmfOutputStream amfOut = new AmfOutputStream(new ByteArrayOutputStreamEx(4 * 1024));\n    // todo Embed, ClassReference, but idea doesn't support it too\n    final List<IProperty> properties = file.getProperties();\n    amfOut.write(Amf3Types.DICTIONARY);\n    amfOut.writeUInt29((properties.size() << 1) | 1);\n    amfOut.write(0);\n    for (IProperty property : properties) {\n      amfOut.write(property.getUnescapedKey());\n      amfOut.write(property.getUnescapedValue());\n    }\n\n    amfOut.getByteArrayOut().writeTo(out);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 138,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1153209880-1643318598406": [
        {
            "ProgrammID": 234,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 29,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643319194409,
            "program": "  protected String retrieveFinalFormKey(\n      String formKey,\n      FlowElement flowElement,\n      Map<Long, Form> formIdMap,\n      AbstractModel model,\n      Long appDefinitionId,\n      Long appDeploymentId,\n      User user) {\n\n    String finalFormKey = null;\n    List<ExtensionElement> formIdExtensions =\n        flowElement.getExtensionElements().get(\"form-reference-id\");\n    List<ExtensionElement> formNameExtensions =\n        flowElement.getExtensionElements().get(\"form-reference-name\");\n    if (CollectionUtils.isNotEmpty(formIdExtensions)\n        && CollectionUtils.isNotEmpty(formNameExtensions)) {\n      Long formId = Long.valueOf(formIdExtensions.get(0).getElementText());\n      finalFormKey =\n          getFormKeyWithFormId(formId, formIdMap, model, appDefinitionId, appDeploymentId, user);\n\n    } else if (StringUtils.isNotEmpty(formKey) && formKey.startsWith(\"FORM_REFERENCE\")) {\n      String formIdValue = formKey.replace(\"FORM_REFERENCE\", \"\");\n      if (NumberUtils.isNumber(formIdValue)) {\n        Long formId = Long.valueOf(formIdValue);\n        finalFormKey =\n            getFormKeyWithFormId(formId, formIdMap, model, appDefinitionId, appDeploymentId, user);\n      }\n    }\n\n    if (StringUtils.isEmpty(formKey)) {\n      finalFormKey = formKey;\n    }\n\n    return finalFormKey;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 212,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 166,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643319321850,
            "program": "  public static CharArraySet parseStopWords(\n      Environment env,\n      Settings settings,\n      CharArraySet defaultStopWords,\n      Version version,\n      boolean ignore_case) {\n    String value = settings.get(\"stopwords\");\n    if (value != null) {\n      if (\"_none_\".equals(value)) {\n        return CharArraySet.EMPTY_SET;\n      } else {\n        return resolveNamedStopWords(Strings.commaDelimitedListToSet(value), version, ignore_case);\n      }\n    }\n    String[] stopWords = settings.getAsArray(\"stopwords\", null);\n    if (stopWords != null) {\n      return resolveNamedStopWords(stopWords, version, ignore_case);\n    }\n    List<String> pathLoadedStopWords = getWordList(env, settings, \"stopwords\");\n    if (pathLoadedStopWords != null) {\n      return resolveNamedStopWords(pathLoadedStopWords, version, ignore_case);\n    }\n\n    return defaultStopWords;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 142,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 221,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643319394377,
            "program": "  private void pollFilter(EthFilter ethFilter) {\n    EthLog ethLog = null;\n    try {\n      ethLog = web3j.ethGetFilterChanges(filterId).send();\n    } catch (IOException e) {\n      throwException(e);\n    }\n    if (ethLog.hasError()) {\n      throwException(ethFilter.getError());\n    } else {\n      process(ethLog.getLogs());\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 73,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 180,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": 13,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643319670839,
            "program": "  private void computePostdominators() {\n    outer:\n    for (Block block : postOrder()) {\n      if (block.isLoopEnd()) {\n        // We do not want the loop header registered as the postdominator of the loop end.\n        continue;\n      }\n      if (block.getSuccessorCount() == 0) {\n        // No successors => no postdominator.\n        continue;\n      }\n      Block firstSucc = block.getSuccessors().get(0);\n      if (block.getSuccessorCount() == 1) {\n        block.postdominator = block;\n        continue;\n      }\n      Block postdominator = firstSucc;\n      for (Block sux : block.getSuccessors()) {\n        postdominator = commonPostdominator(postdominator, sux);\n        if (postdominator == null) {\n          // There is a dead end => no postdominator available.\n          continue outer;\n        }\n      }\n      assert !block.getSuccessors().contains(postdominator)\n          : \"Block \" + block + \" has a wrong post dominator: \" + postdominator;\n      block.postdominator = postdominator;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 145,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 167,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643319732929,
            "program": "  public void test03() {\n    initializeForTimeout();\n    // 0 disables alarm utility\n    OptionValues initialOptions = getInitialOptions();\n    OptionValues options = new OptionValues(initialOptions, CompilationExpirationPeriod, 0);\n    try (CompilationAlarm c1 = CompilationAlarm.trackCompilationPeriod(options)) {\n      StructuredGraph g = parseEager(\"snippet\", AllowAssumptions.NO, options);\n      new PartiallyCooperativePhase().apply(g);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 69,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 214,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643319781758,
            "program": "  public void doWithLibraries(LibraryCallback callback) throws IOException {\n\n    FileCollection compile = this.project.getConfigurations().getByName(\"compile\");\n\n    FileCollection runtime = this.project.getConfigurations().getByName(\"runtime\");\n    runtime = runtime.minus(compile);\n\n    FileCollection provided =\n        this.project.getConfigurations().findByName(this.providedConfigurationName);\n    if (provided != null) {\n      compile = compile.minus(provided);\n      runtime = compile.minus(provided);\n    }\n\n    libraries(LibraryScope.COMPILE, compile, callback);\n    libraries(LibraryScope.RUNTIME, runtime, callback);\n    libraries(LibraryScope.PROVIDED, provided, callback);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 129,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 201,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643319982952,
            "program": "  private <T extends Metric> T register(String name, MetricRegistrar<T> registrar) {\n    Reservoir reservoir = this.reservoirFactory.getReservoir(name);\n    if (reservoir == null) {\n      return registrar.register(this.registry, name);\n    }\n    Metric metric = this.registry.getMetrics().get(name);\n    if (metric != null) {\n      registrar.checkExisting(metric);\n      return (T) metric;\n    }\n    try {\n      return this.registry.register(name, registrar.createForReservoir(reservoir));\n    } catch (IllegalArgumentException ex) {\n      Metric added = this.registry.getMetrics().get(name);\n      registrar.checkExisting(added);\n      return (T) added;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 145,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 236,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643320209624,
            "program": "  public boolean dispatchTouchEvent(MotionEvent ev) {\n    if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n      if (!mTouchEnabled) {\n        mTouchCancelled = true;\n        return false;\n      }\n      mTouchCancelled = false;\n    } else if (mTouchCancelled) {\n      return false;\n    } else if (!mTouchEnabled) {\n      MotionEvent cancel = MotionEvent.obtain(ev);\n      cancel.setAction(MotionEvent.ACTION_CANCEL);\n      super.dispatchTouchEvent(cancel);\n      cancel.recycle();\n      mTouchCancelled = true;\n      return false;\n    }\n    return super.dispatchTouchEvent(ev);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 106,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "613621257-1643334827975": [
        {
            "ProgrammID": 161,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643335424964,
            "program": "  protected void handleRefCursorOutputParameter(\r\n      CallableStatement cs,\r\n      ParameterMapping parameterMapping,\r\n      int parameterMappingIndex,\r\n      MetaObject metaParam)\r\n      throws SQLException {\r\n    final ResultSet rs = (ResultSet) cs.getObject(parameterMappingIndex + 1);\r\n    final String resultMapId = parameterMapping.getResultMapId();\r\n    if (resultMapId != null) {\r\n      final ResultMap resultMap = configuration.getResultMap(resultMapId);\r\n      final DefaultResultHandler resultHandler =\r\n          new DefaultResultHandler(configuration.getDefaultListResultHandlerType());\r\n      ResultColumnCache resultColumnCache = new ResultColumnCache(rs.getMetaData(), configuration);\r\n      handleRowValues(rs, resultMap, resultHandler, new RowBounds(), resultColumnCache);\r\n      metaParam.setValue(parameterMapping.getProperty(), resultHandler.getResultList());\r\n    } else {\r\n      throw new ExecutorException(\r\n          \"Parameter requires ResultMap for output types of java.sql.ResultSet\");\r\n    }\r\n    rs.close();\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 143,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 226,
            "lineNumberOfError": 20,
            "attempt": 1,
            "expectedAnswer": 24,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643335461831,
            "program": "  public void testMethodAnnotationsWrapper()\n      throws IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n    WrapperProxetta proxetta =\n        WrapperProxetta.withAspects(\n            new ProxyAspect(\n                HeroProxyAdvice.class,\n                new AllRealMethodsPointcut() {\n                  @Override\n                  public boolean apply(MethodInfo methodInfo) {\n                    if (!methodInfo.isTopLevelMethod()) {\n                      return false;\n                    }\n                    return super.apply(methodInfo);\n                  }\n                }))\n        // .setDebugFolder(\"/Users/igor/\")\n        ;\n\n    WrapperProxettaBuilder proxettaBuilder = proxetta.builder();\n    proxettaBuilder.setTarget(Hero.class);\n    proxetta.setVariableClassName(true);\n    Object hero = proxettaBuilder.newInstance();\n\n    Method nameMethod = hero.getClass().getMethod(\"name\");\n    assertEquals(\"BatmanHero37W88.3CatWoman99speeeeedXRAYnull\", nameMethod.invoke(nameMethod));\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 129,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 213,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643335673545,
            "program": "  public XmlObject readFrom(\n      Class<XmlObject> type,\n      Type genericType,\n      Annotation[] annotations,\n      MediaType m,\n      MultivaluedMap<String, String> headers,\n      InputStream is)\n      throws IOException {\n    XmlObject result = null;\n\n    try {\n\n      Map<String, String> nstojns = new HashMap<String, String>();\n\n      MappedXMLInputFactory factory = new MappedXMLInputFactory(nstojns);\n      XMLStreamReader xsr = factory.createXMLStreamReader(is);\n      Reader r = (Reader) xsr;\n      result = parseXmlBean(type, r);\n\n      xsr.close();\n      xsr = null;\n\n    } catch (XMLStreamException e) {\n      throw new WebApplicationException(HttpURLConnection.HTTP_INTERNAL_ERROR);\n    }\n\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 127,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 219,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643335896091,
            "program": "  public static Throwable unwrapCause(Throwable t) {\n    int counter = 0;\n    Throwable result = t;\n    while (result instanceof ElasticSearchWrapperException) {\n      if (t.getCause() == null) {\n        return result;\n      }\n      if (t.getCause() == t) {\n        return result;\n      }\n      if (counter++ > 10) {\n        // dear god, if we got more than 10 levels down, WTF? just bail\n        logger.warn(\"Exception cause unwrapping ran for 10 levels...\", t);\n        return result;\n      }\n      result = t.getCause();\n    }\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 90,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 204,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643336050997,
            "program": "  static ErrorProneAnalyzer createAnalyzer(\n      ScannerSupplier scannerSupplier,\n      ErrorProneOptions epOptions,\n      Context context,\n      RefactoringCollection[] refactoringCollection) {\n    if (!epOptions.patchingOptions().doRefactor()) {\n      return ErrorProneAnalyzer.createByScanningForPlugins(scannerSupplier, epOptions, context);\n    }\n    refactoringCollection[0] = RefactoringCollection.refactor(epOptions.patchingOptions());\n\n    // Refaster refactorer or using builtin checks\n    CodeTransformer codeTransformer =\n        epOptions\n            .patchingOptions()\n            .customRefactorer()\n            .or(\n                () -> {\n                  ScannerSupplier toUse = ErrorPronePlugins.loadPlugins(scannerSupplier, context);\n                  Set<String> namedCheckers = epOptions.patchingOptions().namedCheckers();\n                  if (!namedCheckers.isEmpty()) {\n                    toUse = toUse.filter(bci -> namedCheckers.contains(bci.canonicalName()));\n                  }\n                  return ErrorProneScannerTransformer.create(toUse.applyOverrides(epOptions).get());\n                })\n            .get();\n\n    return ErrorProneAnalyzer.createWithCustomDescriptionListener(\n        codeTransformer, epOptions, context, refactoringCollection[0]);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 182,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 169,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643336217815,
            "program": "  public static String getGoExecutablePath(@Nullable String sdkHomePath) {\n    if (sdkHomePath != null) {\n      if (isAppEngineSdkPath(sdkHomePath)) {\n        String goExecutablePath = PathUtil.toSystemIndependentName(sdkHomePath);\n        goExecutablePath =\n            StringUtil.trimEnd(goExecutablePath, GoConstants.APP_ENGINE_GO_ROOT_DIRECTORY_PATH);\n\n        boolean gcloudInstallation =\n            sdkHomePath.endsWith(GoConstants.GCLOUD_APP_ENGINE_DIRECTORY_PATH);\n        if (gcloudInstallation) {\n          goExecutablePath =\n              FileUtil.join(\n                  StringUtil.trimEnd(\n                      goExecutablePath, GoConstants.GCLOUD_APP_ENGINE_DIRECTORY_PATH),\n                  \"bin\");\n        }\n        return FileUtil.join(\n            goExecutablePath, GoEnvironmentUtil.getGaeExecutableFileName(gcloudInstallation));\n      } else {\n        return FileUtil.join(\n            sdkHomePath,\n            \"bin\",\n            GoEnvironmentUtil.getBinaryFileNameForPath(GoConstants.GO_EXECUTABLE_NAME));\n      }\n    }\n    return null;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 130,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 210,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643336460282,
            "program": "  private KadaneResult kadane(int arr[]) {\n    int max = 0;\n    int maxStart = -1;\n    int maxEnd = -1;\n    int currentStart = 0;\n    int maxSoFar = 0;\n    for (int i = 0; i < arr.length; i++) {\n      maxSoFar += arr[i];\n      if (maxSoFar < 0) {\n        maxSoFar = 0;\n        currentStart = i + 1;\n      }\n      if (max < maxSoFar) {\n        maxStart = currentStart;\n        maxEnd = i;\n        max = maxSoFar;\n      }\n    }\n    return new KadaneResult(max, maxStart, maxEnd);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 112,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 163,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643336478513,
            "program": "  public String getLabel(Locale locale) {\n    ResourceBundle resourceBundle =\n        ResourceBundleUtil.getBundle(\"content.Language\", locale, getClass());\n\n    return LanguageUtil.get(locale, getKey());\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 37,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "680952074-1643360843850": [
        {
            "ProgrammID": 196,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 16,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643361571186,
            "program": "  protected boolean matchRequest(Request request) {\n\n    // Has a session been created?\n    Session session = request.getSessionInternal(false);\n    if (session == null) return (false);\n\n    // Is there a saved request?\n    SavedRequest sreq = (SavedRequest) session.getNote(Constants.FORM_REQUEST_NOTE);\n    if (sreq == null) return (false);\n\n    // Is there a saved principal?\n    if (session.getNote(Constants.FORM_PRINCIPAL_NOTE) == null) return (false);\n\n    // Does the request URI match?\n    String requestURI = request.getRequestURI();\n    if (requestURI == null) return (false);\n    return (requestURI.equals(request.getRequestURI()));\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 108,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 170,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643361630721,
            "program": "  public <T> ICompletableFuture<T> submitInternal(final Callable<T> command) {\n    CompletableFutureTask futureTask = new CompletableFutureTask(command, internalExecutor);\n    internalExecutor.submit(futureTask);\n    return futureTask;\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 40,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 211,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 14,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643361874133,
            "program": "  public void addAllUpdates(RightTupleSets tupleSets) {\n    RightTupleSetsImpl tupleSetsImpl = (RightTupleSetsImpl) tupleSets;\n    if (updateFirst == null) {\n      updateFirst = tupleSetsImpl.getUpdateFirst();\n      updateSize = tupleSetsImpl.updateSize;\n    } else {\n      RightTuple current = updateFirst;\n      RightTuple last = null;\n      while (current != null) {\n        last = current;\n        current = current.getStagedNext();\n      }\n      RightTuple rightTuple = tupleSetsImpl.getUpdateFirst();\n      last.setStagedNext(rightTuple);\n      rightTuple.setStagePrevious(rightTuple);\n      updateSize = updateSize + tupleSetsImpl.updateSize();\n    }\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 105,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 200,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643361966015,
            "program": "  private void checkChunkReady(Vector3i pos) {\n    if (worldEntity.exists()) {\n      for (Vector3i adjPos : Region3i.createFromCenterExtents(pos, LOCAL_REGION_EXTENTS)) {\n        Chunk chunk = getChunk(pos);\n        if (chunk == null || chunk.getChunkState() != Chunk.State.COMPLETE) {\n          return;\n        }\n      }\n      worldEntity.send(new ChunkReadyEvent(pos));\n    }\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 76,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 218,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643362022406,
            "program": "  protected static int calculateShift(int minimumValue, int maximumValue) {\n    int shift = 0;\n    int value = 1;\n    while (value < minimumValue && value < minimumValue) {\n      value <<= 1;\n      shift++;\n    }\n    return shift;\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 45,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 215,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643362114710,
            "program": "  protected void filterResults(List<AuxiliaryResolveInfo> results) {\n    // only do work if ordering is enabled [most of the time it won't be]\n    if (mOrderResult.size() == 0) {\n      return;\n    }\n    int resultSize = results.size();\n    for (int i = 0; i < resultSize; i++) {\n      final InstantAppResolveInfo info = results.get(i).resolveInfo;\n      final String packageName = info.getPackageName();\n      final Pair<Integer, InstantAppResolveInfo> savedInfo = mOrderResult.get(packageName);\n      if (savedInfo == null) {\n        // package doesn't having ordering\n        continue;\n      }\n      if (savedInfo.second == info) {\n        // circled back to the highest ordered item; remove from order list\n        mOrderResult.remove(packageName);\n        if (mOrderResult.size() == 0) {\n          // no more ordered items\n          break;\n        }\n        continue;\n      }\n      // item has a worse order, remove it from the result list\n      results.remove(i);\n      resultSize--;\n      i--;\n    }\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 146,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 173,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643362132472,
            "program": "  private static boolean shouldBeGenerated(PsiMethod method) {\n    for (PsiMethod psiMethod : method.findSuperMethods()) {\n      if (!psiMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        final PsiType type = method.getReturnType();\n        final PsiType superType = psiMethod.getReturnType();\n        if (type != null && superType != null && !superType.isAssignableFrom(type)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 83,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 168,
            "lineNumberOfError": 24,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643362360605,
            "program": "  public void visit(final ParserRuleContext ancestorNode, final SQLStatement statement) {\n    AlterTableStatement alterStatement = (AlterTableStatement) statement;\n\n    ParserRuleContext modifyColumnCtx =\n        TreeUtils.getFirstChildByRuleName(ancestorNode, \"renameColumn\");\n    if (null == modifyColumnCtx) {\n      return;\n    }\n\n    List<ParserRuleContext> columnNodes =\n        TreeUtils.getAllDescendantByRuleName(modifyColumnCtx, \"columnName\");\n    if (null == columnNodes || columnNodes.size() != 2) {\n      return;\n    }\n\n    String oldName = columnNodes.get(0).getText();\n    String newName = columnNodes.get(1).getText();\n    ColumnDefinition oldDefinition = alterStatement.getUpdateColumns().remove(oldName);\n    if (null != oldDefinition) {\n      oldDefinition.setName(newName);\n    } else {\n      oldDefinition = new ColumnDefinition(newName, null, null, false);\n    }\n\n    alterStatement.getUpdateColumns().put(oldName, oldDefinition);\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 164,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1312714739-1643380304541": [
        {
            "ProgrammID": 183,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643380889450,
            "program": "  void updateRulesForTempWhitelistChangeLocked() {\n    final List<UserInfo> users = mUserManager.getUsers();\n    for (int i = 0; i < users.size(); i++) {\n      final UserInfo user = users.get(i);\n      for (int j = mPowerSaveTempWhitelistAppIds.size() - 1; j >= 0; j--) {\n        int appId = mPowerSaveTempWhitelistAppIds.keyAt(j);\n        int uid = UserHandle.getUid(user.id, appId);\n        updateRuleForAppIdleLocked(uid);\n        updateRuleForDeviceIdleLocked(uid);\n        updateRulesForRestrictPowerLocked(uid);\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 111,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 171,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643380956251,
            "program": "  private void scanOverrides(Path overrideDirectory, Path basePath) {\n    try {\n      for (Path child : Files.newDirectoryStream(overrideDirectory)) {\n        if (Files.isDirectory(child)) {\n          scanOverrides(child, basePath);\n        } else if (Files.isRegularFile(child)) {\n          Path relativePath = basePath.relativize(child);\n          Path modulePath = relativePath.subpath(0, 1);\n          AssetUri uri = getUri(modulePath.toString(), modulePath.relativize(relativePath));\n          if (uri != null) {\n            try {\n              addOverride(uri, child.toUri().toURL());\n            } catch (MalformedURLException e) {\n              logger.warn(\"Failed to load override {}\", child, e.getMessage());\n            }\n          }\n        }\n      }\n    } catch (IOException e) {\n      logger.error(\"Failed to scan override path: {}\", overrideDirectory, e);\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 166,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 227,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643380997005,
            "program": "  public void setPermissions(final List<String> permissions) {\n    final List<String> perms = Lists.newArrayList(permissions);\n    // Do not store the dynamic user self edit permissions\n    perms.removeAll(this.permissions.userSelfEditPermissions(getName()));\n    fields.put(PERMISSIONS, permissions);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 52,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 188,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643381099766,
            "program": "  private boolean isSunUpAllDay(Calendar calendar, double latitude, double longitude) {\n    Calendar cal = DateTimeUtils.truncateToMidnight(calendar);\n    Sun sun = new Sun();\n    for (int minutes = 0; minutes <= MINUTES_PER_DAY; minutes += CURVE_TIME_INTERVAL) {\n      setSunPosition(cal, latitude, longitude, sun);\n      if (sun.getPosition().getElevation() < SUN_ANGLE) {\n        return false;\n      }\n      cal.add(Calendar.MINUTE, CURVE_TIME_INTERVAL);\n    }\n    return true;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 94,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 239,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643381123395,
            "program": "  public void addStream(String meetingId, VideoStream vs) {\r\n    Meeting m = meetings.get(meetingId);\r\n    if (m != null) {\r\n      m.addStream(vs);\r\n    } else {\r\n      Meeting nm = new Meeting(meetingId);\r\n      nm.addStream(vs);\r\n      add(m);\r\n    }\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 61,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 192,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643381166600,
            "program": "  static void registerTransformers(SubsystemRegistration subsystem) {\n    ResourceTransformationDescriptionBuilder builder110 =\n        TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n    ResourceAdapterResourceDefinition.registerTransformers110(builder110);\n    TransformationDescription.Tools.register(\n        builder110.build(), subsystem, ModelVersion.create(1, 1, 0));\n    ResourceTransformationDescriptionBuilder builder120 =\n        TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n    ResourceAdapterResourceDefinition.registerTransformers120(builder120);\n    TransformationDescription.Tools.register(\n        builder120.build(), subsystem, ModelVersion.create(1, 2, 0));\n    // Apply same to RBAC-updated version\n    TransformationDescription.Tools.register(\n        builder120.build(), subsystem, ModelVersion.create(1, 3, 0));\n    ResourceTransformationDescriptionBuilder builder200 =\n        TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n    ResourceAdapterResourceDefinition.registerTransformers200(builder200);\n    TransformationDescription.Tools.register(\n        builder200.build(), subsystem, ModelVersion.create(2, 0, 0));\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 167,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 203,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643381192173,
            "program": "  protected void validateImport(\n      Map<String, List<StagedModel>> dependentStagedModelsMap, Group group) throws Exception {\n\n    List<StagedModel> dependentStagedModels =\n        dependentStagedModelsMap.get(MDRRuleGroup.class.getSimpleName());\n\n    Assert.assertEquals(1, dependentStagedModels.size());\n\n    MDRRuleGroup ruleGroup = (MDRRuleGroup) dependentStagedModels.get(0);\n\n    MDRRuleGroupLocalServiceUtil.getMDRRuleGroupByUuidAndGroupId(\n        ruleGroup.getUuid(), ruleGroup.getGroupId());\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 84,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 181,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643381238618,
            "program": "  public void centerOnGraph() {\n    float graphWidth = Math.abs(limits.getMaxXoctree() - limits.getMinXoctree());\n    float graphHeight = Math.abs(limits.getMaxYoctree() - limits.getMinYoctree());\n\n    float currentDistanceGraphRatioX =\n        Math.abs(graphDrawable.viewport.get(2) / (float) graphDrawable.getDraggingMarkerX())\n            / graphDrawable.cameraLocation[2];\n    float currentDistanceGraphRatioY =\n        Math.abs(graphDrawable.viewport.get(3) / (float) graphDrawable.getDraggingMarkerY())\n            / graphDrawable.cameraLocation[2];\n    float newCameraLocationX = graphWidth / currentDistanceGraphRatioX;\n    float newCameraLocationY = graphHeight / currentDistanceGraphRatioY;\n    float newCameraLocation = Math.max(newCameraLocationX, newCameraLocationY);\n\n    graphDrawable.cameraLocation[0] = limits.getMinXoctree() + graphWidth / 2;\n    graphDrawable.cameraLocation[1] = limits.getMinYoctree() + graphHeight / 2;\n    graphDrawable.cameraLocation[2] = newCameraLocation;\n\n    graphDrawable.cameraTarget[0] = graphDrawable.cameraLocation[0];\n    graphDrawable.cameraTarget[1] = graphDrawable.cameraLocation[1];\n    graphDrawable.cameraTarget[2] = 0;\n\n    // Refresh\n    engine.getScheduler().requireUpdateVisible();\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 229,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1354178326-1643393727547": [
        {
            "ProgrammID": 205,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643394338648,
            "program": "  protected int putCodeWScope(String name, CodeWScope code) {\n    final int start = _buf.position();\n    _put(CODE_W_SCOPE, name);\n    int temp = _buf.position();\n    _buf.putInt(0);\n    _putValueString(code._code);\n    putObject(code._scope);\n    _buf.putInt(temp, _buf.position() - start);\n    return _buf.position() - start;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 83,
            "ctx": "commercial",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 233,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643394484231,
            "program": "  public Alarm saveAlarm(@RequestBody Alarm alarm) throws ThingsboardException {\n    try {\n      alarm.setTenantId(getCurrentUser().getTenantId());\n      Alarm savedAlarm = checkNotNull(alarmService.createOrUpdateAlarm(alarm));\n      logEntityAction(\n          savedAlarm.getId(),\n          savedAlarm,\n          getCurrentUser().getCustomerId(),\n          alarm.getId() == null ? ActionType.ADDED : ActionType.UPDATED,\n          null);\n      return savedAlarm;\n    } catch (Exception e) {\n      logEntityAction(\n          emptyId(EntityType.ALARM),\n          alarm,\n          null,\n          alarm.getId() == null ? ActionType.ADDED : ActionType.UPDATED,\n          e);\n      throw handleException(e);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 127,
            "ctx": "commercial",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 222,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643394649179,
            "program": "  private Template generateScaffoldedTemplate(\n      GrailsWebRequest webRequest, String templateName, String uri) throws IOException {\n    Template t = null;\n    Collection<String> controllerActions = scaffoldedActionMap.get(webRequest.getControllerName());\n    if (controllerActions != null && controllerActions.contains(webRequest.getActionName())) {\n      GrailsDomainClass domainClass =\n          controllerToScaffoldedDomainClassMap.get(webRequest.getControllerName());\n      if (domainClass != null) {\n        int i = uri.lastIndexOf('/');\n        String scaffoldedtemplateName = i > -1 ? uri.substring(i) : uri;\n        if (scaffoldedtemplateName.toLowerCase().endsWith(\".gsp\")) {\n          scaffoldedtemplateName =\n              scaffoldedtemplateName.substring(0, scaffoldedtemplateName.length() - 4);\n        }\n        FastStringWriter sw = new FastStringWriter();\n        ReflectionUtils.invokeMethod(\n            generateViewMethod,\n            scaffoldingTemplateGenerator,\n            domainClass,\n            scaffoldedtemplateName,\n            sw);\n        t = groovyPagesTemplateEngine.createTemplate(sw.toString(), uri);\n      }\n    }\n    return t;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 180,
            "ctx": "commercial",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 194,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643394862777,
            "program": "  public final View getView(int position, View convertView, ViewGroup parent) {\n    ContextualUndoView contextualUndoView = (ContextualUndoView) convertView;\n    if (contextualUndoView == null) {\n      contextualUndoView =\n          new ContextualUndoView(parent.getContext(), mUndoLayoutId, mCountDownTextViewResId);\n      contextualUndoView\n          .findViewById(mUndoActionId)\n          .setOnClickListener(new UndoListener(contextualUndoView));\n    }\n\n    View contentView = super.getView(position, contextualUndoView.getContentView(), parent);\n    contextualUndoView.updateContentView(contentView);\n\n    long itemId = getItemId(position);\n\n    if (itemId == mCurrentRemovedId) {\n      contextualUndoView.displayUndo();\n      mCurrentRemovedView = contextualUndoView;\n      long millisLeft = mAutoDeleteDelayMillis - (System.currentTimeMillis() - mDismissStartMillis);\n      if (mCountDownFormatter != null) {\n        mCurrentRemovedView.updateCountDownTimer(\n            mCountDownFormatter.getCountDownString(millisLeft));\n      }\n    } else {\n      contextualUndoView.displayContentView();\n    }\n\n    contextualUndoView.setItemId(itemId);\n    return contextualUndoView;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 169,
            "ctx": "commercial",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 232,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 12,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643394993081,
            "program": "  protected double getDropoutFromConfig(Map<String, Object> layerConfig)\n      throws InvalidKerasConfigurationException {\n    Map<String, Object> innerConfig = getInnerLayerConfigFromConfig(layerConfig);\n    /* NOTE: Keras \"dropout\" parameter determines dropout probability,\n     * while DL4J \"dropout\" parameter determines retention probability.\n     */\n    double dropout = 1.0;\n    if (innerConfig.containsKey(LAYER_FIELD_DROPOUT)) {\n      /* For most feedforward layers. */\n      dropout = 1.0 - (double) innerConfig.get(LAYER_FIELD_DROPOUT);\n    } else if (layerConfig.containsKey(LAYER_FIELD_DROPOUT_W)) {\n      /* For LSTMs. */\n      dropout = 1.0 - (double) layerConfig.get(LAYER_FIELD_DROPOUT_W);\n    }\n    return dropout;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 88,
            "ctx": "commercial",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 179,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643395048625,
            "program": "  public FileType findFileTypeByName(String fileTypeName) {\n    FileType type = getStdFileType(fileTypeName);\n    // TODO: Abstract file types are not std one, so need to be restored specially,\n    // currently there are 6 of them and restoration does not happen very often so just iteration is\n    // enough\n    if (type == PlainTextFileType.INSTANCE && !fileTypeName.equals(type.getName())) {\n      for (FileType fileType : getRegisteredFileTypes()) {\n        if (fileType.equals(fileType.getName())) {\n          return fileType;\n        }\n      }\n    }\n    return type;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 71,
            "ctx": "commercial",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 224,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643395137521,
            "program": "  private void addCustomDefinition(\n      @NotNull AntDomNamedElement declaringTag,\n      String customTagName,\n      String nsUri,\n      Class clazz,\n      String error) {\n    final XmlName xmlName = new XmlName(customTagName, nsUri == null ? \"\" : nsUri);\n    if (error != null) {\n      myErrors.put(xmlName, error);\n    }\n    myCustomElements.put(xmlName, clazz);\n    myDeclarations.put(xmlName, declaringTag);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 76,
            "ctx": "commercial",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 172,
            "lineNumberOfError": 20,
            "attempt": 1,
            "expectedAnswer": 20,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643395255814,
            "program": "  public Element writeXML(Document document) {\n    Element modelE = document.createElement(\"statisticsmodel\");\n\n    Element resultsE = document.createElement(\"results\");\n    for (Map.Entry<StatisticsUI, String> entry : resultMap.entrySet()) {\n      if (entry.getValue() != null && !entry.getValue().isEmpty()) {\n        Element resultE = document.createElement(\"result\");\n        resultE.setAttribute(\"class\", entry.getKey().getClass().getName());\n        resultE.setAttribute(\"value\", entry.getValue());\n        resultsE.appendChild(resultE);\n      }\n    }\n    modelE.appendChild(resultsE);\n\n    Element reportsE = document.createElement(\"reports\");\n    for (Map.Entry<Class, String> entry : reportMap.entrySet()) {\n      if (entry.getValue() != null && !entry.getValue().isEmpty()) {\n        Element reportE = document.createElement(\"report\");\n        reportE.setAttribute(\"class\", entry.getKey().getName());\n        reportE.setAttribute(\"value\", entry.getValue());\n        resultsE.appendChild(reportE);\n      }\n    }\n    modelE.appendChild(reportsE);\n\n    return modelE;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 240,
            "ctx": "commercial",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1967205642-1643442958616": [
        {
            "ProgrammID": 237,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643445007075,
            "program": "  private void drawAnnotation(\n      Canvas canvas, LineStyle style, LinePoint linePoint, float rawValueX, float rawValueY) {\n    final ChartCalculator chartCalculator = mChart.getChartCalculator();\n    final float offset = Utils.dp2px(mContext, style.getPointRadius());\n    final String text = style.getLineValueFormatter().formatValue(linePoint);\n    annotationPaint.setTextSize(Utils.sp2px(mContext, style.getTextSize()));\n    annotationPaint.getTextBounds(text, 0, text.length(), textBoundsRect);\n    float left = rawValueX - textBoundsRect.width() / 2 - mAnnotationMargin;\n    float right = rawValueX + textBoundsRect.width() / 2 + mAnnotationMargin;\n    float top = rawValueY - offset - textBoundsRect.height() - mAnnotationMargin * 2;\n    float bottom = rawValueY - offset;\n    if (top < chartCalculator.mContentRect.top) {\n      top = rawValueY + offset;\n      bottom = rawValueY + offset + textBoundsRect.height() + mAnnotationMargin * 2;\n    }\n    if (right < chartCalculator.mContentRect.left) {\n      left = rawValueX;\n      right = rawValueX + textBoundsRect.width() + mAnnotationMargin * 2;\n    }\n    if (right > chartCalculator.mContentRect.right) {\n      left = rawValueX - textBoundsRect.width() - mAnnotationMargin * 2;\n      right = rawValueX;\n    }\n    annotationRect.set(left, top, right, bottom);\n    annotationPaint.setColor(style.getColor());\n    canvas.drawRoundRect(annotationRect, mAnnotationMargin, mAnnotationMargin, annotationPaint);\n    annotationPaint.setColor(style.getTextColor());\n    canvas.drawText(text, left + mAnnotationMargin, bottom - mAnnotationMargin, annotationPaint);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 311,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 229,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643445066934,
            "program": "  private List<Transaction> loadErrorTransactions() {\n\n    TransactionRepository transactionRepository =\n        transactionConfigurator.getTransactionRepository();\n\n    long currentTimeInMillis = Calendar.getInstance().getTimeInMillis();\n\n    List<Transaction> transactions =\n        transactionRepository.findAllUnmodifiedSince(\n            new Date(\n                currentTimeInMillis\n                    - transactionConfigurator.getRecoverConfig().getRecoverDuration() * 1000));\n\n    List<Transaction> recoverTransactions = new ArrayList<Transaction>();\n\n    for (Transaction transaction : transactions) {\n\n      int result = transactionRepository.update(transaction);\n\n      if (result > 0) {\n        recoverTransactions.add(transaction);\n      }\n    }\n\n    return recoverTransactions;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 112,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 199,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643445111275,
            "program": "  private static final Comparator<Method> METHOD_COMPARATOR =\n      new Comparator<Method>() {\n        public int compare(final Method o1, final Method o2) {\n          int cmp = o1.getName().compareTo(o2.getName());\n          if (cmp != 0) return cmp;\n          cmp = o1.getParameterTypes().length - o2.getParameterTypes().length;\n          return cmp;\n        }\n      };\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 81,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 174,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 21,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643445299140,
            "program": "  public PsiElement simplify(PsiMethodCallExpression call) {\n    PsiExpression value = myValuePointer.getElement();\n    if (value == null) return null;\n    PsiMethodCallExpression qualifierCall = getQualifierMethodCall(call);\n    if (qualifierCall == null) return null;\n    PsiExpressionList qualifierArgs = qualifierCall.getArgumentList();\n    CommentTracker ct = new CommentTracker();\n    PsiReferenceParameterList typeParameters =\n        qualifierCall.getMethodExpression().getParameterList();\n    String typeParametersText = typeParameters == null ? \"\" : ct.text(typeParameters);\n    PsiElement result =\n        ct.replaceAndRestoreComments(\n            call,\n            CommonClassNames.JAVA_UTIL_ARRAYS\n                + \".\"\n                + typeParametersText\n                + \"asList\"\n                + ct.text(qualifierArgs)\n                + \".contains(\"\n                + ct.text(value)\n                + \")\");\n    return JavaCodeStyleManager.getInstance(call.getProject()).shortenClassReferences(result);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 145,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 228,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643445423612,
            "program": "  public void loadPlugin(File file) throws Exception {\n    Preconditions.checkNotNull(file, \"file\");\n    Preconditions.checkArgument(file.isFile(), \"Must load from file\");\n\n    try (JarFile jar = new JarFile(file)) {\n      JarEntry pdf = jar.getJarEntry(\"plugin.yml\");\n      Preconditions.checkNotNull(pdf, \"Plugin must have a plugin.yml\");\n\n      try (InputStream in = jar.getInputStream(pdf)) {\n        PluginDescription desc = yaml.loadAs(in, PluginDescription.class);\n        URLClassLoader loader = new URLClassLoader(new URL[] {file.toURI().toURL()});\n        Class<?> main = loader.loadClass(desc.getMain());\n        Plugin plugin = (Plugin) main.getDeclaredConstructor().newInstance();\n\n        plugin.init(desc);\n        plugins.put(desc.getName(), plugin);\n        plugin.onLoad();\n        ProxyServer.getInstance()\n            .getLogger()\n            .log(\n                Level.INFO,\n                \"Loaded plugin {0} version {1} by {2}\",\n                new Object[] {desc.getName(), desc.getVersion(), desc.getAuthor()});\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 218,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 193,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643445548714,
            "program": "  public ObjectName getObjectName(RouteContext routeContext, ProcessorType processor)\n      throws MalformedObjectNameException {\n    Endpoint<? extends Exchange> ep = routeContext.getEndpoint();\n    String ctxid = ep != null ? getContextId(ep.getCamelContext()) : VALUE_UNKNOWN;\n    String cid = getComponentId(ep);\n    String id = VALUE_UNKNOWN.equals(cid) ? getEndpointId(ep) : \"[\" + cid + \"]\" + getEndpointId(ep);\n    String nodeId = processor.idOrCreate();\n\n    StringBuffer buffer = new StringBuffer();\n    buffer.append(domainName).append(\":\");\n    buffer.append(KEY_CONTEXT + \"=\").append(ctxid).append(\",\");\n    buffer.append(KEY_ROUTE + \"=\").append(id).append(\",\");\n    buffer.append(KEY_TYPE + \"=\" + TYPE_PROCESSOR + \",\");\n    buffer.append(KEY_NODE_ID + \"=\").append(nodeId).append(\",\");\n    buffer.append(KEY_NAME + \"=\").append(ObjectName.quote(processor.toString()));\n    return createObjectName(buffer);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 208,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 182,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643445637334,
            "program": "  private boolean getStringToReplace(\n      int textOffset,\n      int textEndOffset,\n      Document document,\n      FindModel findModel,\n      Ref<String> stringToReplace)\n      throws FindManager.MalformedReplacementStringException {\n    if (textOffset < 0 || textOffset >= document.getTextLength()) {\n      return false;\n    }\n    if (textEndOffset < 0 || textOffset > document.getTextLength()) {\n      return false;\n    }\n    FindManager findManager = FindManager.getInstance(myProject);\n    final CharSequence foundString =\n        document.getCharsSequence().subSequence(textOffset, textEndOffset);\n    PsiFile file = PsiDocumentManager.getInstance(myProject).getPsiFile(document);\n    FindResult findResult =\n        findManager.findString(\n            document.getCharsSequence(),\n            textOffset,\n            findModel,\n            file != null ? file.getVirtualFile() : null);\n    if (!findResult.isStringFound()\n        ||\n        // find result should be in needed range\n        !(findResult.getStartOffset() >= textOffset\n            && findResult.getEndOffset() <= textEndOffset)) {\n      return false;\n    }\n\n    stringToReplace.set(\n        FindManager.getInstance(myProject)\n            .getStringToReplace(foundString.toString(), findModel, textOffset, document.getText()));\n\n    return true;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 205,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 165,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643445725355,
            "program": "  private boolean sendRemoved(int fingerId, int groupId, int remaining) {\n    IFingerprintServiceReceiver receiver = getReceiver();\n    try {\n      if (receiver != null) {\n        // TODO: plumb remaining\n        receiver.onRemoved(getHalDeviceId(), fingerId, groupId, remaining);\n      }\n    } catch (RemoteException e) {\n      Slog.w(TAG, \"Failed to notify Removed:\", e);\n    }\n    return fingerId == 0;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 71,
            "ctx": "oss",
            "codebase": "others",
            "team": "small"
        }
    ],
    "656018942-1643454923629": [
        {
            "ProgrammID": 256,
            "lineNumberOfError": 17,
            "attempt": 1,
            "expectedAnswer": 20,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643455922599,
            "program": "  private void parseOptions(String optionsPart) {\n    for (String _part : optionsPart.split(\"&|;\")) {\n      int idx = _part.indexOf(\"=\");\n      if (idx >= 0) {\n        String key = _part.substring(0, idx).toLowerCase();\n        String value = _part.substring(idx + 1);\n        if (key.equals(\"maxpoolsize\")) _options.connectionsPerHost = Integer.parseInt(value);\n        else if (key.equals(\"minpoolsize\"))\n          LOGGER.warning(\"Currently No support in Java driver for Min Pool Size.\");\n        else if (key.equals(\"waitqueuemultiple\"))\n          _options.threadsAllowedToBlockForConnectionMultiplier = Integer.parseInt(value);\n        else if (key.equals(\"waitqueuetimeoutms\")) _options.maxWaitTime = Integer.parseInt(value);\n        else if (key.equals(\"connecttimeoutms\")) _options.connectTimeout = Integer.parseInt(value);\n        else if (key.equals(\"sockettimeoutms\")) _options.socketTimeout = Integer.parseInt(value);\n        else if (key.equals(\"autoconnectretry\")) _options.autoConnectRetry = _parseBoolean(value);\n        else if (key.equals(\"slaveok\")) _options.slaveOk = _parseBoolean(value);\n        else if (key.equals(\"safe\")) _options.safe = _parseBoolean(value);\n        else if (key.equals(\"w\")) _options.w = Integer.parseInt(value);\n        else if (key.equals(\"wtimeout\")) _options.wtimeout = Integer.parseInt(value);\n        else if (key.equals(\"fsync\")) _options.fsync = _parseBoolean(value);\n        else LOGGER.warning(\"Unknown or Unsupported Option '\" + value + \"'\");\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,review,test",
            "token": 320,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 240,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643456073353,
            "program": "  public void setImeWindowStatus(\n      IBinder token, IBinder startInputToken, int vis, int backDisposition) {\n    if (!calledWithValidToken(token)) {\n      return;\n    }\n\n    final StartInputInfo info;\n    synchronized (mMethodMap) {\n      info = mStartInputMap.get(startInputToken);\n      mImeWindowVis = vis;\n      mBackDisposition = backDisposition;\n      updateSystemUiLocked(token, vis, backDisposition);\n    }\n    mWindowManagerInternal.updateInputMethodWindowStatus(\n        token,\n        (vis & InputMethodService.IME_VISIBLE) != 0,\n        info != null ? info.mTargetWindow : null);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,review,test",
            "token": 93,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 274,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643456181063,
            "program": "  public static void unboxInlineClass(\n      @NotNull Type type,\n      @NotNull KotlinType targetInlineClassType,\n      @NotNull InstructionAdapter v) {\n    Type owner = KotlinTypeMapper.mapInlineClassTypeAsDeclaration(targetInlineClassType);\n\n    coerce(type, owner, v);\n\n    Type resultType = KotlinTypeMapper.mapUnderlyingTypeOfInlineClassType(targetInlineClassType);\n\n    if (TypeUtils.isNullableType(targetInlineClassType) && !isPrimitive(type)) {\n      boxOrUnboxWithNullCheck(v, vv -> invokeUnboxMethod(vv, owner, resultType));\n    } else {\n      invokeUnboxMethod(v, owner, resultType);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,review,test",
            "token": 96,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 245,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643456344097,
            "program": "  public static Range getRange(int startMonth, int startDay, int endMonth, int endDay) {\n    Calendar start = Calendar.getInstance();\n    start.set(Calendar.MONTH, startMonth);\n    start.set(Calendar.DAY_OF_MONTH, startDay);\n    start = truncateToMidnight(start);\n\n    Calendar end = Calendar.getInstance();\n    end.set(Calendar.MONTH, endMonth);\n    end.set(Calendar.DAY_OF_MONTH, endDay);\n    end.set(Calendar.HOUR_OF_DAY, 23);\n    end.set(Calendar.MINUTE, 59);\n    end.set(Calendar.SECOND, 59);\n    end.set(Calendar.MILLISECOND, 999);\n\n    return new Range(start, end);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,review,test",
            "token": 141,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 295,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643456519674,
            "program": "  protected final RedisClusterConfiguration getClusterConfiguration() {\n    if (this.clusterConfiguration != null) {\n      return this.clusterConfiguration;\n    }\n    if (this.properties.getCluster() == null) {\n      return null;\n    }\n    Cluster clusterProperties = this.properties.getCluster();\n    RedisClusterConfiguration config = new RedisClusterConfiguration(clusterProperties.getNodes());\n\n    if (clusterProperties.getMaxRedirects() != null) {\n      config.setMaxRedirects(config.getMaxRedirects());\n    }\n    return config;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,review,test",
            "token": 90,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 271,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643456690879,
            "program": "  private static void registerCustomAnnotators(\n      AnnotatorPool pool, AnnotatorImplementations annotatorImplementation, Properties inputProps) {\n    // add annotators loaded via reflection from class names specified\n    // in the properties\n    for (String property : inputProps.stringPropertyNames()) {\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName = property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        logger.info(\"Registering annotator \" + customName + \" with class \" + customClassName);\n        pool.register(\n            customName,\n            inputProps,\n            Lazy.of(() -> annotatorImplementation.custom(inputProps, property)));\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,review,test",
            "token": 105,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 241,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643456893267,
            "program": "  public URL getResource(String name) {\n    if (_notFound.contains(name)) {\n      if (LOG.isDebugEnabled()) LOG.debug(\"Not found cache hit resource {}\", name);\n      return null;\n    }\n\n    URL url = _cache.get(name);\n\n    if (url == null) {\n      // Not found in cache, try parent\n      url = super.getResource(name);\n\n      if (url == null) {\n        // Still not found, cache the not-found result\n        if (LOG.isDebugEnabled()) LOG.debug(\"Caching not found resource {}\", name);\n        _notFound.add(name);\n      } else {\n        // Cache the new result\n        _cache.putIfAbsent(name, url);\n      }\n    }\n\n    return url;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,review,test",
            "token": 114,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 308,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643457066315,
            "program": "  protected long getResourcePermissionCount(long companyId, String name, int scope, long roleId) {\n\n    DynamicQuery dynamicQuery = _resourcePermissionLocalService.dynamicQuery();\n\n    Property companyIdProperty = PropertyFactoryUtil.forName(\"companyId\");\n\n    dynamicQuery.add(companyIdProperty.eq(companyId));\n\n    Property nameProperty = PropertyFactoryUtil.forName(\"name\");\n\n    dynamicQuery.add(nameProperty.eq(name));\n\n    Property scopeProperty = PropertyFactoryUtil.forName(\"scope\");\n\n    dynamicQuery.add(scopeProperty.eq(scope));\n\n    Property roleIdProperty = PropertyFactoryUtil.forName(\"roleId\");\n\n    dynamicQuery.add(roleIdProperty.eq(roleId));\n\n    return _resourcePermissionLocalService.dynamicQueryCount(dynamicQuery);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop,review,test",
            "token": 123,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "2087051064-1643474364100": [
        {
            "ProgrammID": 283,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 22,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643501887690,
            "program": "  protected <T> void writeBody(\n      T o,\n      Message outMessage,\n      Class<?> cls,\n      Type type,\n      Annotation[] anns,\n      MultivaluedMap<String, Object> headers,\n      OutputStream os) {\n\n    if (o == null) {\n      return;\n    }\n    @SuppressWarnings(\"unchecked\")\n    Class<T> theClass = (Class<T>) cls;\n\n    MediaType contentType = MediaType.valueOf(headers.getFirst(\"Content-Type\").toString());\n\n    MessageBodyWriter<T> mbw =\n        ProviderFactory.getInstance(outMessage)\n            .createMessageBodyWriter(theClass, type, anns, contentType, outMessage);\n    if (mbw != null) {\n      try {\n        mbw.writeTo(o, cls, type, anns, contentType, headers, os);\n        if (os != null) {\n          os.flush();\n        }\n      } catch (Exception ex) {\n        reportMessageHandlerProblem(\"MSG_WRITER_PROBLEM\", cls, contentType, ex, null);\n      }\n    } else {\n      reportMessageHandlerProblem(\"NO_MSG_WRITER\", cls, contentType, null, null);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test",
            "token": 194,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 282,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643502008000,
            "program": "  public static net.osmand.Location convertLocation(Location l, OsmandApplication app) {\n    net.osmand.Location r = new net.osmand.Location(l.getProvider());\n    r.setLatitude(l.getLatitude());\n    r.setLongitude(l.getLongitude());\n    r.setTime(l.getTime());\n    if (l.hasAccuracy()) {\n      r.setAccuracy(l.getAccuracy());\n    }\n    if (l.hasSpeed()) {\n      r.setSpeed(l.getSpeed());\n    }\n    if (l.hasAltitude()) {\n      r.setAltitude(l.getAltitude());\n    }\n    if (l.hasBearing()) {\n      r.setBearing(l.getBearing());\n    }\n    if (l.hasAltitude() && app != null) {\n      double alt = l.getAltitude();\n      final GeoidAltitudeCorrection geo = app.getResourceManager().getGeoidAltitudeCorrection();\n      if (geo != null) {\n        alt -= geo.getGeoidHeight(l.getLatitude(), l.getLongitude());\n        r.setAltitude(alt);\n      }\n    }\n    return r;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test",
            "token": 229,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 285,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643502131557,
            "program": "  protected Principal getPrincipal(String username) {\n\n    User user = database.findUser(username);\n    if (user == null) {\n      return null;\n    }\n\n    List roles = new ArrayList();\n    Iterator uroles = user.getRoles();\n    while (uroles.hasNext()) {\n      Role role = (Role) uroles.next();\n      roles.add(role.getName());\n    }\n    Iterator groups = user.getGroups();\n    while (groups.hasNext()) {\n      Group group = (Group) groups.next();\n      uroles = group.getRoles();\n      while (uroles.hasNext()) {\n        Role role = (Role) uroles.next();\n        roles.add(role.getName());\n      }\n    }\n    return new GenericPrincipal(this, username, user.getPassword(), roles, user);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test",
            "token": 171,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 280,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643502185978,
            "program": "  public float dst(final Vector3 vector) {\r\n    final float a = vector.x - x;\r\n    final float b = vector.y - y;\r\n    final float c = vector.z - z;\r\n\r\n    return (float) Math.sqrt(a * a + b * b + c * c);\r\n  }\r\n",
            "exp": "2",
            "age": "30",
            "task": "test",
            "token": 61,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 269,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": 9,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643502250348,
            "program": "  private void initializeFromMailto(MailTo mailTo) {\n    recipientPresenter.initFromMailto(mailTo);\n\n    String subject = mailTo.getSubject();\n    if (subject != null && !subject.isEmpty()) {\n      mSubjectView.setText(subject);\n    }\n\n    String body = mailTo.getBody();\n    if (body != null && !subject.isEmpty()) {\n      mMessageContentView.setCharacters(body);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test",
            "token": 78,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 299,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643502353100,
            "program": "  public double distance(double centroidLengthSquare, Vector centroid, Vector v) {\n    if (centroid.size() != v.size()) {\n      throw new CardinalityException();\n    }\n\n    double result = centroidLengthSquare;\n    result += v.getDistanceSquared(centroid);\n    return result;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test",
            "token": 54,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 303,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643502424138,
            "program": "  public Map<String, T> copy(Map<String, T> value) {\n    if (value != null) {\n      Map<String, T> result = Maps.newHashMap();\n      for (Map.Entry<String, T> entry : result.entrySet()) {\n        result.put(entry.getKey(), contentsHandler.copy(entry.getValue()));\n      }\n      return result;\n    }\n    return null;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "test",
            "token": 89,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 260,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643502534585,
            "program": "  public InstallState getInstallState(Version system) {\r\n    if (StringUtils.isEmpty(installedRelease)) {\r\n      return InstallState.NOT_INSTALLED;\r\n    }\r\n    Version ir = Version.createVersion(installedRelease);\r\n    Version cr = Version.ZERO;\r\n    PluginRelease curr = getCurrentRelease(system);\r\n    if (curr != null) {\r\n      cr = Version.createVersion(curr.version);\r\n    }\r\n    switch (ir.compareTo(cr)) {\r\n      case -1:\r\n        return InstallState.UNKNOWN;\r\n      case 1:\r\n        return InstallState.UPDATE_AVAILABLE;\r\n      default:\r\n        return InstallState.INSTALLED;\r\n    }\r\n  }\r\n",
            "exp": "2",
            "age": "30",
            "task": "test",
            "token": 104,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1371832906-1643550107209": [
        {
            "ProgrammID": 281,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643550520474,
            "program": "  Map<VirtualFile, Object[]> getDirectInheritors(\n      @NotNull LightRef searchElement,\n      @NotNull GlobalSearchScope searchScope,\n      @NotNull GlobalSearchScope dirtyScope,\n      @NotNull FileType fileType,\n      @NotNull CompilerHierarchySearchType searchType)\n      throws StorageException {\n    GlobalSearchScope effectiveSearchScope =\n        GlobalSearchScope.notScope(dirtyScope).intersectWith(searchScope);\n    LanguageLightRefAdapter adapter = CompilerReferenceServiceImpl.findAdapterForFileType(fileType);\n    LOG.assertTrue(adapter != null, \"adapter is null for file type: \" + fileType);\n    Class<? extends LightRef> requiredLightRefClass = searchType.getRequiredClass(adapter);\n\n    Map<VirtualFile, Object[]> candidatesPerFile = new HashMap<>();\n    myIndex\n        .get(CompilerIndices.BACK_HIERARCHY)\n        .getData(searchElement)\n        .forEach(\n            (fileId, defs) -> {\n              final List<LightRef> requiredCandidates =\n                  defs.stream().filter(requiredLightRefClass::isInstance).collect(toList());\n              if (requiredCandidates.isEmpty()) return true;\n              final VirtualFile file = findFile(fileId);\n              if (file != null && effectiveSearchScope.contains(file)) {\n                candidatesPerFile.put(\n                    file, searchType.convertToIds(requiredCandidates, myIndex.getByteSeqEum()));\n              }\n              return true;\n            });\n    return candidatesPerFile.isEmpty() ? Collections.emptyMap() : candidatesPerFile;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 235,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 305,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643550557516,
            "program": "  private void assertEqualClusterDescriptions(\n      final ClusterDescription expected, final ClusterDescription actual) {\n    assertEquals(expected.getType(), actual.getType());\n    assertEquals(expected.getAll().size(), actual.getAll().size());\n    for (ServerDescription curExpected : actual.getAll()) {\n      ServerDescription curActual = getByServerAddress(curExpected.getAddress(), actual.getAll());\n      assertNotNull(curActual);\n      assertEqualServerDescriptions(curExpected, curActual);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 95,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 262,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643550626613,
            "program": "  protected void onNewIntent(Intent intent) {\n    super.onNewIntent(intent);\n    if (isFinishing()) return;\n\n    chatViewerAdapter.onChange();\n\n    String account = getAccount(intent);\n    String user = getUser(intent);\n    if (account == null || user == null) {\n      return;\n    }\n\n    LogManager.i(this, \"onNewIntent account: \" + account + \", user: \" + user);\n\n    actionWithUser = user;\n    actionWithAccount = user;\n\n    selectPage(false);\n    onChatSelected();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 92,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 249,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643550664216,
            "program": "  public DataResponse<Iterable<Dashboard>> getByServiceAndApplication(String component, String app)\n      throws HygieiaException {\n    Cmdb cmdbCompItem = cmdbService.configurationItemByConfigurationItem(component);\n    Cmdb cmdbAppItem = cmdbService.configurationItemByConfigurationItem(app);\n    Iterable<Dashboard> rt = null;\n\n    if (cmdbAppItem != null && cmdbAppItem != null) {\n      rt =\n          dashboardRepository\n              .findAllByConfigurationItemBusServObjectIdAndConfigurationItemBusAppObjectId(\n                  cmdbAppItem.getId(), cmdbCompItem.getId());\n    }\n    return new DataResponse<>(rt, System.currentTimeMillis());\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 94,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 286,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643550717114,
            "program": "  public static View findParentViewHolderItemView(View v) {\n    final ViewParent parent = v.getParent();\n    if (parent instanceof RecyclerView) {\n      // returns the passed instance if the parent is RecyclerView\n      return v;\n    } else if (parent instanceof View) {\n      // check the parent view recursively\n      return findParentViewHolderItemView((View) parent);\n    } else {\n      return null;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 55,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 289,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 18,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643550772862,
            "program": "  private String adjustPath(final String path) {\n    String adjustedPath = path;\n\n    if (RequestUtils.isDispatcherServletRequest()\n        && StringUtils.hasText(this.dispatcherServletPath)) {\n      if (!this.dispatcherServletPath.equals(\"/\")) {\n        adjustedPath = path.substring(this.dispatcherServletPath.length());\n        log.debug(\"Stripped dispatcherServletPath\");\n      }\n    } else if (RequestUtils.isZuulServletRequest()) {\n      if (StringUtils.hasText(this.zuulServletPath) && !this.zuulServletPath.equals(\"/\")) {\n        adjustedPath = path.substring(this.zuulServletPath.length());\n        log.debug(\"Stripped zuulServletPath\");\n      }\n    } else {\n      // do nothing\n    }\n\n    log.debug(\"adjustedPath=\" + path);\n    return adjustedPath;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 141,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 270,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643550833100,
            "program": "  private static APKModule getModuleForLinkable(\n      MergedLibNativeLinkable linkable,\n      ImmutableMap<NativeLinkable, APKModule> linkableToModuleMap) {\n    APKModule module = null;\n    for (NativeLinkable constituent : linkable.constituents.getLinkables()) {\n      APKModule constituentModule = linkableToModuleMap.get(constituent);\n      if (module == null) {\n        module = constituentModule;\n      }\n      if (module != constituentModule) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Native library merge of \")\n            .append(linkable)\n            .append(\" has inconsistent application module mappings: \");\n        for (NativeLinkable innerConstituent : linkable.constituents.getLinkables()) {\n          APKModule innerConstituentModule = linkableToModuleMap.get(constituent);\n          sb.append(innerConstituent).append(\" -> \").append(innerConstituentModule).append(\", \");\n        }\n        throw new RuntimeException(\n            \"Native library merge of \"\n                + linkable\n                + \" has inconsistent application module mappings: \"\n                + sb);\n      }\n    }\n    return Preconditions.checkNotNull(module);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 161,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 304,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643550892098,
            "program": "  static Object unwrapResourceIfNecessary(Object resource) {\n    Assert.notNull(resource, \"Resource must not be null\");\n    Object resourceRef = resource;\n    // unwrap infrastructure proxy\n    if (resourceRef instanceof InfrastructureProxy) {\n      resourceRef = ((InfrastructureProxy) resourceRef).getWrappedObject();\n    }\n    if (aopAvailable) {\n      // now unwrap scoped proxy\n      resourceRef = ScopedProxyUnwrapper.unwrapIfNecessary(resourceRef);\n    }\n    return resourceRef;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 62,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "2118805218-1643574310427": [
        {
            "ProgrammID": 259,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643575218434,
            "program": "  public boolean removeListener(final String eventId, final IDownloadListener listener) {\n    if (FileDownloadLog.NEED_LOG) {\n      FileDownloadLog.v(this, \"removeListener %s\", eventId);\n    }\n\n    LinkedList<IDownloadListener> container = listenersMap.get(eventId);\n    if (container == null) {\n      synchronized (eventId.intern()) {\n        container = listenersMap.get(eventId);\n      }\n    }\n\n    if (container == null || listener == null) {\n      return false;\n    }\n\n    synchronized (eventId.intern()) {\n      boolean succeed = container.remove(listener);\n      if (container.size() <= 0) {\n        listenersMap.remove(eventId);\n      }\n      return succeed;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,review,test",
            "token": 130,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 247,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643575429683,
            "program": "  public void go(\n      final Canvas container, HashMap<String, String[]> pages, String pageKey, boolean firstTime) {\n    this.pages = pages;\n    this.container = container;\n\n    if (firstTime) {\n      String token = History.getToken();\n      if (pageKey.equals(BLCLaunch.getSelectedPage(token))\n          && MasterView.moduleKey.equals(BLCLaunch.getSelectedModule(token))) {\n        String itemId = BLCLaunch.getDefaultItem(token);\n        showView(pages.get(pageKey)[0], pages.get(pageKey)[1], itemId);\n      } else {\n        buildHistoryNewItem(pageKey);\n      }\n      return;\n    }\n\n    if (pageKey != null && pages.get(pageKey) != null) {\n      if (SecurityManager.getInstance().isUserAuthorizedToViewSection(pages.get(pageKey)[0])) {\n        buildHistoryNewItem(pageKey);\n        return;\n      }\n    }\n\n    for (String sectionTitle : pages.keySet()) {\n      if (SecurityManager.getInstance().isUserAuthorizedToViewSection(pages.get(sectionTitle)[0])) {\n        buildHistoryNewItem(sectionTitle);\n        break;\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,review,test",
            "token": 218,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 248,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643575470592,
            "program": "  private SVNConflictReason parseConflictReason(@NotNull String reasonName) throws SAXException {\n    SVNConflictReason reason = SVNConflictReason.fromString(reasonName);\n    reason = reason != null ? reason : ourConflictReasons.get(reasonName);\n\n    if (reason == null) {\n      throw new SAXException(\"Can not parse conflict reason: \" + reasonName);\n    }\n\n    return reason;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,review,test",
            "token": 58,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 298,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 23,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643575644790,
            "program": "  Object invokeAndReturn(HttpServletRequest httpRequest, T controller) throws IOException {\n    final String partParameter = HttpParameter.PART.getParameterFrom(httpRequest);\n    final HttpPart httpPart = HttpPart.getByName(partParameter);\n    final Method method = methodsByPart.get(httpPart);\n    if (method == null) {\n      throw new IllegalArgumentException(\"Unknown http part: \" + partParameter);\n    }\n    try {\n      // find parameters values\n      final Object[] parameterValues = getParameterValues(httpRequest, method);\n      // invoke the method (the \"endpoint\")\n      return method.invoke(controller, parameterValues);\n    } catch (final IllegalAccessException e) {\n      throw new IllegalStateException(e);\n    } catch (final InvocationTargetException e) {\n      final Throwable targetException = e.getTargetException();\n      if (targetException instanceof IOException) {\n        throw (IOException) targetException;\n      } else if (targetException instanceof RuntimeException) {\n        throw (RuntimeException) targetException;\n      } else if (targetException instanceof Error) {\n        throw (Error) targetException;\n      }\n      throw new IOException(e);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,review,test",
            "token": 175,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 268,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643575852221,
            "program": "  private void addInputBindRow(SimpleUri uri, RegisterBindButton bind, ColumnLayout layout) {\n    UIInputBindButton inputBind = new UIInputBindButton();\n    inputBind.setManager(getManager());\n    inputBind.setDescription(bind.description());\n    inputBind.bindInput(new InputConfigBinding(config.getInput().getBinds(), uri));\n    UIInputBindButton secondaryInputBind = new UIInputBindButton();\n    secondaryInputBind.setManager(getManager());\n    secondaryInputBind.setDescription(bind.description());\n    secondaryInputBind.bindInput(new InputConfigBinding(config.getInput().getBinds(), uri, 1));\n    layout.addWidget(\n        new RowLayout(new UILabel(bind.description()), inputBind, secondaryInputBind)\n            .setColumnRatios(0.4f)\n            .setHorizontalSpacing(horizontalSpacing));\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,review,test",
            "token": 148,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 284,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643576186748,
            "program": "  public Map<Long, List<Layout>> getLayoutChildLayouts(\n      LayoutSet layoutSet, List<Layout> parentLayouts) {\n\n    List<Layout> childLayouts =\n        _getChildLayouts(layoutSet, ListUtil.toLongArray(parentLayouts, Layout::getLayoutId));\n\n    Map<Long, List<Layout>> layoutChildLayouts = new HashMap<>();\n\n    for (Layout childLayout : childLayouts) {\n      List<Layout> layoutChildLayoutsList =\n          layoutChildLayouts.computeIfAbsent(\n              childLayout.getParentLayoutId(), (parentLayoutId) -> new ArrayList<>());\n\n      layoutChildLayoutsList.add(childLayout);\n    }\n\n    for (List<Layout> layoutChildLayoutsList : layoutChildLayouts.values()) {\n\n      layoutChildLayoutsList.sort(Comparator.comparing(Layout::getPriority));\n    }\n\n    return layoutChildLayouts;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,review,test",
            "token": 140,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 292,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643576240725,
            "program": "  public void track(WPStats.Stat stat, JSONObject properties) {\n    WPStatsTrackerMixpanelInstructionsForStat instructions = instructionsForStat(stat);\n\n    if (instructions == null) return;\n\n    trackMixpanelDataForInstructions(instructions, properties);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,review,test",
            "token": 37,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 306,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643576416509,
            "program": "  protected void processTypeSwitch(AbstractBeginNode beginNode, TypeSwitchNode typeSwitch) {\n    ValueNode hub = typeSwitch.value();\n    if (hub instanceof LoadHubNode) {\n      LoadHubNode loadHub = (LoadHubNode) hub;\n      ValueNode value = loadHub.getValue();\n      if (maybeMultipleUsages(value)) {\n        Stamp stamp = null;\n        for (int i = 0; i < typeSwitch.keyCount(); i++) {\n          if (typeSwitch.keySuccessor(i) == beginNode) {\n            if (stamp == null) {\n              stamp =\n                  StampFactory.objectNonNull(\n                      TypeReference.createExactTrusted(typeSwitch.typeAt(i)));\n            } else {\n              stamp =\n                  stamp.meet(\n                      StampFactory.objectNonNull(\n                          TypeReference.createExactTrusted(typeSwitch.typeAt(i))));\n            }\n          }\n        }\n        if (stamp != null) {\n          registerNewStamp(value, stamp, beginNode);\n        }\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop,review,test",
            "token": 164,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "473713722-1643625137323": [
        {
            "ProgrammID": 276,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643625617914,
            "program": "  public RuntimeContext prepare(RuntimeIdentity id, Environment originEnv)\n      throws ValidationException, InfrastructureException {\n    final EnvironmentImpl environment = new EnvironmentImpl(originEnv);\n    final OpenShiftEnvironment openShiftEnvironment = envParser.parse(environment);\n\n    infrastructureProvisioner.provision(environment, openShiftEnvironment, id);\n\n    return runtimeContextFactory.create(environment, openShiftEnvironment, id, this);\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 62,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 290,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643625689385,
            "program": "  private static String getAlgorithmMode(String algorithm) {\n    int start = algorithm.indexOf('/');\n    if (start < 0)\n      throw new IllegalArgumentException(sm.getString(\"encryptInterceptor.algorithm.required\"));\n    int end = algorithm.indexOf('/', start + 1);\n    if (start < 0)\n      throw new IllegalArgumentException(sm.getString(\"encryptInterceptor.algorithm.required\"));\n\n    return algorithm.substring(start + 1, end);\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 82,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 250,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643625706394,
            "program": "  static boolean extendsThread(ClassObj clazz) {\n    boolean extendsThread = false;\n    ClassObj parentClass = clazz;\n    while (parentClass.getSuperClassObj() != null) {\n      if (clazz.getClassName().equals(Thread.class.getName())) {\n        extendsThread = true;\n        break;\n      }\n      parentClass = parentClass.getSuperClassObj();\n    }\n    return extendsThread;\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 69,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 258,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643625712161,
            "program": "  @Override\n  public void getBounds(RectF outBounds, Matrix parentMatrix) {\n    path.reset();\n    for (int i = 0; i < pathGroups.size(); i++) {\n      PathGroup pathGroup = pathGroups.get(i);\n      for (int j = 0; j < pathGroup.paths.size(); j++) {\n        path.addPath(pathGroup.paths.get(i).getPath(), parentMatrix);\n      }\n    }\n    path.computeBounds(rect, false);\n\n    float width = widthAnimation.getValue();\n    rect.set(\n        rect.left - width / 2f,\n        rect.top - width / 2f,\n        rect.right + width / 2f,\n        rect.bottom + width / 2f);\n    outBounds.set(rect);\n    // Add padding to account for rounding errors.\n    outBounds.set(outBounds.left - 1, outBounds.top - 1, outBounds.right + 1, outBounds.bottom + 1);\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 183,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 261,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643625746603,
            "program": "  public Key importKey(@NonNull String alias, byte[] keyBytes)\n      throws InternalRecoveryServiceException, LockScreenRequiredException {\n    try {\n      String grantAlias = mBinder.importKey(alias, keyBytes);\n      if (grantAlias == null) {\n        throw new InternalRecoveryServiceException(\"Null grant alias\");\n      }\n      return getKeyFromGrant(grantAlias);\n    } catch (RemoteException e) {\n      throw e.rethrowFromSystemServer();\n    } catch (UnrecoverableKeyException e) {\n      throw new InternalRecoveryServiceException(\"Failed to get key from keystore\", e);\n    } catch (ServiceSpecificException e) {\n      if (e.errorCode == ERROR_INSECURE_USER) {\n        throw new LockScreenRequiredException(e.getMessage());\n      }\n      throw wrapUnexpectedServiceSpecificException(e);\n    }\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 120,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 273,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643625803638,
            "program": "  private int recursiveCollapse(@IntRange(from = 0) int position) {\n    T item = getItem(position);\n    if (!isExpandable(item)) {\n      return 0;\n    }\n    IExpandable expandable = (IExpandable) item;\n    int subItemCount = 0;\n    if (expandable.isExpanded()) {\n      List<T> subItems = expandable.getSubItems();\n      for (int i = subItems.size() - 1; i >= 0; i--) {\n        T subItem = subItems.get(i);\n        int pos = getItemPosition(subItem);\n        if (pos < 0) {\n          continue;\n        }\n        if (subItem instanceof IExpandable) {\n          subItemCount += recursiveCollapse(pos);\n        }\n        mData.remove(subItem);\n        subItemCount++;\n      }\n    }\n    return subItemCount;\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 150,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 297,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643625899593,
            "program": "  public boolean satisfiedBy(PsiElement element) {\n    final PsiElement parent = element.getParent();\n    if (!(parent instanceof GrTypeDefinition)) return false;\n    if (((GrTypeDefinition) parent).getNameIdentifierGroovy() != element) return false;\n\n    final String name = ((GrTypeDefinition) element).getName();\n    if (name == null || name.length() == 0) return false;\n    final PsiFile file = element.getContainingFile();\n    if (!(file instanceof GroovyFile)) return false;\n    if (!file.isPhysical()) return false;\n    if (name.equals(FileUtil.getNameWithoutExtension(file.getName()))) return false;\n    if (mySearchForClassInMultiClassFile) {\n      return ((GroovyFile) file).getClasses().length > 1;\n    } else {\n      return !((GroovyFile) file).isScript();\n    }\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 174,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 307,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643625970022,
            "program": "  public ScheduledEntry<K, V> cancelComparingTimeKey(K key) {\n    Set<TimeKey> candidateKeys = new HashSet<TimeKey>();\n    for (Object tkey : secondsOfKeys.keySet()) {\n      TimeKey timeKey = (TimeKey) tkey;\n      if (timeKey.getKey().equals(key)) {\n        candidateKeys.add(timeKey);\n      }\n    }\n\n    ScheduledEntry<K, V> result = null;\n    for (TimeKey timeKey : candidateKeys) {\n      final Integer second = secondsOfKeys.remove(timeKey);\n      if (second != null) {\n        final ConcurrentMap<Object, ScheduledEntry<K, V>> entries = scheduledEntries.get(second);\n        if (entries != null) {\n          result = entries.remove(timeKey);\n        }\n      }\n    }\n\n    return result;\n  }\n",
            "exp": "5",
            "age": "50",
            "task": "test,develop,review",
            "token": 150,
            "ctx": "others",
            "codebase": "own",
            "team": "small"
        }
    ],
    "956740298-1643714063081": [
        {
            "ProgrammID": 293,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643714871127,
            "program": "  private void tintIcons(Context context) {\n    Drawable sms =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_textsms_white_24dp));\n    Drawable notifications =\n        DrawableCompat.wrap(\n            ContextCompat.getDrawable(context, R.drawable.ic_notifications_white_24dp));\n    Drawable privacy =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_security_white_24dp));\n    Drawable appearance =\n        DrawableCompat.wrap(\n            ContextCompat.getDrawable(context, R.drawable.ic_brightness_6_white_24dp));\n    Drawable chats =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_forum_white_24dp));\n    Drawable devices =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_laptop_white_24dp));\n    Drawable advanced =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_advanced_white_24dp));\n\n    int[] tintAttr = new int[] {R.attr.pref_icon_tint};\n    TypedArray typedArray = context.obtainStyledAttributes(tintAttr);\n    int color = typedArray.getColor(0, 0x0);\n    typedArray.recycle();\n\n    DrawableCompat.setTint(sms, color);\n    DrawableCompat.setTint(notifications, color);\n    DrawableCompat.setTint(privacy, color);\n    DrawableCompat.setTint(appearance, color);\n    DrawableCompat.setTint(chats, color);\n    DrawableCompat.setTint(devices, color);\n    DrawableCompat.setTint(advanced, color);\n\n    this.findPreference(PREFERENCE_CATEGORY_SMS_MMS).setIcon(sms);\n    this.findPreference(PREFERENCE_CATEGORY_NOTIFICATIONS).setIcon(notifications);\n    this.findPreference(PREFERENCE_CATEGORY_APP_PROTECTION).setIcon(privacy);\n    this.findPreference(PREFERENCE_CATEGORY_APPEARANCE).setIcon(appearance);\n    this.findPreference(PREFERENCE_CATEGORY_CHATS).setIcon(chats);\n    this.findPreference(PREFERENCE_CATEGORY_DEVICES).setIcon(devices);\n    this.findPreference(PREFERENCE_CATEGORY_ADVANCED).setIcon(advanced);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 348,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 291,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643715084365,
            "program": "  protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n    final Tokenizer source = new StandardTokenizer(matchVersion, reader);\n    TokenStream result = new StandardFilter(matchVersion, source);\n    result = new LowerCaseFilter(matchVersion, result);\n    result = new StopFilter(matchVersion, result, stopwords);\n    if (!stemExclusionSet.isEmpty()) {\n      result = new KeywordMarkerFilter(result, stemExclusionSet);\n    }\n    return new TokenStreamComponents(source, new IndonesianStemFilter(result));\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 91,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 254,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643715317875,
            "program": "  public static MetadataListStructObjectInspector getInstance(List<String> columnNames) {\n    ArrayList<List<String>> key = new ArrayList<List<String>>(1);\n    key.add(columnNames);\n    MetadataListStructObjectInspector result = cached.get(key);\n    if (result == null) {\n      result = new MetadataListStructObjectInspector(columnNames);\n      MetadataListStructObjectInspector prev = cached.putIfAbsent(key, result);\n      if (prev != null) {\n        result = prev;\n      }\n    }\n    return result;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 94,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 265,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643715344777,
            "program": "  public void glGenBuffers(int n, int[] buffers, int offset) {\r\n    for (int i = offset; i < offset + n; i++) buffers[i] = GL15.glGenBuffers();\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 44,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 302,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643715622582,
            "program": "  public void reconnectServer(\n      final String serverName,\n      final ModelNode domainModel,\n      final byte[] authKey,\n      final boolean running,\n      final boolean stopping) {\n    if (shutdown || connectionFinished) {\n      throw HostControllerMessages.MESSAGES.hostAlreadyShutdown();\n    }\n    final ManagedServer existing = servers.get(serverName);\n    if (existing != null) {\n      ROOT_LOGGER.existingServerWithState(serverName, existing.getState());\n      return;\n    }\n    final ManagedServer server = createManagedServer(serverName, domainModel, authKey);\n    if (servers.putIfAbsent(serverName, server) != null) {\n      ROOT_LOGGER.existingServerWithState(serverName, server.getState());\n      return;\n    }\n    if (running) {\n      if (!stopping) {\n        server.reconnectServerProcess();\n        // Register the server proxy at the domain controller\n        domainController.registerRunningServer(server.getProxyController());\n      } else {\n        server.setServerProcessStopping();\n      }\n    } else {\n      server.removeServerProcess();\n    }\n    synchronized (shutdownCondition) {\n      shutdownCondition.notifyAll();\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 182,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 246,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643715756089,
            "program": "  protected void addTempAttachment(ActionRequest actionRequest) throws Exception {\n\n    UploadPortletRequest uploadRequest = PortalUtil.getUploadPortletRequest(actionRequest);\n\n    long nodeId = ParamUtil.getLong(actionRequest, \"nodeId\");\n\n    File file = uploadRequest.getFile(\"file\");\n    String sourceFileName = uploadRequest.getFileName(\"file\");\n\n    WikiPageServiceUtil.addTempPageAttachment(nodeId, sourceFileName, _TEMP_FOLDER_NAME, file);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 66,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 263,
            "lineNumberOfError": 8,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643715840435,
            "program": "  public ConfigurationContainer getConfiguration(String typeName) {\n    for (Map.Entry<Class, ConfigurationContainer> entry : configurations.entrySet()) {\n      if (entry.getKey().getName().equals(typeName)) {\n        return entry.getValue();\n      }\n    }\n    try {\n      Class typeClass = Class.forName(typeName);\n      configurations.put(typeClass, createConfiguration(typeClass));\n      return configurations.get(typeClass);\n    } catch (Exception e) {\n      throw new UnexpectedLiquibaseException(e);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 102,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 251,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643715984903,
            "program": "  private static void collectPythonInstallations(String pythonPath, List<String> candidates) {\n    VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(pythonPath);\n    if (rootVDir != null) {\n      for (VirtualFile dir : rootVDir.getChildren()) {\n        final String dir_name = dir.getName().toLowerCase();\n        if (dir.isDirectory()) {\n          if (\"Current\".equals(dir_name) || dir_name.startsWith(\"2\") || dir_name.startsWith(\"3\")) {\n            VirtualFile bin_dir = dir.findChild(\"bin\");\n            if (bin_dir != null && bin_dir.isDirectory()) {\n              VirtualFile python_exe = bin_dir.findChild(\"python\");\n              if (python_exe != null) candidates.add(python_exe.getPath());\n            }\n          }\n        }\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 151,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1551073245-1643722478961": [
        {
            "ProgrammID": 300,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643722850524,
            "program": "  private ClassNode configureWildcardType(WildcardType wildcardType) {\r\n    ClassNode base = ClassHelper.makeWithoutCaching(\"?\");\r\n    base.setRedirect(ClassHelper.OBJECT_TYPE);\r\n    // TODO: more than one lower bound for wildcards?\r\n    ClassNode[] lowers = configureTypes(wildcardType.getLowerBounds());\r\n    ClassNode lower = null;\r\n    // TODO: is it safe to remove this? What was the original intention?\r\n    if (lower != null) lower = lowers[0];\r\n\r\n    ClassNode[] upper = configureTypes(wildcardType.getUpperBounds());\r\n    GenericsType t = new GenericsType(base, upper, lower);\r\n    t.setWildcard(true);\r\n\r\n    ClassNode ref = ClassHelper.makeWithoutCaching(Object.class, false);\r\n    ref.setGenericsTypes(new GenericsType[] {t});\r\n\r\n    return ref;\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 124,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 253,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643722901948,
            "program": "  private void bulkAdd(String[] names, Vec[] vecs) {\n    Vec vec = vecs != null && vecs.length > 0 ? makeCompatible(new Frame(vecs[0])).anyVec() : null;\n    String[] tmpnames = names.clone();\n    int N = names.length;\n    assert (names.length == vecs.length);\n    for (int i = 0; i < N; ++i) {\n      checkCompatible(tmpnames[i] = uniquify(tmpnames[i]), vec); // Throw IAE is mismatch\n    }\n\n    int ncols = _keys.length;\n    _names = Arrays.copyOf(_names, ncols + N);\n    _keys = Arrays.copyOf(_keys, ncols + N);\n    _vecs = Arrays.copyOf(_vecs, ncols + N);\n    for (int i = 0; i < N; ++i) {\n      _names[ncols + i] = tmpnames[i];\n      _keys[ncols + i] = vecs[i]._key;\n      _vecs[ncols + i] = vecs[i];\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 210,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 287,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643722903658,
            "program": "  public final String resolveRelativePathEntry(String path, String relativeTo) {\n    if (relativeTo == null) {\n      return AbsolutePathService.convertPath(path);\n    } else {\n      PathEntry pathEntry;\n      synchronized (pathEntries) {\n        pathEntry = pathEntries.get(relativeTo);\n        if (pathEntry == null) {\n          throw MESSAGES.pathEntryNotFound(path);\n        }\n        return RelativePathService.doResolve(pathEntry.resolvePath(), path);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 80,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 244,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643722906546,
            "program": "  public boolean remove(MessageInput input) {\n    final IOState<MessageInput> inputState = this.stop(input);\n    if (inputState != null) inputState.setState(IOState.Type.TERMINATED);\n\n    return super.remove(inputState);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 48,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 267,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643722908101,
            "program": "  public MultiMap<VirtualFile, Hash> getCommitsAround(@NotNull Node node, int above, int below) {\n    MultiMap<VirtualFile, Hash> commits = MultiMap.create();\n    int rowIndex = node.getRowIndex();\n    for (int i = rowIndex - above; i < rowIndex + below; i++) {\n      Node commitNode = getCommitNodeInRow(i);\n      if (commitNode != null) {\n        Hash hash = myDataHolder.getHash(commitNode.getCommitIndex());\n        commits.putValue(commitNode.getBranch().getRepositoryRoot(), hash);\n      }\n    }\n    return commits;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 115,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 243,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643722909447,
            "program": "  private void registerAuthenticatedSession(WsSession wsSession, String httpSessionId) {\n    Set<WsSession> wsSessions = authenticatedSessions.get(httpSessionId);\n    if (wsSession == null) {\n      wsSessions = Collections.newSetFromMap(new ConcurrentHashMap<WsSession, Boolean>());\n      authenticatedSessions.putIfAbsent(httpSessionId, wsSessions);\n      wsSessions = authenticatedSessions.get(httpSessionId);\n    }\n    wsSessions.add(wsSession);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 75,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 275,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643722919821,
            "program": "  private static Set<WorkerSlot> badSlots(\n      Map<WorkerSlot, List<ExecutorDetails>> existingSlots, int numExecutors, int numWorkers) {\n    if (numWorkers != 0) {\n      Map<Integer, Integer> distribution = Utils.integerDivided(numExecutors, numWorkers);\n      Set<WorkerSlot> slots = new HashSet<WorkerSlot>();\n\n      for (Entry<WorkerSlot, List<ExecutorDetails>> entry : existingSlots.entrySet()) {\n        Integer executorCount = entry.getValue().size();\n        Integer workerCount = distribution.get(executorCount);\n        if (workerCount != null && workerCount > 0) {\n          slots.add(entry.getKey());\n          workerCount--;\n          distribution.put(executorCount, workerCount);\n        }\n      }\n\n      for (WorkerSlot slot : slots) {\n        existingSlots.remove(slot);\n      }\n\n      return existingSlots.keySet();\n    }\n\n    return null;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 171,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 277,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643722926232,
            "program": "  public void testClear() {\n    BooleanSubscription s1 = new BooleanSubscription();\n    BooleanSubscription s2 = new BooleanSubscription();\n\n    CompositeSubscription s = new CompositeSubscription();\n    s.add(s1);\n    s.add(s2);\n\n    assertFalse(s1.isUnsubscribed());\n    assertFalse(s2.isUnsubscribed());\n\n    s.clear();\n\n    assertTrue(s1.isUnsubscribed());\n    assertTrue(s2.isUnsubscribed());\n    assertFalse(s.isUnsubscribed());\n\n    BooleanSubscription s3 = new BooleanSubscription();\n\n    s.add(s3);\n    s.unsubscribe();\n\n    assertTrue(s3.isUnsubscribed());\n    assertTrue(s.isUnsubscribed());\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 135,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "16111588-1643797866467": [
        {
            "ProgrammID": 296,
            "lineNumberOfError": 20,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643798288492,
            "program": "  public ManagementStrategy create(CamelContext context, boolean disableJMX) {\n    ManagementStrategy answer = null;\n\n    if (disableJMX || Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {\n      log.info(\"JMX is disabled.\");\n    } else {\n      try {\n        ManagedManagementStrategy jmx =\n            new ManagedManagementStrategy(new DefaultManagementAgent(context));\n        // must start it to ensure JMX works and can load needed Spring JARs\n        ServiceHelper.startService(jmx);\n        // prefer to have it at first strategy\n        context.getLifecycleStrategies().add(0, new DefaultManagementLifecycleStrategy(context));\n        log.info(\"JMX enabled.\");\n      } catch (Exception e) {\n        answer = null;\n        log.warn(\"Cannot create JMX lifecycle strategy. Will fallback and disable JMX.\", e);\n      }\n    }\n\n    if (answer == null) {\n      answer = new DefaultManagementStrategy();\n    }\n    return answer;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 127,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 301,
            "lineNumberOfError": 20,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643798307525,
            "program": "  public void renameElement(\n      final PsiElement element,\n      final String newName,\n      final boolean searchInComments,\n      final boolean searchTextOccurrences) {\n    new WriteCommandAction.Simple(myProjectFixture.getProject()) {\n      @Override\n      protected void run() throws Exception {\n        final PsiElement substitution =\n            RenamePsiElementProcessor.forElement(element)\n                .substituteElementToRename(element, myEditor);\n        if (element == null) return;\n        new RenameProcessor(\n                myProjectFixture.getProject(),\n                substitution,\n                newName,\n                searchInComments,\n                searchTextOccurrences)\n            .run();\n      }\n    }.execute().throwException();\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 103,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 278,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643798339515,
            "program": "  public AsyncSupport resolve(\n      boolean useNativeIfPossible, boolean defaultToBlocking, boolean useServlet30Async) {\n    AsyncSupport cs = null;\n\n    // Validate the value for old Servlet Container.\n    useServlet30Async = testClassExists(SERVLET_30);\n\n    if (!defaultToBlocking) {\n      List<Class<? extends AsyncSupport>> l =\n          detectWebSocketPresent(useNativeIfPossible, useServlet30Async);\n\n      if (!l.isEmpty()) {\n        cs = resolveWebSocket(l);\n      }\n    }\n\n    if (cs == null) {\n      AsyncSupport nativeSupport = resolveNativeCometSupport(detectContainersPresent());\n      return nativeSupport == null ? defaultCometSupport(defaultToBlocking) : nativeSupport;\n    } else {\n      return cs;\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 106,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 252,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643798385990,
            "program": "  public void addIterationHead(\n      Integer vertexID, Integer iterationHead, Integer iterationID, long timeOut) {\n\n    addNode(vertexID, StreamIterationHead.class, null, null);\n\n    chaining = false;\n\n    StreamLoop iteration = new StreamLoop(iterationID, getStreamNode(vertexID), timeOut);\n    streamLoops.put(iterationID, iteration);\n    vertexIDtoLoop.put(vertexID, iteration);\n\n    setSerializersFrom(iterationHead, vertexID);\n    getStreamNode(vertexID).setOperatorName(\"IterationHead-\" + iterationHead);\n\n    int outpartitionerIndex = getStreamNode(iterationHead).getInEdgeIndices().get(0);\n    StreamPartitioner<?> outputPartitioner =\n        getStreamNode(outpartitionerIndex).getOutEdges().get(0).getPartitioner();\n\n    addEdge(vertexID, iterationHead, outputPartitioner, 0, new ArrayList<String>());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ITERATION SOURCE: {}\", vertexID);\n    }\n\n    sources.add(vertexID);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 174,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 264,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 25,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643798459675,
            "program": "  private void verify(IndexWriter writer) throws Exception {\n    CheckIndex checkIndex = new CheckIndex(writer.getDirectory());\n    CheckIndex.Status status = checkIndex.checkIndex();\n    assertThat(status.clean, equalTo(true));\n    IndexReader reader = DirectoryReader.open(writer, true);\n    final Bits liveDocs = MultiFields.getLiveDocs(reader);\n    for (int i = 0; i < reader.maxDoc(); i++) {\n      if (liveDocs != null && !liveDocs.get(i)) {\n        continue;\n      }\n      Document document = reader.document(i);\n      checkDoc(document);\n      DocumentStoredFieldVisitor visitor = new DocumentStoredFieldVisitor(\"id\", \"field\", \"count\");\n      reader.document(i, visitor);\n      document = visitor.getDocument();\n      checkDoc(document);\n    }\n    for (int i = 0; i < 100; i++) {\n      int doc = ThreadLocalRandom.current().nextInt(reader.maxDoc());\n      if (liveDocs != null && !liveDocs.get(i)) {\n        continue;\n      }\n      Document document = reader.document(doc);\n      checkDoc(document);\n      DocumentStoredFieldVisitor visitor = new DocumentStoredFieldVisitor(\"id\", \"field\", \"count\");\n      reader.document(i, visitor);\n      document = visitor.getDocument();\n      checkDoc(document);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 260,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 255,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": 27,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643798494625,
            "program": "  public static HostAddress resolveXMPPServerDomain(String domain) {\n    if (context == null) {\n      return new HostAddress(domain, 5269);\n    }\n    String host = domain;\n    int port = 5269;\n    try {\n      Attributes dnsLookup = context.getAttributes(\"_xmpp-server._tcp.\" + domain);\n      String srvRecord = (String) dnsLookup.get(\"SRV\").get();\n      String[] srvRecordEntries = srvRecord.split(\" \");\n      port = Integer.parseInt(srvRecordEntries[srvRecordEntries.length - 2]);\n      host = srvRecordEntries[srvRecordEntries.length - 1];\n    } catch (Exception e) {\n      // Attempt lookup with older \"jabber\" name.\n      try {\n        Attributes dnsLookup = context.getAttributes(\"_jabber._tcp.\" + domain);\n        String srvRecord = (String) dnsLookup.get(\"SRV\").get();\n        String[] srvRecordEntries = srvRecord.split(\" \");\n        port = Integer.parseInt(srvRecordEntries[srvRecordEntries.length - 2]);\n        host = srvRecordEntries[srvRecordEntries.length - 1];\n      } catch (Exception e2) {\n      }\n    }\n    // Host entries in DNS should end with a \".\".\n    if (host.endsWith(\".\")) {\n      host = host.substring(0, host.length() - 1);\n    }\n    return new HostAddress(domain, port);\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 230,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 266,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643798577822,
            "program": "  public Future<Boolean> removeAllAsync(Collection<?> c) {\n    if (c.isEmpty()) {\n      return newSucceededFuture(false);\n    }\n\n    List<Object> args = new ArrayList<Object>(c.size() + 1);\n    args.add(getName());\n    args.addAll(c);\n\n    return commandExecutor.writeAsync(getName(), codec, RedisCommands.SREM_SINGLE, args.toArray());\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 90,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 261,
            "lineNumberOfError": 0,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643798605609,
            "program": "  public Key importKey(@NonNull String alias, byte[] keyBytes)\n      throws InternalRecoveryServiceException, LockScreenRequiredException {\n    try {\n      String grantAlias = mBinder.importKey(alias, keyBytes);\n      if (grantAlias == null) {\n        throw new InternalRecoveryServiceException(\"Null grant alias\");\n      }\n      return getKeyFromGrant(grantAlias);\n    } catch (RemoteException e) {\n      throw e.rethrowFromSystemServer();\n    } catch (UnrecoverableKeyException e) {\n      throw new InternalRecoveryServiceException(\"Failed to get key from keystore\", e);\n    } catch (ServiceSpecificException e) {\n      if (e.errorCode == ERROR_INSECURE_USER) {\n        throw new LockScreenRequiredException(e.getMessage());\n      }\n      throw wrapUnexpectedServiceSpecificException(e);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 120,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "171772891-1643798137742": [
        {
            "ProgrammID": 245,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643798702681,
            "program": "  public static Range getRange(int startMonth, int startDay, int endMonth, int endDay) {\n    Calendar start = Calendar.getInstance();\n    start.set(Calendar.MONTH, startMonth);\n    start.set(Calendar.DAY_OF_MONTH, startDay);\n    start = truncateToMidnight(start);\n\n    Calendar end = Calendar.getInstance();\n    end.set(Calendar.MONTH, endMonth);\n    end.set(Calendar.DAY_OF_MONTH, endDay);\n    end.set(Calendar.HOUR_OF_DAY, 23);\n    end.set(Calendar.MINUTE, 59);\n    end.set(Calendar.SECOND, 59);\n    end.set(Calendar.MILLISECOND, 999);\n\n    return new Range(start, end);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 141,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 295,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643798740503,
            "program": "  protected final RedisClusterConfiguration getClusterConfiguration() {\n    if (this.clusterConfiguration != null) {\n      return this.clusterConfiguration;\n    }\n    if (this.properties.getCluster() == null) {\n      return null;\n    }\n    Cluster clusterProperties = this.properties.getCluster();\n    RedisClusterConfiguration config = new RedisClusterConfiguration(clusterProperties.getNodes());\n\n    if (clusterProperties.getMaxRedirects() != null) {\n      config.setMaxRedirects(config.getMaxRedirects());\n    }\n    return config;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 90,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 253,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643798899017,
            "program": "  private void bulkAdd(String[] names, Vec[] vecs) {\n    Vec vec = vecs != null && vecs.length > 0 ? makeCompatible(new Frame(vecs[0])).anyVec() : null;\n    String[] tmpnames = names.clone();\n    int N = names.length;\n    assert (names.length == vecs.length);\n    for (int i = 0; i < N; ++i) {\n      checkCompatible(tmpnames[i] = uniquify(tmpnames[i]), vec); // Throw IAE is mismatch\n    }\n\n    int ncols = _keys.length;\n    _names = Arrays.copyOf(_names, ncols + N);\n    _keys = Arrays.copyOf(_keys, ncols + N);\n    _vecs = Arrays.copyOf(_vecs, ncols + N);\n    for (int i = 0; i < N; ++i) {\n      _names[ncols + i] = tmpnames[i];\n      _keys[ncols + i] = vecs[i]._key;\n      _vecs[ncols + i] = vecs[i];\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 210,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 288,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643798924711,
            "program": "  public void removeFrameSlot(String name) {\n    assertNotRunning();\n    FrameSlot slot = getSlot(name);\n    slot.releaseFrame();\n    mFrameSlots.remove(slot);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 34,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 266,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643798991130,
            "program": "  public Future<Boolean> removeAllAsync(Collection<?> c) {\n    if (c.isEmpty()) {\n      return newSucceededFuture(false);\n    }\n\n    List<Object> args = new ArrayList<Object>(c.size() + 1);\n    args.add(getName());\n    args.addAll(c);\n\n    return commandExecutor.writeAsync(getName(), codec, RedisCommands.SREM_SINGLE, args.toArray());\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 90,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 249,
            "lineNumberOfError": 6,
            "attempt": 1,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643799038763,
            "program": "  public DataResponse<Iterable<Dashboard>> getByServiceAndApplication(String component, String app)\n      throws HygieiaException {\n    Cmdb cmdbCompItem = cmdbService.configurationItemByConfigurationItem(component);\n    Cmdb cmdbAppItem = cmdbService.configurationItemByConfigurationItem(app);\n    Iterable<Dashboard> rt = null;\n\n    if (cmdbAppItem != null && cmdbAppItem != null) {\n      rt =\n          dashboardRepository\n              .findAllByConfigurationItemBusServObjectIdAndConfigurationItemBusAppObjectId(\n                  cmdbAppItem.getId(), cmdbCompItem.getId());\n    }\n    return new DataResponse<>(rt, System.currentTimeMillis());\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 94,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 263,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643799079904,
            "program": "  public ConfigurationContainer getConfiguration(String typeName) {\n    for (Map.Entry<Class, ConfigurationContainer> entry : configurations.entrySet()) {\n      if (entry.getKey().getName().equals(typeName)) {\n        return entry.getValue();\n      }\n    }\n    try {\n      Class typeClass = Class.forName(typeName);\n      configurations.put(typeClass, createConfiguration(typeClass));\n      return configurations.get(typeClass);\n    } catch (Exception e) {\n      throw new UnexpectedLiquibaseException(e);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 102,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 270,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1643799199485,
            "program": "  private static APKModule getModuleForLinkable(\n      MergedLibNativeLinkable linkable,\n      ImmutableMap<NativeLinkable, APKModule> linkableToModuleMap) {\n    APKModule module = null;\n    for (NativeLinkable constituent : linkable.constituents.getLinkables()) {\n      APKModule constituentModule = linkableToModuleMap.get(constituent);\n      if (module == null) {\n        module = constituentModule;\n      }\n      if (module != constituentModule) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Native library merge of \")\n            .append(linkable)\n            .append(\" has inconsistent application module mappings: \");\n        for (NativeLinkable innerConstituent : linkable.constituents.getLinkables()) {\n          APKModule innerConstituentModule = linkableToModuleMap.get(constituent);\n          sb.append(innerConstituent).append(\" -> \").append(innerConstituentModule).append(\", \");\n        }\n        throw new RuntimeException(\n            \"Native library merge of \"\n                + linkable\n                + \" has inconsistent application module mappings: \"\n                + sb);\n      }\n    }\n    return Preconditions.checkNotNull(module);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 161,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1504981876-1643810022766": [
        {
            "ProgrammID": 248,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643810227240,
            "program": "  private SVNConflictReason parseConflictReason(@NotNull String reasonName) throws SAXException {\n    SVNConflictReason reason = SVNConflictReason.fromString(reasonName);\n    reason = reason != null ? reason : ourConflictReasons.get(reasonName);\n\n    if (reason == null) {\n      throw new SAXException(\"Can not parse conflict reason: \" + reasonName);\n    }\n\n    return reason;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 58,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 257,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643810267866,
            "program": "  protected void crateCall(long[] args) {\n    int i = 2;\n    int target = getIndex(args[i++]);\n    int[] arguments = new int[args.length - i];\n    int j = 0;\n    while (j < arguments.length) {\n      arguments[j++] = getIndex(args[i++]);\n    }\n\n    Type type = symbols.get(target).getType();\n\n    if (type instanceof PointerType) {\n      type = ((PointerType) type).getPointeeType();\n    }\n\n    Type returnType = ((FunctionType) type).getReturnType();\n\n    code.createCall(returnType, target, arguments);\n\n    if (returnType != MetaType.VOID) {\n      symbols.add(returnType);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 150,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 278,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643810324342,
            "program": "  public AsyncSupport resolve(\n      boolean useNativeIfPossible, boolean defaultToBlocking, boolean useServlet30Async) {\n    AsyncSupport cs = null;\n\n    // Validate the value for old Servlet Container.\n    useServlet30Async = testClassExists(SERVLET_30);\n\n    if (!defaultToBlocking) {\n      List<Class<? extends AsyncSupport>> l =\n          detectWebSocketPresent(useNativeIfPossible, useServlet30Async);\n\n      if (!l.isEmpty()) {\n        cs = resolveWebSocket(l);\n      }\n    }\n\n    if (cs == null) {\n      AsyncSupport nativeSupport = resolveNativeCometSupport(detectContainersPresent());\n      return nativeSupport == null ? defaultCometSupport(defaultToBlocking) : nativeSupport;\n    } else {\n      return cs;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 106,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 298,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 23,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643810453328,
            "program": "  Object invokeAndReturn(HttpServletRequest httpRequest, T controller) throws IOException {\n    final String partParameter = HttpParameter.PART.getParameterFrom(httpRequest);\n    final HttpPart httpPart = HttpPart.getByName(partParameter);\n    final Method method = methodsByPart.get(httpPart);\n    if (method == null) {\n      throw new IllegalArgumentException(\"Unknown http part: \" + partParameter);\n    }\n    try {\n      // find parameters values\n      final Object[] parameterValues = getParameterValues(httpRequest, method);\n      // invoke the method (the \"endpoint\")\n      return method.invoke(controller, parameterValues);\n    } catch (final IllegalAccessException e) {\n      throw new IllegalStateException(e);\n    } catch (final InvocationTargetException e) {\n      final Throwable targetException = e.getTargetException();\n      if (targetException instanceof IOException) {\n        throw (IOException) targetException;\n      } else if (targetException instanceof RuntimeException) {\n        throw (RuntimeException) targetException;\n      } else if (targetException instanceof Error) {\n        throw (Error) targetException;\n      }\n      throw new IOException(e);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 175,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 242,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643810498707,
            "program": "  public synchronized void update(\r\n      final float pX1, final float pY1, final float pX2, final float pY2) {\r\n    final int[] bufferData = this.mBufferData;\r\n\r\n    bufferData[0] = Float.floatToRawIntBits(pX1);\r\n    bufferData[1] = Float.floatToRawIntBits(pY1);\r\n\r\n    bufferData[2] = Float.floatToRawIntBits(pX2);\r\n    bufferData[3] = Float.floatToRawIntBits(pY2);\r\n\r\n    final FastFloatBuffer buffer = this.getFloatBuffer();\r\n    buffer.position(0);\r\n    buffer.put(bufferData);\r\n    buffer.position(0);\r\n\r\n    super.setHardwareBufferNeedsUpdate();\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 118,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 291,
            "lineNumberOfError": 2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643810575069,
            "program": "  protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n    final Tokenizer source = new StandardTokenizer(matchVersion, reader);\n    TokenStream result = new StandardFilter(matchVersion, source);\n    result = new LowerCaseFilter(matchVersion, result);\n    result = new StopFilter(matchVersion, result, stopwords);\n    if (!stemExclusionSet.isEmpty()) {\n      result = new KeywordMarkerFilter(result, stemExclusionSet);\n    }\n    return new TokenStreamComponents(source, new IndonesianStemFilter(result));\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 91,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 296,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1643810615837,
            "program": "  public ManagementStrategy create(CamelContext context, boolean disableJMX) {\n    ManagementStrategy answer = null;\n\n    if (disableJMX || Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {\n      log.info(\"JMX is disabled.\");\n    } else {\n      try {\n        ManagedManagementStrategy jmx =\n            new ManagedManagementStrategy(new DefaultManagementAgent(context));\n        // must start it to ensure JMX works and can load needed Spring JARs\n        ServiceHelper.startService(jmx);\n        // prefer to have it at first strategy\n        context.getLifecycleStrategies().add(0, new DefaultManagementLifecycleStrategy(context));\n        log.info(\"JMX enabled.\");\n      } catch (Exception e) {\n        answer = null;\n        log.warn(\"Cannot create JMX lifecycle strategy. Will fallback and disable JMX.\", e);\n      }\n    }\n\n    if (answer == null) {\n      answer = new DefaultManagementStrategy();\n    }\n    return answer;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 127,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 286,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1643810707164,
            "program": "  public static View findParentViewHolderItemView(View v) {\n    final ViewParent parent = v.getParent();\n    if (parent instanceof RecyclerView) {\n      // returns the passed instance if the parent is RecyclerView\n      return v;\n    } else if (parent instanceof View) {\n      // check the parent view recursively\n      return findParentViewHolderItemView((View) parent);\n    } else {\n      return null;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 55,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "921527129-1644005832837": [
        {
            "ProgrammID": 267,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644006218624,
            "program": "  public MultiMap<VirtualFile, Hash> getCommitsAround(@NotNull Node node, int above, int below) {\n    MultiMap<VirtualFile, Hash> commits = MultiMap.create();\n    int rowIndex = node.getRowIndex();\n    for (int i = rowIndex - above; i < rowIndex + below; i++) {\n      Node commitNode = getCommitNodeInRow(i);\n      if (commitNode != null) {\n        Hash hash = myDataHolder.getHash(commitNode.getCommitIndex());\n        commits.putValue(commitNode.getBranch().getRepositoryRoot(), hash);\n      }\n    }\n    return commits;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 115,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 255,
            "lineNumberOfError": 27,
            "attempt": 1,
            "expectedAnswer": 27,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644006327014,
            "program": "  public static HostAddress resolveXMPPServerDomain(String domain) {\n    if (context == null) {\n      return new HostAddress(domain, 5269);\n    }\n    String host = domain;\n    int port = 5269;\n    try {\n      Attributes dnsLookup = context.getAttributes(\"_xmpp-server._tcp.\" + domain);\n      String srvRecord = (String) dnsLookup.get(\"SRV\").get();\n      String[] srvRecordEntries = srvRecord.split(\" \");\n      port = Integer.parseInt(srvRecordEntries[srvRecordEntries.length - 2]);\n      host = srvRecordEntries[srvRecordEntries.length - 1];\n    } catch (Exception e) {\n      // Attempt lookup with older \"jabber\" name.\n      try {\n        Attributes dnsLookup = context.getAttributes(\"_jabber._tcp.\" + domain);\n        String srvRecord = (String) dnsLookup.get(\"SRV\").get();\n        String[] srvRecordEntries = srvRecord.split(\" \");\n        port = Integer.parseInt(srvRecordEntries[srvRecordEntries.length - 2]);\n        host = srvRecordEntries[srvRecordEntries.length - 1];\n      } catch (Exception e2) {\n      }\n    }\n    // Host entries in DNS should end with a \".\".\n    if (host.endsWith(\".\")) {\n      host = host.substring(0, host.length() - 1);\n    }\n    return new HostAddress(domain, port);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 230,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 293,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644006487931,
            "program": "  private void tintIcons(Context context) {\n    Drawable sms =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_textsms_white_24dp));\n    Drawable notifications =\n        DrawableCompat.wrap(\n            ContextCompat.getDrawable(context, R.drawable.ic_notifications_white_24dp));\n    Drawable privacy =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_security_white_24dp));\n    Drawable appearance =\n        DrawableCompat.wrap(\n            ContextCompat.getDrawable(context, R.drawable.ic_brightness_6_white_24dp));\n    Drawable chats =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_forum_white_24dp));\n    Drawable devices =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_laptop_white_24dp));\n    Drawable advanced =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_advanced_white_24dp));\n\n    int[] tintAttr = new int[] {R.attr.pref_icon_tint};\n    TypedArray typedArray = context.obtainStyledAttributes(tintAttr);\n    int color = typedArray.getColor(0, 0x0);\n    typedArray.recycle();\n\n    DrawableCompat.setTint(sms, color);\n    DrawableCompat.setTint(notifications, color);\n    DrawableCompat.setTint(privacy, color);\n    DrawableCompat.setTint(appearance, color);\n    DrawableCompat.setTint(chats, color);\n    DrawableCompat.setTint(devices, color);\n    DrawableCompat.setTint(advanced, color);\n\n    this.findPreference(PREFERENCE_CATEGORY_SMS_MMS).setIcon(sms);\n    this.findPreference(PREFERENCE_CATEGORY_NOTIFICATIONS).setIcon(notifications);\n    this.findPreference(PREFERENCE_CATEGORY_APP_PROTECTION).setIcon(privacy);\n    this.findPreference(PREFERENCE_CATEGORY_APPEARANCE).setIcon(appearance);\n    this.findPreference(PREFERENCE_CATEGORY_CHATS).setIcon(chats);\n    this.findPreference(PREFERENCE_CATEGORY_DEVICES).setIcon(devices);\n    this.findPreference(PREFERENCE_CATEGORY_ADVANCED).setIcon(advanced);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 348,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 276,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644006546052,
            "program": "  public RuntimeContext prepare(RuntimeIdentity id, Environment originEnv)\n      throws ValidationException, InfrastructureException {\n    final EnvironmentImpl environment = new EnvironmentImpl(originEnv);\n    final OpenShiftEnvironment openShiftEnvironment = envParser.parse(environment);\n\n    infrastructureProvisioner.provision(environment, openShiftEnvironment, id);\n\n    return runtimeContextFactory.create(environment, openShiftEnvironment, id, this);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 62,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 285,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644006743021,
            "program": "  protected Principal getPrincipal(String username) {\n\n    User user = database.findUser(username);\n    if (user == null) {\n      return null;\n    }\n\n    List roles = new ArrayList();\n    Iterator uroles = user.getRoles();\n    while (uroles.hasNext()) {\n      Role role = (Role) uroles.next();\n      roles.add(role.getName());\n    }\n    Iterator groups = user.getGroups();\n    while (groups.hasNext()) {\n      Group group = (Group) groups.next();\n      uroles = group.getRoles();\n      while (uroles.hasNext()) {\n        Role role = (Role) uroles.next();\n        roles.add(role.getName());\n      }\n    }\n    return new GenericPrincipal(this, username, user.getPassword(), roles, user);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 171,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 246,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644006872675,
            "program": "  protected void addTempAttachment(ActionRequest actionRequest) throws Exception {\n\n    UploadPortletRequest uploadRequest = PortalUtil.getUploadPortletRequest(actionRequest);\n\n    long nodeId = ParamUtil.getLong(actionRequest, \"nodeId\");\n\n    File file = uploadRequest.getFile(\"file\");\n    String sourceFileName = uploadRequest.getFileName(\"file\");\n\n    WikiPageServiceUtil.addTempPageAttachment(nodeId, sourceFileName, _TEMP_FOLDER_NAME, file);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 66,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 280,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644006930649,
            "program": "  public float dst(final Vector3 vector) {\r\n    final float a = vector.x - x;\r\n    final float b = vector.y - y;\r\n    final float c = vector.z - z;\r\n\r\n    return (float) Math.sqrt(a * a + b * b + c * c);\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 61,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 289,
            "lineNumberOfError": 18,
            "attempt": 1,
            "expectedAnswer": 18,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644007028717,
            "program": "  private String adjustPath(final String path) {\n    String adjustedPath = path;\n\n    if (RequestUtils.isDispatcherServletRequest()\n        && StringUtils.hasText(this.dispatcherServletPath)) {\n      if (!this.dispatcherServletPath.equals(\"/\")) {\n        adjustedPath = path.substring(this.dispatcherServletPath.length());\n        log.debug(\"Stripped dispatcherServletPath\");\n      }\n    } else if (RequestUtils.isZuulServletRequest()) {\n      if (StringUtils.hasText(this.zuulServletPath) && !this.zuulServletPath.equals(\"/\")) {\n        adjustedPath = path.substring(this.zuulServletPath.length());\n        log.debug(\"Stripped zuulServletPath\");\n      }\n    } else {\n      // do nothing\n    }\n\n    log.debug(\"adjustedPath=\" + path);\n    return adjustedPath;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 141,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 243,
            "lineNumberOfError": 5,
            "attempt": 2,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644007163044,
            "program": "  private void registerAuthenticatedSession(WsSession wsSession, String httpSessionId) {\n    Set<WsSession> wsSessions = authenticatedSessions.get(httpSessionId);\n    if (wsSession == null) {\n      wsSessions = Collections.newSetFromMap(new ConcurrentHashMap<WsSession, Boolean>());\n      authenticatedSessions.putIfAbsent(httpSessionId, wsSessions);\n      wsSessions = authenticatedSessions.get(httpSessionId);\n    }\n    wsSessions.add(wsSession);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 75,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 247,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644007333105,
            "program": "  public void go(\n      final Canvas container, HashMap<String, String[]> pages, String pageKey, boolean firstTime) {\n    this.pages = pages;\n    this.container = container;\n\n    if (firstTime) {\n      String token = History.getToken();\n      if (pageKey.equals(BLCLaunch.getSelectedPage(token))\n          && MasterView.moduleKey.equals(BLCLaunch.getSelectedModule(token))) {\n        String itemId = BLCLaunch.getDefaultItem(token);\n        showView(pages.get(pageKey)[0], pages.get(pageKey)[1], itemId);\n      } else {\n        buildHistoryNewItem(pageKey);\n      }\n      return;\n    }\n\n    if (pageKey != null && pages.get(pageKey) != null) {\n      if (SecurityManager.getInstance().isUserAuthorizedToViewSection(pages.get(pageKey)[0])) {\n        buildHistoryNewItem(pageKey);\n        return;\n      }\n    }\n\n    for (String sectionTitle : pages.keySet()) {\n      if (SecurityManager.getInstance().isUserAuthorizedToViewSection(pages.get(sectionTitle)[0])) {\n        buildHistoryNewItem(sectionTitle);\n        break;\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 218,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 302,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644007494239,
            "program": "  public void reconnectServer(\n      final String serverName,\n      final ModelNode domainModel,\n      final byte[] authKey,\n      final boolean running,\n      final boolean stopping) {\n    if (shutdown || connectionFinished) {\n      throw HostControllerMessages.MESSAGES.hostAlreadyShutdown();\n    }\n    final ManagedServer existing = servers.get(serverName);\n    if (existing != null) {\n      ROOT_LOGGER.existingServerWithState(serverName, existing.getState());\n      return;\n    }\n    final ManagedServer server = createManagedServer(serverName, domainModel, authKey);\n    if (servers.putIfAbsent(serverName, server) != null) {\n      ROOT_LOGGER.existingServerWithState(serverName, server.getState());\n      return;\n    }\n    if (running) {\n      if (!stopping) {\n        server.reconnectServerProcess();\n        // Register the server proxy at the domain controller\n        domainController.registerRunningServer(server.getProxyController());\n      } else {\n        server.setServerProcessStopping();\n      }\n    } else {\n      server.removeServerProcess();\n    }\n    synchronized (shutdownCondition) {\n      shutdownCondition.notifyAll();\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 182,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 244,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644007540731,
            "program": "  public boolean remove(MessageInput input) {\n    final IOState<MessageInput> inputState = this.stop(input);\n    if (inputState != null) inputState.setState(IOState.Type.TERMINATED);\n\n    return super.remove(inputState);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 48,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 258,
            "lineNumberOfError": 6,
            "attempt": 2,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644007568316,
            "program": "  @Override\n  public void getBounds(RectF outBounds, Matrix parentMatrix) {\n    path.reset();\n    for (int i = 0; i < pathGroups.size(); i++) {\n      PathGroup pathGroup = pathGroups.get(i);\n      for (int j = 0; j < pathGroup.paths.size(); j++) {\n        path.addPath(pathGroup.paths.get(i).getPath(), parentMatrix);\n      }\n    }\n    path.computeBounds(rect, false);\n\n    float width = widthAnimation.getValue();\n    rect.set(\n        rect.left - width / 2f,\n        rect.top - width / 2f,\n        rect.right + width / 2f,\n        rect.bottom + width / 2f);\n    outBounds.set(rect);\n    // Add padding to account for rounding errors.\n    outBounds.set(outBounds.left - 1, outBounds.top - 1, outBounds.right + 1, outBounds.bottom + 1);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 183,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 259,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644007747534,
            "program": "  public boolean removeListener(final String eventId, final IDownloadListener listener) {\n    if (FileDownloadLog.NEED_LOG) {\n      FileDownloadLog.v(this, \"removeListener %s\", eventId);\n    }\n\n    LinkedList<IDownloadListener> container = listenersMap.get(eventId);\n    if (container == null) {\n      synchronized (eventId.intern()) {\n        container = listenersMap.get(eventId);\n      }\n    }\n\n    if (container == null || listener == null) {\n      return false;\n    }\n\n    synchronized (eventId.intern()) {\n      boolean succeed = container.remove(listener);\n      if (container.size() <= 0) {\n        listenersMap.remove(eventId);\n      }\n      return succeed;\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 130,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 290,
            "lineNumberOfError": 5,
            "attempt": 2,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644007768485,
            "program": "  private static String getAlgorithmMode(String algorithm) {\n    int start = algorithm.indexOf('/');\n    if (start < 0)\n      throw new IllegalArgumentException(sm.getString(\"encryptInterceptor.algorithm.required\"));\n    int end = algorithm.indexOf('/', start + 1);\n    if (start < 0)\n      throw new IllegalArgumentException(sm.getString(\"encryptInterceptor.algorithm.required\"));\n\n    return algorithm.substring(start + 1, end);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 82,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 269,
            "lineNumberOfError": 9,
            "attempt": 2,
            "expectedAnswer": 9,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644007803708,
            "program": "  private void initializeFromMailto(MailTo mailTo) {\n    recipientPresenter.initFromMailto(mailTo);\n\n    String subject = mailTo.getSubject();\n    if (subject != null && !subject.isEmpty()) {\n      mSubjectView.setText(subject);\n    }\n\n    String body = mailTo.getBody();\n    if (body != null && !subject.isEmpty()) {\n      mMessageContentView.setCharacters(body);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "develop",
            "token": 78,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1828564560-1644006076834": [
        {
            "ProgrammID": 283,
            "lineNumberOfError": 22,
            "attempt": 2,
            "expectedAnswer": 22,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644006271677,
            "program": "  protected <T> void writeBody(\n      T o,\n      Message outMessage,\n      Class<?> cls,\n      Type type,\n      Annotation[] anns,\n      MultivaluedMap<String, Object> headers,\n      OutputStream os) {\n\n    if (o == null) {\n      return;\n    }\n    @SuppressWarnings(\"unchecked\")\n    Class<T> theClass = (Class<T>) cls;\n\n    MediaType contentType = MediaType.valueOf(headers.getFirst(\"Content-Type\").toString());\n\n    MessageBodyWriter<T> mbw =\n        ProviderFactory.getInstance(outMessage)\n            .createMessageBodyWriter(theClass, type, anns, contentType, outMessage);\n    if (mbw != null) {\n      try {\n        mbw.writeTo(o, cls, type, anns, contentType, headers, os);\n        if (os != null) {\n          os.flush();\n        }\n      } catch (Exception ex) {\n        reportMessageHandlerProblem(\"MSG_WRITER_PROBLEM\", cls, contentType, ex, null);\n      }\n    } else {\n      reportMessageHandlerProblem(\"NO_MSG_WRITER\", cls, contentType, null, null);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 194,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 294,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644006340969,
            "program": "  default <T> T get(Class<T> key) {\n    T v = get((Object) key);\n    if (key.isInstance(v)) {\n      return v;\n    }\n    return null;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 43,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 254,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644006419793,
            "program": "  public static MetadataListStructObjectInspector getInstance(List<String> columnNames) {\n    ArrayList<List<String>> key = new ArrayList<List<String>>(1);\n    key.add(columnNames);\n    MetadataListStructObjectInspector result = cached.get(key);\n    if (result == null) {\n      result = new MetadataListStructObjectInspector(columnNames);\n      MetadataListStructObjectInspector prev = cached.putIfAbsent(key, result);\n      if (prev != null) {\n        result = prev;\n      }\n    }\n    return result;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 94,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 300,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644006557617,
            "program": "  private ClassNode configureWildcardType(WildcardType wildcardType) {\r\n    ClassNode base = ClassHelper.makeWithoutCaching(\"?\");\r\n    base.setRedirect(ClassHelper.OBJECT_TYPE);\r\n    // TODO: more than one lower bound for wildcards?\r\n    ClassNode[] lowers = configureTypes(wildcardType.getLowerBounds());\r\n    ClassNode lower = null;\r\n    // TODO: is it safe to remove this? What was the original intention?\r\n    if (lower != null) lower = lowers[0];\r\n\r\n    ClassNode[] upper = configureTypes(wildcardType.getUpperBounds());\r\n    GenericsType t = new GenericsType(base, upper, lower);\r\n    t.setWildcard(true);\r\n\r\n    ClassNode ref = ClassHelper.makeWithoutCaching(Object.class, false);\r\n    ref.setGenericsTypes(new GenericsType[] {t});\r\n\r\n    return ref;\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 124,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 256,
            "lineNumberOfError": 20,
            "attempt": 2,
            "expectedAnswer": 20,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644006690162,
            "program": "  private void parseOptions(String optionsPart) {\n    for (String _part : optionsPart.split(\"&|;\")) {\n      int idx = _part.indexOf(\"=\");\n      if (idx >= 0) {\n        String key = _part.substring(0, idx).toLowerCase();\n        String value = _part.substring(idx + 1);\n        if (key.equals(\"maxpoolsize\")) _options.connectionsPerHost = Integer.parseInt(value);\n        else if (key.equals(\"minpoolsize\"))\n          LOGGER.warning(\"Currently No support in Java driver for Min Pool Size.\");\n        else if (key.equals(\"waitqueuemultiple\"))\n          _options.threadsAllowedToBlockForConnectionMultiplier = Integer.parseInt(value);\n        else if (key.equals(\"waitqueuetimeoutms\")) _options.maxWaitTime = Integer.parseInt(value);\n        else if (key.equals(\"connecttimeoutms\")) _options.connectTimeout = Integer.parseInt(value);\n        else if (key.equals(\"sockettimeoutms\")) _options.socketTimeout = Integer.parseInt(value);\n        else if (key.equals(\"autoconnectretry\")) _options.autoConnectRetry = _parseBoolean(value);\n        else if (key.equals(\"slaveok\")) _options.slaveOk = _parseBoolean(value);\n        else if (key.equals(\"safe\")) _options.safe = _parseBoolean(value);\n        else if (key.equals(\"w\")) _options.w = Integer.parseInt(value);\n        else if (key.equals(\"wtimeout\")) _options.wtimeout = Integer.parseInt(value);\n        else if (key.equals(\"fsync\")) _options.fsync = _parseBoolean(value);\n        else LOGGER.warning(\"Unknown or Unsupported Option '\" + value + \"'\");\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 320,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 250,
            "lineNumberOfError": 4,
            "attempt": 2,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644006725817,
            "program": "  static boolean extendsThread(ClassObj clazz) {\n    boolean extendsThread = false;\n    ClassObj parentClass = clazz;\n    while (parentClass.getSuperClassObj() != null) {\n      if (clazz.getClassName().equals(Thread.class.getName())) {\n        extendsThread = true;\n        break;\n      }\n      parentClass = parentClass.getSuperClassObj();\n    }\n    return extendsThread;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 69,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 279,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644006855361,
            "program": "  private void cleanDirectory(final VirtualFile dir) {\n    new WriteCommandAction(myProject) {\n      protected void run(Result result) throws Throwable {\n        deleteChildrenRecursively(dir);\n      }\n\n      private void deleteChildrenRecursively(final VirtualFile dir) throws IOException {\n        for (final VirtualFile child : dir.getChildren()) {\n          if (child.isDirectory()) {\n            deleteChildrenRecursively(child);\n          }\n          TranslatingCompilerFilesMonitor.removeSourceInfo(child);\n          child.delete(this);\n        }\n      }\n    }.execute();\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 93,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 252,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644006997559,
            "program": "  public void addIterationHead(\n      Integer vertexID, Integer iterationHead, Integer iterationID, long timeOut) {\n\n    addNode(vertexID, StreamIterationHead.class, null, null);\n\n    chaining = false;\n\n    StreamLoop iteration = new StreamLoop(iterationID, getStreamNode(vertexID), timeOut);\n    streamLoops.put(iterationID, iteration);\n    vertexIDtoLoop.put(vertexID, iteration);\n\n    setSerializersFrom(iterationHead, vertexID);\n    getStreamNode(vertexID).setOperatorName(\"IterationHead-\" + iterationHead);\n\n    int outpartitionerIndex = getStreamNode(iterationHead).getInEdgeIndices().get(0);\n    StreamPartitioner<?> outputPartitioner =\n        getStreamNode(outpartitionerIndex).getOutEdges().get(0).getPartitioner();\n\n    addEdge(vertexID, iterationHead, outputPartitioner, 0, new ArrayList<String>());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ITERATION SOURCE: {}\", vertexID);\n    }\n\n    sources.add(vertexID);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,develop",
            "token": 174,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1825587248-1644009860972": [
        {
            "ProgrammID": 307,
            "lineNumberOfError": 11,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644010221535,
            "program": "  public ScheduledEntry<K, V> cancelComparingTimeKey(K key) {\n    Set<TimeKey> candidateKeys = new HashSet<TimeKey>();\n    for (Object tkey : secondsOfKeys.keySet()) {\n      TimeKey timeKey = (TimeKey) tkey;\n      if (timeKey.getKey().equals(key)) {\n        candidateKeys.add(timeKey);\n      }\n    }\n\n    ScheduledEntry<K, V> result = null;\n    for (TimeKey timeKey : candidateKeys) {\n      final Integer second = secondsOfKeys.remove(timeKey);\n      if (second != null) {\n        final ConcurrentMap<Object, ScheduledEntry<K, V>> entries = scheduledEntries.get(second);\n        if (entries != null) {\n          result = entries.remove(timeKey);\n        }\n      }\n    }\n\n    return result;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 150,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 277,
            "lineNumberOfError": 23,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644010282080,
            "program": "  public void testClear() {\n    BooleanSubscription s1 = new BooleanSubscription();\n    BooleanSubscription s2 = new BooleanSubscription();\n\n    CompositeSubscription s = new CompositeSubscription();\n    s.add(s1);\n    s.add(s2);\n\n    assertFalse(s1.isUnsubscribed());\n    assertFalse(s2.isUnsubscribed());\n\n    s.clear();\n\n    assertTrue(s1.isUnsubscribed());\n    assertTrue(s2.isUnsubscribed());\n    assertFalse(s.isUnsubscribed());\n\n    BooleanSubscription s3 = new BooleanSubscription();\n\n    s.add(s3);\n    s.unsubscribe();\n\n    assertTrue(s3.isUnsubscribed());\n    assertTrue(s.isUnsubscribed());\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 135,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 306,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644010355175,
            "program": "  protected void processTypeSwitch(AbstractBeginNode beginNode, TypeSwitchNode typeSwitch) {\n    ValueNode hub = typeSwitch.value();\n    if (hub instanceof LoadHubNode) {\n      LoadHubNode loadHub = (LoadHubNode) hub;\n      ValueNode value = loadHub.getValue();\n      if (maybeMultipleUsages(value)) {\n        Stamp stamp = null;\n        for (int i = 0; i < typeSwitch.keyCount(); i++) {\n          if (typeSwitch.keySuccessor(i) == beginNode) {\n            if (stamp == null) {\n              stamp =\n                  StampFactory.objectNonNull(\n                      TypeReference.createExactTrusted(typeSwitch.typeAt(i)));\n            } else {\n              stamp =\n                  stamp.meet(\n                      StampFactory.objectNonNull(\n                          TypeReference.createExactTrusted(typeSwitch.typeAt(i))));\n            }\n          }\n        }\n        if (stamp != null) {\n          registerNewStamp(value, stamp, beginNode);\n        }\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 164,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 305,
            "lineNumberOfError": 5,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644010450022,
            "program": "  private void assertEqualClusterDescriptions(\n      final ClusterDescription expected, final ClusterDescription actual) {\n    assertEquals(expected.getType(), actual.getType());\n    assertEquals(expected.getAll().size(), actual.getAll().size());\n    for (ServerDescription curExpected : actual.getAll()) {\n      ServerDescription curActual = getByServerAddress(curExpected.getAddress(), actual.getAll());\n      assertNotNull(curActual);\n      assertEqualServerDescriptions(curExpected, curActual);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 95,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 304,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644010500075,
            "program": "  static Object unwrapResourceIfNecessary(Object resource) {\n    Assert.notNull(resource, \"Resource must not be null\");\n    Object resourceRef = resource;\n    // unwrap infrastructure proxy\n    if (resourceRef instanceof InfrastructureProxy) {\n      resourceRef = ((InfrastructureProxy) resourceRef).getWrappedObject();\n    }\n    if (aopAvailable) {\n      // now unwrap scoped proxy\n      resourceRef = ScopedProxyUnwrapper.unwrapIfNecessary(resourceRef);\n    }\n    return resourceRef;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 62,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 264,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 25,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644010550267,
            "program": "  private void verify(IndexWriter writer) throws Exception {\n    CheckIndex checkIndex = new CheckIndex(writer.getDirectory());\n    CheckIndex.Status status = checkIndex.checkIndex();\n    assertThat(status.clean, equalTo(true));\n    IndexReader reader = DirectoryReader.open(writer, true);\n    final Bits liveDocs = MultiFields.getLiveDocs(reader);\n    for (int i = 0; i < reader.maxDoc(); i++) {\n      if (liveDocs != null && !liveDocs.get(i)) {\n        continue;\n      }\n      Document document = reader.document(i);\n      checkDoc(document);\n      DocumentStoredFieldVisitor visitor = new DocumentStoredFieldVisitor(\"id\", \"field\", \"count\");\n      reader.document(i, visitor);\n      document = visitor.getDocument();\n      checkDoc(document);\n    }\n    for (int i = 0; i < 100; i++) {\n      int doc = ThreadLocalRandom.current().nextInt(reader.maxDoc());\n      if (liveDocs != null && !liveDocs.get(i)) {\n        continue;\n      }\n      Document document = reader.document(doc);\n      checkDoc(document);\n      DocumentStoredFieldVisitor visitor = new DocumentStoredFieldVisitor(\"id\", \"field\", \"count\");\n      reader.document(i, visitor);\n      document = visitor.getDocument();\n      checkDoc(document);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 260,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 240,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644010579208,
            "program": "  public void setImeWindowStatus(\n      IBinder token, IBinder startInputToken, int vis, int backDisposition) {\n    if (!calledWithValidToken(token)) {\n      return;\n    }\n\n    final StartInputInfo info;\n    synchronized (mMethodMap) {\n      info = mStartInputMap.get(startInputToken);\n      mImeWindowVis = vis;\n      mBackDisposition = backDisposition;\n      updateSystemUiLocked(token, vis, backDisposition);\n    }\n    mWindowManagerInternal.updateInputMethodWindowStatus(\n        token,\n        (vis & InputMethodService.IME_VISIBLE) != 0,\n        info != null ? info.mTargetWindow : null);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 93,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 284,
            "lineNumberOfError": 16,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644010709876,
            "program": "  public Map<Long, List<Layout>> getLayoutChildLayouts(\n      LayoutSet layoutSet, List<Layout> parentLayouts) {\n\n    List<Layout> childLayouts =\n        _getChildLayouts(layoutSet, ListUtil.toLongArray(parentLayouts, Layout::getLayoutId));\n\n    Map<Long, List<Layout>> layoutChildLayouts = new HashMap<>();\n\n    for (Layout childLayout : childLayouts) {\n      List<Layout> layoutChildLayoutsList =\n          layoutChildLayouts.computeIfAbsent(\n              childLayout.getParentLayoutId(), (parentLayoutId) -> new ArrayList<>());\n\n      layoutChildLayoutsList.add(childLayout);\n    }\n\n    for (List<Layout> layoutChildLayoutsList : layoutChildLayouts.values()) {\n\n      layoutChildLayoutsList.sort(Comparator.comparing(Layout::getPriority));\n    }\n\n    return layoutChildLayouts;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 140,
            "ctx": "oss",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "1724533716-1644013571362": [
        {
            "ProgrammID": 262,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644014109905,
            "program": "  protected void onNewIntent(Intent intent) {\n    super.onNewIntent(intent);\n    if (isFinishing()) return;\n\n    chatViewerAdapter.onChange();\n\n    String account = getAccount(intent);\n    String user = getUser(intent);\n    if (account == null || user == null) {\n      return;\n    }\n\n    LogManager.i(this, \"onNewIntent account: \" + account + \", user: \" + user);\n\n    actionWithUser = user;\n    actionWithAccount = user;\n\n    selectPage(false);\n    onChatSelected();\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 92,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 272,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644014220494,
            "program": "  protected void renderTemplate(\n      Map<String, Object> model,\n      GrailsWebRequest webRequest,\n      HttpServletRequest request,\n      HttpServletResponse response)\n      throws Exception {\n    Content content = obtainContent(model, webRequest, request, response);\n    if (content != null) {\n      beforeDecorating(content, model, webRequest, request, response);\n      SpringMVCViewDecorator decorator =\n          (SpringMVCViewDecorator) groovyPageLayoutFinder.findLayout(request, content);\n      if (decorator != null) {\n        decorator.render(content, model, request, response, webRequest.getServletContext());\n      } else {\n        PrintWriter writer = response.getWriter();\n        content.writeOriginal(writer);\n        if (!response.isCommitted()) {\n          writer.flush();\n        }\n      }\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 138,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 303,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": 3,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644014270515,
            "program": "  public Map<String, T> copy(Map<String, T> value) {\n    if (value != null) {\n      Map<String, T> result = Maps.newHashMap();\n      for (Map.Entry<String, T> entry : result.entrySet()) {\n        result.put(entry.getKey(), contentsHandler.copy(entry.getValue()));\n      }\n      return result;\n    }\n    return null;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 89,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 274,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644014415483,
            "program": "  public static void unboxInlineClass(\n      @NotNull Type type,\n      @NotNull KotlinType targetInlineClassType,\n      @NotNull InstructionAdapter v) {\n    Type owner = KotlinTypeMapper.mapInlineClassTypeAsDeclaration(targetInlineClassType);\n\n    coerce(type, owner, v);\n\n    Type resultType = KotlinTypeMapper.mapUnderlyingTypeOfInlineClassType(targetInlineClassType);\n\n    if (TypeUtils.isNullableType(targetInlineClassType) && !isPrimitive(type)) {\n      boxOrUnboxWithNullCheck(v, vv -> invokeUnboxMethod(vv, owner, resultType));\n    } else {\n      invokeUnboxMethod(v, owner, resultType);\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 96,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 299,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644014471791,
            "program": "  public double distance(double centroidLengthSquare, Vector centroid, Vector v) {\n    if (centroid.size() != v.size()) {\n      throw new CardinalityException();\n    }\n\n    double result = centroidLengthSquare;\n    result += v.getDistanceSquared(centroid);\n    return result;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 54,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 281,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644014652653,
            "program": "  Map<VirtualFile, Object[]> getDirectInheritors(\n      @NotNull LightRef searchElement,\n      @NotNull GlobalSearchScope searchScope,\n      @NotNull GlobalSearchScope dirtyScope,\n      @NotNull FileType fileType,\n      @NotNull CompilerHierarchySearchType searchType)\n      throws StorageException {\n    GlobalSearchScope effectiveSearchScope =\n        GlobalSearchScope.notScope(dirtyScope).intersectWith(searchScope);\n    LanguageLightRefAdapter adapter = CompilerReferenceServiceImpl.findAdapterForFileType(fileType);\n    LOG.assertTrue(adapter != null, \"adapter is null for file type: \" + fileType);\n    Class<? extends LightRef> requiredLightRefClass = searchType.getRequiredClass(adapter);\n\n    Map<VirtualFile, Object[]> candidatesPerFile = new HashMap<>();\n    myIndex\n        .get(CompilerIndices.BACK_HIERARCHY)\n        .getData(searchElement)\n        .forEach(\n            (fileId, defs) -> {\n              final List<LightRef> requiredCandidates =\n                  defs.stream().filter(requiredLightRefClass::isInstance).collect(toList());\n              if (requiredCandidates.isEmpty()) return true;\n              final VirtualFile file = findFile(fileId);\n              if (file != null && effectiveSearchScope.contains(file)) {\n                candidatesPerFile.put(\n                    file, searchType.convertToIds(requiredCandidates, myIndex.getByteSeqEum()));\n              }\n              return true;\n            });\n    return candidatesPerFile.isEmpty() ? Collections.emptyMap() : candidatesPerFile;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 235,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 297,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644014888729,
            "program": "  public boolean satisfiedBy(PsiElement element) {\n    final PsiElement parent = element.getParent();\n    if (!(parent instanceof GrTypeDefinition)) return false;\n    if (((GrTypeDefinition) parent).getNameIdentifierGroovy() != element) return false;\n\n    final String name = ((GrTypeDefinition) element).getName();\n    if (name == null || name.length() == 0) return false;\n    final PsiFile file = element.getContainingFile();\n    if (!(file instanceof GroovyFile)) return false;\n    if (!file.isPhysical()) return false;\n    if (name.equals(FileUtil.getNameWithoutExtension(file.getName()))) return false;\n    if (mySearchForClassInMultiClassFile) {\n      return ((GroovyFile) file).getClasses().length > 1;\n    } else {\n      return !((GroovyFile) file).isScript();\n    }\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 174,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 241,
            "lineNumberOfError": 22,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644015069092,
            "program": "  public URL getResource(String name) {\n    if (_notFound.contains(name)) {\n      if (LOG.isDebugEnabled()) LOG.debug(\"Not found cache hit resource {}\", name);\n      return null;\n    }\n\n    URL url = _cache.get(name);\n\n    if (url == null) {\n      // Not found in cache, try parent\n      url = super.getResource(name);\n\n      if (url == null) {\n        // Still not found, cache the not-found result\n        if (LOG.isDebugEnabled()) LOG.debug(\"Caching not found resource {}\", name);\n        _notFound.add(name);\n      } else {\n        // Cache the new result\n        _cache.putIfAbsent(name, url);\n      }\n    }\n\n    return url;\n  }\n",
            "exp": "2",
            "age": "30",
            "task": "develop",
            "token": 114,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "132734651-1644059089689": [
        {
            "ProgrammID": 287,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644060140051,
            "program": "  public final String resolveRelativePathEntry(String path, String relativeTo) {\n    if (relativeTo == null) {\n      return AbsolutePathService.convertPath(path);\n    } else {\n      PathEntry pathEntry;\n      synchronized (pathEntries) {\n        pathEntry = pathEntries.get(relativeTo);\n        if (pathEntry == null) {\n          throw MESSAGES.pathEntryNotFound(path);\n        }\n        return RelativePathService.doResolve(pathEntry.resolvePath(), path);\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 80,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 292,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644060214205,
            "program": "  public void track(WPStats.Stat stat, JSONObject properties) {\n    WPStatsTrackerMixpanelInstructionsForStat instructions = instructionsForStat(stat);\n\n    if (instructions == null) return;\n\n    trackMixpanelDataForInstructions(instructions, properties);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 37,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 308,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644060364165,
            "program": "  protected long getResourcePermissionCount(long companyId, String name, int scope, long roleId) {\n\n    DynamicQuery dynamicQuery = _resourcePermissionLocalService.dynamicQuery();\n\n    Property companyIdProperty = PropertyFactoryUtil.forName(\"companyId\");\n\n    dynamicQuery.add(companyIdProperty.eq(companyId));\n\n    Property nameProperty = PropertyFactoryUtil.forName(\"name\");\n\n    dynamicQuery.add(nameProperty.eq(name));\n\n    Property scopeProperty = PropertyFactoryUtil.forName(\"scope\");\n\n    dynamicQuery.add(scopeProperty.eq(scope));\n\n    Property roleIdProperty = PropertyFactoryUtil.forName(\"roleId\");\n\n    dynamicQuery.add(roleIdProperty.eq(roleId));\n\n    return _resourcePermissionLocalService.dynamicQueryCount(dynamicQuery);\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 123,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 271,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644060683140,
            "program": "  private static void registerCustomAnnotators(\n      AnnotatorPool pool, AnnotatorImplementations annotatorImplementation, Properties inputProps) {\n    // add annotators loaded via reflection from class names specified\n    // in the properties\n    for (String property : inputProps.stringPropertyNames()) {\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName = property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        logger.info(\"Registering annotator \" + customName + \" with class \" + customClassName);\n        pool.register(\n            customName,\n            inputProps,\n            Lazy.of(() -> annotatorImplementation.custom(inputProps, property)));\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 105,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 273,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644061127908,
            "program": "  private int recursiveCollapse(@IntRange(from = 0) int position) {\n    T item = getItem(position);\n    if (!isExpandable(item)) {\n      return 0;\n    }\n    IExpandable expandable = (IExpandable) item;\n    int subItemCount = 0;\n    if (expandable.isExpanded()) {\n      List<T> subItems = expandable.getSubItems();\n      for (int i = subItems.size() - 1; i >= 0; i--) {\n        T subItem = subItems.get(i);\n        int pos = getItemPosition(subItem);\n        if (pos < 0) {\n          continue;\n        }\n        if (subItem instanceof IExpandable) {\n          subItemCount += recursiveCollapse(pos);\n        }\n        mData.remove(subItem);\n        subItemCount++;\n      }\n    }\n    return subItemCount;\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 150,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 268,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644061234088,
            "program": "  private void addInputBindRow(SimpleUri uri, RegisterBindButton bind, ColumnLayout layout) {\n    UIInputBindButton inputBind = new UIInputBindButton();\n    inputBind.setManager(getManager());\n    inputBind.setDescription(bind.description());\n    inputBind.bindInput(new InputConfigBinding(config.getInput().getBinds(), uri));\n    UIInputBindButton secondaryInputBind = new UIInputBindButton();\n    secondaryInputBind.setManager(getManager());\n    secondaryInputBind.setDescription(bind.description());\n    secondaryInputBind.bindInput(new InputConfigBinding(config.getInput().getBinds(), uri, 1));\n    layout.addWidget(\n        new RowLayout(new UILabel(bind.description()), inputBind, secondaryInputBind)\n            .setColumnRatios(0.4f)\n            .setHorizontalSpacing(horizontalSpacing));\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 148,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 301,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644061317119,
            "program": "  public void renameElement(\n      final PsiElement element,\n      final String newName,\n      final boolean searchInComments,\n      final boolean searchTextOccurrences) {\n    new WriteCommandAction.Simple(myProjectFixture.getProject()) {\n      @Override\n      protected void run() throws Exception {\n        final PsiElement substitution =\n            RenamePsiElementProcessor.forElement(element)\n                .substituteElementToRename(element, myEditor);\n        if (element == null) return;\n        new RenameProcessor(\n                myProjectFixture.getProject(),\n                substitution,\n                newName,\n                searchInComments,\n                searchTextOccurrences)\n            .run();\n      }\n    }.execute().throwException();\n  }\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 103,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 265,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644061429705,
            "program": "  public void glGenBuffers(int n, int[] buffers, int offset) {\r\n    for (int i = offset; i < offset + n; i++) buffers[i] = GL15.glGenBuffers();\r\n  }\r\n",
            "exp": "5",
            "age": "31-50",
            "task": "develop,review,test",
            "token": 44,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1216134486-1644069159171": [
        {
            "ProgrammID": 260,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644069771807,
            "program": "  public InstallState getInstallState(Version system) {\r\n    if (StringUtils.isEmpty(installedRelease)) {\r\n      return InstallState.NOT_INSTALLED;\r\n    }\r\n    Version ir = Version.createVersion(installedRelease);\r\n    Version cr = Version.ZERO;\r\n    PluginRelease curr = getCurrentRelease(system);\r\n    if (curr != null) {\r\n      cr = Version.createVersion(curr.version);\r\n    }\r\n    switch (ir.compareTo(cr)) {\r\n      case -1:\r\n        return InstallState.UNKNOWN;\r\n      case 1:\r\n        return InstallState.UPDATE_AVAILABLE;\r\n      default:\r\n        return InstallState.INSTALLED;\r\n    }\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 104,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 282,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644069888146,
            "program": "  public static net.osmand.Location convertLocation(Location l, OsmandApplication app) {\n    net.osmand.Location r = new net.osmand.Location(l.getProvider());\n    r.setLatitude(l.getLatitude());\n    r.setLongitude(l.getLongitude());\n    r.setTime(l.getTime());\n    if (l.hasAccuracy()) {\n      r.setAccuracy(l.getAccuracy());\n    }\n    if (l.hasSpeed()) {\n      r.setSpeed(l.getSpeed());\n    }\n    if (l.hasAltitude()) {\n      r.setAltitude(l.getAltitude());\n    }\n    if (l.hasBearing()) {\n      r.setBearing(l.getBearing());\n    }\n    if (l.hasAltitude() && app != null) {\n      double alt = l.getAltitude();\n      final GeoidAltitudeCorrection geo = app.getResourceManager().getGeoidAltitudeCorrection();\n      if (geo != null) {\n        alt -= geo.getGeoidHeight(l.getLatitude(), l.getLongitude());\n        r.setAltitude(alt);\n      }\n    }\n    return r;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 229,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 275,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644070047103,
            "program": "  private static Set<WorkerSlot> badSlots(\n      Map<WorkerSlot, List<ExecutorDetails>> existingSlots, int numExecutors, int numWorkers) {\n    if (numWorkers != 0) {\n      Map<Integer, Integer> distribution = Utils.integerDivided(numExecutors, numWorkers);\n      Set<WorkerSlot> slots = new HashSet<WorkerSlot>();\n\n      for (Entry<WorkerSlot, List<ExecutorDetails>> entry : existingSlots.entrySet()) {\n        Integer executorCount = entry.getValue().size();\n        Integer workerCount = distribution.get(executorCount);\n        if (workerCount != null && workerCount > 0) {\n          slots.add(entry.getKey());\n          workerCount--;\n          distribution.put(executorCount, workerCount);\n        }\n      }\n\n      for (WorkerSlot slot : slots) {\n        existingSlots.remove(slot);\n      }\n\n      return existingSlots.keySet();\n    }\n\n    return null;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 171,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 283,
            "lineNumberOfError": 22,
            "attempt": 1,
            "expectedAnswer": 22,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644070219381,
            "program": "  protected <T> void writeBody(\n      T o,\n      Message outMessage,\n      Class<?> cls,\n      Type type,\n      Annotation[] anns,\n      MultivaluedMap<String, Object> headers,\n      OutputStream os) {\n\n    if (o == null) {\n      return;\n    }\n    @SuppressWarnings(\"unchecked\")\n    Class<T> theClass = (Class<T>) cls;\n\n    MediaType contentType = MediaType.valueOf(headers.getFirst(\"Content-Type\").toString());\n\n    MessageBodyWriter<T> mbw =\n        ProviderFactory.getInstance(outMessage)\n            .createMessageBodyWriter(theClass, type, anns, contentType, outMessage);\n    if (mbw != null) {\n      try {\n        mbw.writeTo(o, cls, type, anns, contentType, headers, os);\n        if (os != null) {\n          os.flush();\n        }\n      } catch (Exception ex) {\n        reportMessageHandlerProblem(\"MSG_WRITER_PROBLEM\", cls, contentType, ex, null);\n      }\n    } else {\n      reportMessageHandlerProblem(\"NO_MSG_WRITER\", cls, contentType, null, null);\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 194,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 284,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644070344589,
            "program": "  public Map<Long, List<Layout>> getLayoutChildLayouts(\n      LayoutSet layoutSet, List<Layout> parentLayouts) {\n\n    List<Layout> childLayouts =\n        _getChildLayouts(layoutSet, ListUtil.toLongArray(parentLayouts, Layout::getLayoutId));\n\n    Map<Long, List<Layout>> layoutChildLayouts = new HashMap<>();\n\n    for (Layout childLayout : childLayouts) {\n      List<Layout> layoutChildLayoutsList =\n          layoutChildLayouts.computeIfAbsent(\n              childLayout.getParentLayoutId(), (parentLayoutId) -> new ArrayList<>());\n\n      layoutChildLayoutsList.add(childLayout);\n    }\n\n    for (List<Layout> layoutChildLayoutsList : layoutChildLayouts.values()) {\n\n      layoutChildLayoutsList.sort(Comparator.comparing(Layout::getPriority));\n    }\n\n    return layoutChildLayouts;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 140,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 285,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644070430773,
            "program": "  protected Principal getPrincipal(String username) {\n\n    User user = database.findUser(username);\n    if (user == null) {\n      return null;\n    }\n\n    List roles = new ArrayList();\n    Iterator uroles = user.getRoles();\n    while (uroles.hasNext()) {\n      Role role = (Role) uroles.next();\n      roles.add(role.getName());\n    }\n    Iterator groups = user.getGroups();\n    while (groups.hasNext()) {\n      Group group = (Group) groups.next();\n      uroles = group.getRoles();\n      while (uroles.hasNext()) {\n        Role role = (Role) uroles.next();\n        roles.add(role.getName());\n      }\n    }\n    return new GenericPrincipal(this, username, user.getPassword(), roles, user);\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 171,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 286,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644070481237,
            "program": "  public static View findParentViewHolderItemView(View v) {\n    final ViewParent parent = v.getParent();\n    if (parent instanceof RecyclerView) {\n      // returns the passed instance if the parent is RecyclerView\n      return v;\n    } else if (parent instanceof View) {\n      // check the parent view recursively\n      return findParentViewHolderItemView((View) parent);\n    } else {\n      return null;\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 55,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        },
        {
            "ProgrammID": 287,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644070559756,
            "program": "  public final String resolveRelativePathEntry(String path, String relativeTo) {\n    if (relativeTo == null) {\n      return AbsolutePathService.convertPath(path);\n    } else {\n      PathEntry pathEntry;\n      synchronized (pathEntries) {\n        pathEntry = pathEntries.get(relativeTo);\n        if (pathEntry == null) {\n          throw MESSAGES.pathEntryNotFound(path);\n        }\n        return RelativePathService.doResolve(pathEntry.resolvePath(), path);\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "test,review,develop",
            "token": 80,
            "ctx": "commercial",
            "codebase": "others",
            "team": "small"
        }
    ],
    "1747818774-1644073084288": [
        {
            "ProgrammID": 282,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644073349901,
            "program": "  public static net.osmand.Location convertLocation(Location l, OsmandApplication app) {\n    net.osmand.Location r = new net.osmand.Location(l.getProvider());\n    r.setLatitude(l.getLatitude());\n    r.setLongitude(l.getLongitude());\n    r.setTime(l.getTime());\n    if (l.hasAccuracy()) {\n      r.setAccuracy(l.getAccuracy());\n    }\n    if (l.hasSpeed()) {\n      r.setSpeed(l.getSpeed());\n    }\n    if (l.hasAltitude()) {\n      r.setAltitude(l.getAltitude());\n    }\n    if (l.hasBearing()) {\n      r.setBearing(l.getBearing());\n    }\n    if (l.hasAltitude() && app != null) {\n      double alt = l.getAltitude();\n      final GeoidAltitudeCorrection geo = app.getResourceManager().getGeoidAltitudeCorrection();\n      if (geo != null) {\n        alt -= geo.getGeoidHeight(l.getLatitude(), l.getLongitude());\n        r.setAltitude(alt);\n      }\n    }\n    return r;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "review,develop",
            "token": 229,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 266,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644073392235,
            "program": "  public Future<Boolean> removeAllAsync(Collection<?> c) {\n    if (c.isEmpty()) {\n      return newSucceededFuture(false);\n    }\n\n    List<Object> args = new ArrayList<Object>(c.size() + 1);\n    args.add(getName());\n    args.addAll(c);\n\n    return commandExecutor.writeAsync(getName(), codec, RedisCommands.SREM_SINGLE, args.toArray());\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "review,develop",
            "token": 90,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 278,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644073487603,
            "program": "  public AsyncSupport resolve(\n      boolean useNativeIfPossible, boolean defaultToBlocking, boolean useServlet30Async) {\n    AsyncSupport cs = null;\n\n    // Validate the value for old Servlet Container.\n    useServlet30Async = testClassExists(SERVLET_30);\n\n    if (!defaultToBlocking) {\n      List<Class<? extends AsyncSupport>> l =\n          detectWebSocketPresent(useNativeIfPossible, useServlet30Async);\n\n      if (!l.isEmpty()) {\n        cs = resolveWebSocket(l);\n      }\n    }\n\n    if (cs == null) {\n      AsyncSupport nativeSupport = resolveNativeCometSupport(detectContainersPresent());\n      return nativeSupport == null ? defaultCometSupport(defaultToBlocking) : nativeSupport;\n    } else {\n      return cs;\n    }\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "review,develop",
            "token": 106,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 284,
            "lineNumberOfError": 13,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644073575033,
            "program": "  public Map<Long, List<Layout>> getLayoutChildLayouts(\n      LayoutSet layoutSet, List<Layout> parentLayouts) {\n\n    List<Layout> childLayouts =\n        _getChildLayouts(layoutSet, ListUtil.toLongArray(parentLayouts, Layout::getLayoutId));\n\n    Map<Long, List<Layout>> layoutChildLayouts = new HashMap<>();\n\n    for (Layout childLayout : childLayouts) {\n      List<Layout> layoutChildLayoutsList =\n          layoutChildLayouts.computeIfAbsent(\n              childLayout.getParentLayoutId(), (parentLayoutId) -> new ArrayList<>());\n\n      layoutChildLayoutsList.add(childLayout);\n    }\n\n    for (List<Layout> layoutChildLayoutsList : layoutChildLayouts.values()) {\n\n      layoutChildLayoutsList.sort(Comparator.comparing(Layout::getPriority));\n    }\n\n    return layoutChildLayouts;\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "review,develop",
            "token": 140,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 301,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644073643281,
            "program": "  public void renameElement(\n      final PsiElement element,\n      final String newName,\n      final boolean searchInComments,\n      final boolean searchTextOccurrences) {\n    new WriteCommandAction.Simple(myProjectFixture.getProject()) {\n      @Override\n      protected void run() throws Exception {\n        final PsiElement substitution =\n            RenamePsiElementProcessor.forElement(element)\n                .substituteElementToRename(element, myEditor);\n        if (element == null) return;\n        new RenameProcessor(\n                myProjectFixture.getProject(),\n                substitution,\n                newName,\n                searchInComments,\n                searchTextOccurrences)\n            .run();\n      }\n    }.execute().throwException();\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "review,develop",
            "token": 103,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 300,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": 7,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644073711219,
            "program": "  private ClassNode configureWildcardType(WildcardType wildcardType) {\r\n    ClassNode base = ClassHelper.makeWithoutCaching(\"?\");\r\n    base.setRedirect(ClassHelper.OBJECT_TYPE);\r\n    // TODO: more than one lower bound for wildcards?\r\n    ClassNode[] lowers = configureTypes(wildcardType.getLowerBounds());\r\n    ClassNode lower = null;\r\n    // TODO: is it safe to remove this? What was the original intention?\r\n    if (lower != null) lower = lowers[0];\r\n\r\n    ClassNode[] upper = configureTypes(wildcardType.getUpperBounds());\r\n    GenericsType t = new GenericsType(base, upper, lower);\r\n    t.setWildcard(true);\r\n\r\n    ClassNode ref = ClassHelper.makeWithoutCaching(Object.class, false);\r\n    ref.setGenericsTypes(new GenericsType[] {t});\r\n\r\n    return ref;\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "review,develop",
            "token": 124,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 280,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644073753431,
            "program": "  public float dst(final Vector3 vector) {\r\n    final float a = vector.x - x;\r\n    final float b = vector.y - y;\r\n    final float c = vector.z - z;\r\n\r\n    return (float) Math.sqrt(a * a + b * b + c * c);\r\n  }\r\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "review,develop",
            "token": 61,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        },
        {
            "ProgrammID": 291,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644073816454,
            "program": "  protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n    final Tokenizer source = new StandardTokenizer(matchVersion, reader);\n    TokenStream result = new StandardFilter(matchVersion, source);\n    result = new LowerCaseFilter(matchVersion, result);\n    result = new StopFilter(matchVersion, result, stopwords);\n    if (!stemExclusionSet.isEmpty()) {\n      result = new KeywordMarkerFilter(result, stemExclusionSet);\n    }\n    return new TokenStreamComponents(source, new IndonesianStemFilter(result));\n  }\n",
            "exp": "2-5",
            "age": "31-50",
            "task": "review,develop",
            "token": 91,
            "ctx": "commercial",
            "codebase": "others",
            "team": "large"
        }
    ],
    "11600327-1644257243975": [
        {
            "ProgrammID": 247,
            "lineNumberOfError": 7,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644257937557,
            "program": "  public void go(\n      final Canvas container, HashMap<String, String[]> pages, String pageKey, boolean firstTime) {\n    this.pages = pages;\n    this.container = container;\n\n    if (firstTime) {\n      String token = History.getToken();\n      if (pageKey.equals(BLCLaunch.getSelectedPage(token))\n          && MasterView.moduleKey.equals(BLCLaunch.getSelectedModule(token))) {\n        String itemId = BLCLaunch.getDefaultItem(token);\n        showView(pages.get(pageKey)[0], pages.get(pageKey)[1], itemId);\n      } else {\n        buildHistoryNewItem(pageKey);\n      }\n      return;\n    }\n\n    if (pageKey != null && pages.get(pageKey) != null) {\n      if (SecurityManager.getInstance().isUserAuthorizedToViewSection(pages.get(pageKey)[0])) {\n        buildHistoryNewItem(pageKey);\n        return;\n      }\n    }\n\n    for (String sectionTitle : pages.keySet()) {\n      if (SecurityManager.getInstance().isUserAuthorizedToViewSection(pages.get(sectionTitle)[0])) {\n        buildHistoryNewItem(sectionTitle);\n        break;\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 218,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 296,
            "lineNumberOfError": 20,
            "attempt": 1,
            "expectedAnswer": 10,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644258195357,
            "program": "  public ManagementStrategy create(CamelContext context, boolean disableJMX) {\n    ManagementStrategy answer = null;\n\n    if (disableJMX || Boolean.getBoolean(JmxSystemPropertyKeys.DISABLED)) {\n      log.info(\"JMX is disabled.\");\n    } else {\n      try {\n        ManagedManagementStrategy jmx =\n            new ManagedManagementStrategy(new DefaultManagementAgent(context));\n        // must start it to ensure JMX works and can load needed Spring JARs\n        ServiceHelper.startService(jmx);\n        // prefer to have it at first strategy\n        context.getLifecycleStrategies().add(0, new DefaultManagementLifecycleStrategy(context));\n        log.info(\"JMX enabled.\");\n      } catch (Exception e) {\n        answer = null;\n        log.warn(\"Cannot create JMX lifecycle strategy. Will fallback and disable JMX.\", e);\n      }\n    }\n\n    if (answer == null) {\n      answer = new DefaultManagementStrategy();\n    }\n    return answer;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 127,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 293,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644258317781,
            "program": "  private void tintIcons(Context context) {\n    Drawable sms =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_textsms_white_24dp));\n    Drawable notifications =\n        DrawableCompat.wrap(\n            ContextCompat.getDrawable(context, R.drawable.ic_notifications_white_24dp));\n    Drawable privacy =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_security_white_24dp));\n    Drawable appearance =\n        DrawableCompat.wrap(\n            ContextCompat.getDrawable(context, R.drawable.ic_brightness_6_white_24dp));\n    Drawable chats =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_forum_white_24dp));\n    Drawable devices =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_laptop_white_24dp));\n    Drawable advanced =\n        DrawableCompat.wrap(ContextCompat.getDrawable(context, R.drawable.ic_advanced_white_24dp));\n\n    int[] tintAttr = new int[] {R.attr.pref_icon_tint};\n    TypedArray typedArray = context.obtainStyledAttributes(tintAttr);\n    int color = typedArray.getColor(0, 0x0);\n    typedArray.recycle();\n\n    DrawableCompat.setTint(sms, color);\n    DrawableCompat.setTint(notifications, color);\n    DrawableCompat.setTint(privacy, color);\n    DrawableCompat.setTint(appearance, color);\n    DrawableCompat.setTint(chats, color);\n    DrawableCompat.setTint(devices, color);\n    DrawableCompat.setTint(advanced, color);\n\n    this.findPreference(PREFERENCE_CATEGORY_SMS_MMS).setIcon(sms);\n    this.findPreference(PREFERENCE_CATEGORY_NOTIFICATIONS).setIcon(notifications);\n    this.findPreference(PREFERENCE_CATEGORY_APP_PROTECTION).setIcon(privacy);\n    this.findPreference(PREFERENCE_CATEGORY_APPEARANCE).setIcon(appearance);\n    this.findPreference(PREFERENCE_CATEGORY_CHATS).setIcon(chats);\n    this.findPreference(PREFERENCE_CATEGORY_DEVICES).setIcon(devices);\n    this.findPreference(PREFERENCE_CATEGORY_ADVANCED).setIcon(advanced);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 348,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 289,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 18,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644258549326,
            "program": "  private String adjustPath(final String path) {\n    String adjustedPath = path;\n\n    if (RequestUtils.isDispatcherServletRequest()\n        && StringUtils.hasText(this.dispatcherServletPath)) {\n      if (!this.dispatcherServletPath.equals(\"/\")) {\n        adjustedPath = path.substring(this.dispatcherServletPath.length());\n        log.debug(\"Stripped dispatcherServletPath\");\n      }\n    } else if (RequestUtils.isZuulServletRequest()) {\n      if (StringUtils.hasText(this.zuulServletPath) && !this.zuulServletPath.equals(\"/\")) {\n        adjustedPath = path.substring(this.zuulServletPath.length());\n        log.debug(\"Stripped zuulServletPath\");\n      }\n    } else {\n      // do nothing\n    }\n\n    log.debug(\"adjustedPath=\" + path);\n    return adjustedPath;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 141,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 270,
            "lineNumberOfError": 9,
            "attempt": 1,
            "expectedAnswer": 15,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644259051088,
            "program": "  private static APKModule getModuleForLinkable(\n      MergedLibNativeLinkable linkable,\n      ImmutableMap<NativeLinkable, APKModule> linkableToModuleMap) {\n    APKModule module = null;\n    for (NativeLinkable constituent : linkable.constituents.getLinkables()) {\n      APKModule constituentModule = linkableToModuleMap.get(constituent);\n      if (module == null) {\n        module = constituentModule;\n      }\n      if (module != constituentModule) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Native library merge of \")\n            .append(linkable)\n            .append(\" has inconsistent application module mappings: \");\n        for (NativeLinkable innerConstituent : linkable.constituents.getLinkables()) {\n          APKModule innerConstituentModule = linkableToModuleMap.get(constituent);\n          sb.append(innerConstituent).append(\" -> \").append(innerConstituentModule).append(\", \");\n        }\n        throw new RuntimeException(\n            \"Native library merge of \"\n                + linkable\n                + \" has inconsistent application module mappings: \"\n                + sb);\n      }\n    }\n    return Preconditions.checkNotNull(module);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 161,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 256,
            "lineNumberOfError": 20,
            "attempt": 1,
            "expectedAnswer": 20,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644259266521,
            "program": "  private void parseOptions(String optionsPart) {\n    for (String _part : optionsPart.split(\"&|;\")) {\n      int idx = _part.indexOf(\"=\");\n      if (idx >= 0) {\n        String key = _part.substring(0, idx).toLowerCase();\n        String value = _part.substring(idx + 1);\n        if (key.equals(\"maxpoolsize\")) _options.connectionsPerHost = Integer.parseInt(value);\n        else if (key.equals(\"minpoolsize\"))\n          LOGGER.warning(\"Currently No support in Java driver for Min Pool Size.\");\n        else if (key.equals(\"waitqueuemultiple\"))\n          _options.threadsAllowedToBlockForConnectionMultiplier = Integer.parseInt(value);\n        else if (key.equals(\"waitqueuetimeoutms\")) _options.maxWaitTime = Integer.parseInt(value);\n        else if (key.equals(\"connecttimeoutms\")) _options.connectTimeout = Integer.parseInt(value);\n        else if (key.equals(\"sockettimeoutms\")) _options.socketTimeout = Integer.parseInt(value);\n        else if (key.equals(\"autoconnectretry\")) _options.autoConnectRetry = _parseBoolean(value);\n        else if (key.equals(\"slaveok\")) _options.slaveOk = _parseBoolean(value);\n        else if (key.equals(\"safe\")) _options.safe = _parseBoolean(value);\n        else if (key.equals(\"w\")) _options.w = Integer.parseInt(value);\n        else if (key.equals(\"wtimeout\")) _options.wtimeout = Integer.parseInt(value);\n        else if (key.equals(\"fsync\")) _options.fsync = _parseBoolean(value);\n        else LOGGER.warning(\"Unknown or Unsupported Option '\" + value + \"'\");\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 320,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 261,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644259443520,
            "program": "  public Key importKey(@NonNull String alias, byte[] keyBytes)\n      throws InternalRecoveryServiceException, LockScreenRequiredException {\n    try {\n      String grantAlias = mBinder.importKey(alias, keyBytes);\n      if (grantAlias == null) {\n        throw new InternalRecoveryServiceException(\"Null grant alias\");\n      }\n      return getKeyFromGrant(grantAlias);\n    } catch (RemoteException e) {\n      throw e.rethrowFromSystemServer();\n    } catch (UnrecoverableKeyException e) {\n      throw new InternalRecoveryServiceException(\"Failed to get key from keystore\", e);\n    } catch (ServiceSpecificException e) {\n      if (e.errorCode == ERROR_INSECURE_USER) {\n        throw new LockScreenRequiredException(e.getMessage());\n      }\n      throw wrapUnexpectedServiceSpecificException(e);\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 120,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 255,
            "lineNumberOfError": 27,
            "attempt": 1,
            "expectedAnswer": 27,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644260141459,
            "program": "  public static HostAddress resolveXMPPServerDomain(String domain) {\n    if (context == null) {\n      return new HostAddress(domain, 5269);\n    }\n    String host = domain;\n    int port = 5269;\n    try {\n      Attributes dnsLookup = context.getAttributes(\"_xmpp-server._tcp.\" + domain);\n      String srvRecord = (String) dnsLookup.get(\"SRV\").get();\n      String[] srvRecordEntries = srvRecord.split(\" \");\n      port = Integer.parseInt(srvRecordEntries[srvRecordEntries.length - 2]);\n      host = srvRecordEntries[srvRecordEntries.length - 1];\n    } catch (Exception e) {\n      // Attempt lookup with older \"jabber\" name.\n      try {\n        Attributes dnsLookup = context.getAttributes(\"_jabber._tcp.\" + domain);\n        String srvRecord = (String) dnsLookup.get(\"SRV\").get();\n        String[] srvRecordEntries = srvRecord.split(\" \");\n        port = Integer.parseInt(srvRecordEntries[srvRecordEntries.length - 2]);\n        host = srvRecordEntries[srvRecordEntries.length - 1];\n      } catch (Exception e2) {\n      }\n    }\n    // Host entries in DNS should end with a \".\".\n    if (host.endsWith(\".\")) {\n      host = host.substring(0, host.length() - 1);\n    }\n    return new HostAddress(domain, port);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 230,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ],
    "465424946-1644337256112": [
        {
            "ProgrammID": 250,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1644337945172,
            "program": "  static boolean extendsThread(ClassObj clazz) {\n    boolean extendsThread = false;\n    ClassObj parentClass = clazz;\n    while (parentClass.getSuperClassObj() != null) {\n      if (clazz.getClassName().equals(Thread.class.getName())) {\n        extendsThread = true;\n        break;\n      }\n      parentClass = parentClass.getSuperClassObj();\n    }\n    return extendsThread;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 69,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 302,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644338087923,
            "program": "  public void reconnectServer(\n      final String serverName,\n      final ModelNode domainModel,\n      final byte[] authKey,\n      final boolean running,\n      final boolean stopping) {\n    if (shutdown || connectionFinished) {\n      throw HostControllerMessages.MESSAGES.hostAlreadyShutdown();\n    }\n    final ManagedServer existing = servers.get(serverName);\n    if (existing != null) {\n      ROOT_LOGGER.existingServerWithState(serverName, existing.getState());\n      return;\n    }\n    final ManagedServer server = createManagedServer(serverName, domainModel, authKey);\n    if (servers.putIfAbsent(serverName, server) != null) {\n      ROOT_LOGGER.existingServerWithState(serverName, server.getState());\n      return;\n    }\n    if (running) {\n      if (!stopping) {\n        server.reconnectServerProcess();\n        // Register the server proxy at the domain controller\n        domainController.registerRunningServer(server.getProxyController());\n      } else {\n        server.setServerProcessStopping();\n      }\n    } else {\n      server.removeServerProcess();\n    }\n    synchronized (shutdownCondition) {\n      shutdownCondition.notifyAll();\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 182,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 295,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 11,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644338144107,
            "program": "  protected final RedisClusterConfiguration getClusterConfiguration() {\n    if (this.clusterConfiguration != null) {\n      return this.clusterConfiguration;\n    }\n    if (this.properties.getCluster() == null) {\n      return null;\n    }\n    Cluster clusterProperties = this.properties.getCluster();\n    RedisClusterConfiguration config = new RedisClusterConfiguration(clusterProperties.getNodes());\n\n    if (clusterProperties.getMaxRedirects() != null) {\n      config.setMaxRedirects(config.getMaxRedirects());\n    }\n    return config;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 90,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 248,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644338232557,
            "program": "  private SVNConflictReason parseConflictReason(@NotNull String reasonName) throws SAXException {\n    SVNConflictReason reason = SVNConflictReason.fromString(reasonName);\n    reason = reason != null ? reason : ourConflictReasons.get(reasonName);\n\n    if (reason == null) {\n      throw new SAXException(\"Can not parse conflict reason: \" + reasonName);\n    }\n\n    return reason;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 58,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 286,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644338363347,
            "program": "  public static View findParentViewHolderItemView(View v) {\n    final ViewParent parent = v.getParent();\n    if (parent instanceof RecyclerView) {\n      // returns the passed instance if the parent is RecyclerView\n      return v;\n    } else if (parent instanceof View) {\n      // check the parent view recursively\n      return findParentViewHolderItemView((View) parent);\n    } else {\n      return null;\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 55,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 240,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1644338691623,
            "program": "  public void setImeWindowStatus(\n      IBinder token, IBinder startInputToken, int vis, int backDisposition) {\n    if (!calledWithValidToken(token)) {\n      return;\n    }\n\n    final StartInputInfo info;\n    synchronized (mMethodMap) {\n      info = mStartInputMap.get(startInputToken);\n      mImeWindowVis = vis;\n      mBackDisposition = backDisposition;\n      updateSystemUiLocked(token, vis, backDisposition);\n    }\n    mWindowManagerInternal.updateInputMethodWindowStatus(\n        token,\n        (vis & InputMethodService.IME_VISIBLE) != 0,\n        info != null ? info.mTargetWindow : null);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 93,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 267,
            "lineNumberOfError": 3,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644338816713,
            "program": "  public MultiMap<VirtualFile, Hash> getCommitsAround(@NotNull Node node, int above, int below) {\n    MultiMap<VirtualFile, Hash> commits = MultiMap.create();\n    int rowIndex = node.getRowIndex();\n    for (int i = rowIndex - above; i < rowIndex + below; i++) {\n      Node commitNode = getCommitNodeInRow(i);\n      if (commitNode != null) {\n        Hash hash = myDataHolder.getHash(commitNode.getCommitIndex());\n        commits.putValue(commitNode.getBranch().getRepositoryRoot(), hash);\n      }\n    }\n    return commits;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 115,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        },
        {
            "ProgrammID": 297,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1644339102285,
            "program": "  public boolean satisfiedBy(PsiElement element) {\n    final PsiElement parent = element.getParent();\n    if (!(parent instanceof GrTypeDefinition)) return false;\n    if (((GrTypeDefinition) parent).getNameIdentifierGroovy() != element) return false;\n\n    final String name = ((GrTypeDefinition) element).getName();\n    if (name == null || name.length() == 0) return false;\n    final PsiFile file = element.getContainingFile();\n    if (!(file instanceof GroovyFile)) return false;\n    if (!file.isPhysical()) return false;\n    if (name.equals(FileUtil.getNameWithoutExtension(file.getName()))) return false;\n    if (mySearchForClassInMultiClassFile) {\n      return ((GroovyFile) file).getClasses().length > 1;\n    } else {\n      return !((GroovyFile) file).isScript();\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,develop",
            "token": 174,
            "ctx": "others",
            "codebase": "own",
            "team": "alone"
        }
    ],
    "308121866-1645037775848": [
        {
            "ProgrammID": 253,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1645039969409,
            "program": "  private void bulkAdd(String[] names, Vec[] vecs) {\n    Vec vec = vecs != null && vecs.length > 0 ? makeCompatible(new Frame(vecs[0])).anyVec() : null;\n    String[] tmpnames = names.clone();\n    int N = names.length;\n    assert (names.length == vecs.length);\n    for (int i = 0; i < N; ++i) {\n      checkCompatible(tmpnames[i] = uniquify(tmpnames[i]), vec); // Throw IAE is mismatch\n    }\n\n    int ncols = _keys.length;\n    _names = Arrays.copyOf(_names, ncols + N);\n    _keys = Arrays.copyOf(_keys, ncols + N);\n    _vecs = Arrays.copyOf(_vecs, ncols + N);\n    for (int i = 0; i < N; ++i) {\n      _names[ncols + i] = tmpnames[i];\n      _keys[ncols + i] = vecs[i]._key;\n      _vecs[ncols + i] = vecs[i];\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 210,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 288,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1645040013176,
            "program": "  public void removeFrameSlot(String name) {\n    assertNotRunning();\n    FrameSlot slot = getSlot(name);\n    slot.releaseFrame();\n    mFrameSlots.remove(slot);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 34,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 276,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645040244559,
            "program": "  public RuntimeContext prepare(RuntimeIdentity id, Environment originEnv)\n      throws ValidationException, InfrastructureException {\n    final EnvironmentImpl environment = new EnvironmentImpl(originEnv);\n    final OpenShiftEnvironment openShiftEnvironment = envParser.parse(environment);\n\n    infrastructureProvisioner.provision(environment, openShiftEnvironment, id);\n\n    return runtimeContextFactory.create(environment, openShiftEnvironment, id, this);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 62,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 273,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645040592543,
            "program": "  private int recursiveCollapse(@IntRange(from = 0) int position) {\n    T item = getItem(position);\n    if (!isExpandable(item)) {\n      return 0;\n    }\n    IExpandable expandable = (IExpandable) item;\n    int subItemCount = 0;\n    if (expandable.isExpanded()) {\n      List<T> subItems = expandable.getSubItems();\n      for (int i = subItems.size() - 1; i >= 0; i--) {\n        T subItem = subItems.get(i);\n        int pos = getItemPosition(subItem);\n        if (pos < 0) {\n          continue;\n        }\n        if (subItem instanceof IExpandable) {\n          subItemCount += recursiveCollapse(pos);\n        }\n        mData.remove(subItem);\n        subItemCount++;\n      }\n    }\n    return subItemCount;\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 150,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 251,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645040948049,
            "program": "  private static void collectPythonInstallations(String pythonPath, List<String> candidates) {\n    VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(pythonPath);\n    if (rootVDir != null) {\n      for (VirtualFile dir : rootVDir.getChildren()) {\n        final String dir_name = dir.getName().toLowerCase();\n        if (dir.isDirectory()) {\n          if (\"Current\".equals(dir_name) || dir_name.startsWith(\"2\") || dir_name.startsWith(\"3\")) {\n            VirtualFile bin_dir = dir.findChild(\"bin\");\n            if (bin_dir != null && bin_dir.isDirectory()) {\n              VirtualFile python_exe = bin_dir.findChild(\"python\");\n              if (python_exe != null) candidates.add(python_exe.getPath());\n            }\n          }\n        }\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 151,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 265,
            "lineNumberOfError": 1,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1645040972850,
            "program": "  public void glGenBuffers(int n, int[] buffers, int offset) {\r\n    for (int i = offset; i < offset + n; i++) buffers[i] = GL15.glGenBuffers();\r\n  }\r\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 44,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 292,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645041045555,
            "program": "  public void track(WPStats.Stat stat, JSONObject properties) {\n    WPStatsTrackerMixpanelInstructionsForStat instructions = instructionsForStat(stat);\n\n    if (instructions == null) return;\n\n    trackMixpanelDataForInstructions(instructions, properties);\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 37,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 272,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645041211964,
            "program": "  protected void renderTemplate(\n      Map<String, Object> model,\n      GrailsWebRequest webRequest,\n      HttpServletRequest request,\n      HttpServletResponse response)\n      throws Exception {\n    Content content = obtainContent(model, webRequest, request, response);\n    if (content != null) {\n      beforeDecorating(content, model, webRequest, request, response);\n      SpringMVCViewDecorator decorator =\n          (SpringMVCViewDecorator) groovyPageLayoutFinder.findLayout(request, content);\n      if (decorator != null) {\n        decorator.render(content, model, request, response, webRequest.getServletContext());\n      } else {\n        PrintWriter writer = response.getWriter();\n        content.writeOriginal(writer);\n        if (!response.isCommitted()) {\n          writer.flush();\n        }\n      }\n    }\n  }\n",
            "exp": "2-5",
            "age": "30",
            "task": "test,review,develop",
            "token": 138,
            "ctx": "oss",
            "codebase": "own",
            "team": "small"
        }
    ],
    "1736043785-1645375563818": [
        {
            "ProgrammID": 257,
            "lineNumberOfError": 15,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1645376150660,
            "program": "  protected void crateCall(long[] args) {\n    int i = 2;\n    int target = getIndex(args[i++]);\n    int[] arguments = new int[args.length - i];\n    int j = 0;\n    while (j < arguments.length) {\n      arguments[j++] = getIndex(args[i++]);\n    }\n\n    Type type = symbols.get(target).getType();\n\n    if (type instanceof PointerType) {\n      type = ((PointerType) type).getPointeeType();\n    }\n\n    Type returnType = ((FunctionType) type).getReturnType();\n\n    code.createCall(returnType, target, arguments);\n\n    if (returnType != MetaType.VOID) {\n      symbols.add(returnType);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 150,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 245,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645376225727,
            "program": "  public static Range getRange(int startMonth, int startDay, int endMonth, int endDay) {\n    Calendar start = Calendar.getInstance();\n    start.set(Calendar.MONTH, startMonth);\n    start.set(Calendar.DAY_OF_MONTH, startDay);\n    start = truncateToMidnight(start);\n\n    Calendar end = Calendar.getInstance();\n    end.set(Calendar.MONTH, endMonth);\n    end.set(Calendar.DAY_OF_MONTH, endDay);\n    end.set(Calendar.HOUR_OF_DAY, 23);\n    end.set(Calendar.MINUTE, 59);\n    end.set(Calendar.SECOND, 59);\n    end.set(Calendar.MILLISECOND, 999);\n\n    return new Range(start, end);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 141,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 299,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645376333326,
            "program": "  public double distance(double centroidLengthSquare, Vector centroid, Vector v) {\n    if (centroid.size() != v.size()) {\n      throw new CardinalityException();\n    }\n\n    double result = centroidLengthSquare;\n    result += v.getDistanceSquared(centroid);\n    return result;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 54,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 287,
            "lineNumberOfError": 4,
            "attempt": 1,
            "expectedAnswer": 8,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645376413582,
            "program": "  public final String resolveRelativePathEntry(String path, String relativeTo) {\n    if (relativeTo == null) {\n      return AbsolutePathService.convertPath(path);\n    } else {\n      PathEntry pathEntry;\n      synchronized (pathEntries) {\n        pathEntry = pathEntries.get(relativeTo);\n        if (pathEntry == null) {\n          throw MESSAGES.pathEntryNotFound(path);\n        }\n        return RelativePathService.doResolve(pathEntry.resolvePath(), path);\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 80,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 242,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645376521576,
            "program": "  public synchronized void update(\r\n      final float pX1, final float pY1, final float pX2, final float pY2) {\r\n    final int[] bufferData = this.mBufferData;\r\n\r\n    bufferData[0] = Float.floatToRawIntBits(pX1);\r\n    bufferData[1] = Float.floatToRawIntBits(pY1);\r\n\r\n    bufferData[2] = Float.floatToRawIntBits(pX2);\r\n    bufferData[3] = Float.floatToRawIntBits(pY2);\r\n\r\n    final FastFloatBuffer buffer = this.getFloatBuffer();\r\n    buffer.position(0);\r\n    buffer.put(bufferData);\r\n    buffer.position(0);\r\n\r\n    super.setHardwareBufferNeedsUpdate();\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 118,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 281,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645376742713,
            "program": "  Map<VirtualFile, Object[]> getDirectInheritors(\n      @NotNull LightRef searchElement,\n      @NotNull GlobalSearchScope searchScope,\n      @NotNull GlobalSearchScope dirtyScope,\n      @NotNull FileType fileType,\n      @NotNull CompilerHierarchySearchType searchType)\n      throws StorageException {\n    GlobalSearchScope effectiveSearchScope =\n        GlobalSearchScope.notScope(dirtyScope).intersectWith(searchScope);\n    LanguageLightRefAdapter adapter = CompilerReferenceServiceImpl.findAdapterForFileType(fileType);\n    LOG.assertTrue(adapter != null, \"adapter is null for file type: \" + fileType);\n    Class<? extends LightRef> requiredLightRefClass = searchType.getRequiredClass(adapter);\n\n    Map<VirtualFile, Object[]> candidatesPerFile = new HashMap<>();\n    myIndex\n        .get(CompilerIndices.BACK_HIERARCHY)\n        .getData(searchElement)\n        .forEach(\n            (fileId, defs) -> {\n              final List<LightRef> requiredCandidates =\n                  defs.stream().filter(requiredLightRefClass::isInstance).collect(toList());\n              if (requiredCandidates.isEmpty()) return true;\n              final VirtualFile file = findFile(fileId);\n              if (file != null && effectiveSearchScope.contains(file)) {\n                candidatesPerFile.put(\n                    file, searchType.convertToIds(requiredCandidates, myIndex.getByteSeqEum()));\n              }\n              return true;\n            });\n    return candidatesPerFile.isEmpty() ? Collections.emptyMap() : candidatesPerFile;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 235,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 260,
            "lineNumberOfError": 10,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1645376859037,
            "program": "  public InstallState getInstallState(Version system) {\r\n    if (StringUtils.isEmpty(installedRelease)) {\r\n      return InstallState.NOT_INSTALLED;\r\n    }\r\n    Version ir = Version.createVersion(installedRelease);\r\n    Version cr = Version.ZERO;\r\n    PluginRelease curr = getCurrentRelease(system);\r\n    if (curr != null) {\r\n      cr = Version.createVersion(curr.version);\r\n    }\r\n    switch (ir.compareTo(cr)) {\r\n      case -1:\r\n        return InstallState.UNKNOWN;\r\n      case 1:\r\n        return InstallState.UPDATE_AVAILABLE;\r\n      default:\r\n        return InstallState.INSTALLED;\r\n    }\r\n  }\r\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 104,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 285,
            "lineNumberOfError": -2,
            "attempt": 1,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645377013789,
            "program": "  protected Principal getPrincipal(String username) {\n\n    User user = database.findUser(username);\n    if (user == null) {\n      return null;\n    }\n\n    List roles = new ArrayList();\n    Iterator uroles = user.getRoles();\n    while (uroles.hasNext()) {\n      Role role = (Role) uroles.next();\n      roles.add(role.getName());\n    }\n    Iterator groups = user.getGroups();\n    while (groups.hasNext()) {\n      Group group = (Group) groups.next();\n      uroles = group.getRoles();\n      while (uroles.hasNext()) {\n        Role role = (Role) uroles.next();\n        roles.add(role.getName());\n      }\n    }\n    return new GenericPrincipal(this, username, user.getPassword(), roles, user);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 171,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 246,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645377093153,
            "program": "  protected void addTempAttachment(ActionRequest actionRequest) throws Exception {\n\n    UploadPortletRequest uploadRequest = PortalUtil.getUploadPortletRequest(actionRequest);\n\n    long nodeId = ParamUtil.getLong(actionRequest, \"nodeId\");\n\n    File file = uploadRequest.getFile(\"file\");\n    String sourceFileName = uploadRequest.getFileName(\"file\");\n\n    WikiPageServiceUtil.addTempPageAttachment(nodeId, sourceFileName, _TEMP_FOLDER_NAME, file);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 66,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 269,
            "lineNumberOfError": 9,
            "attempt": 2,
            "expectedAnswer": 9,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1645377155429,
            "program": "  private void initializeFromMailto(MailTo mailTo) {\n    recipientPresenter.initFromMailto(mailTo);\n\n    String subject = mailTo.getSubject();\n    if (subject != null && !subject.isEmpty()) {\n      mSubjectView.setText(subject);\n    }\n\n    String body = mailTo.getBody();\n    if (body != null && !subject.isEmpty()) {\n      mMessageContentView.setCharacters(body);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 78,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 290,
            "lineNumberOfError": 5,
            "attempt": 2,
            "expectedAnswer": 5,
            "taskSolvedCorrectly": true,
            "correctLineNumber": true,
            "timestamp": 1645377176407,
            "program": "  private static String getAlgorithmMode(String algorithm) {\n    int start = algorithm.indexOf('/');\n    if (start < 0)\n      throw new IllegalArgumentException(sm.getString(\"encryptInterceptor.algorithm.required\"));\n    int end = algorithm.indexOf('/', start + 1);\n    if (start < 0)\n      throw new IllegalArgumentException(sm.getString(\"encryptInterceptor.algorithm.required\"));\n\n    return algorithm.substring(start + 1, end);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 82,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 307,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645377266883,
            "program": "  public ScheduledEntry<K, V> cancelComparingTimeKey(K key) {\n    Set<TimeKey> candidateKeys = new HashSet<TimeKey>();\n    for (Object tkey : secondsOfKeys.keySet()) {\n      TimeKey timeKey = (TimeKey) tkey;\n      if (timeKey.getKey().equals(key)) {\n        candidateKeys.add(timeKey);\n      }\n    }\n\n    ScheduledEntry<K, V> result = null;\n    for (TimeKey timeKey : candidateKeys) {\n      final Integer second = secondsOfKeys.remove(timeKey);\n      if (second != null) {\n        final ConcurrentMap<Object, ScheduledEntry<K, V>> entries = scheduledEntries.get(second);\n        if (entries != null) {\n          result = entries.remove(timeKey);\n        }\n      }\n    }\n\n    return result;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 150,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 243,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 2,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1645377377135,
            "program": "  private void registerAuthenticatedSession(WsSession wsSession, String httpSessionId) {\n    Set<WsSession> wsSessions = authenticatedSessions.get(httpSessionId);\n    if (wsSession == null) {\n      wsSessions = Collections.newSetFromMap(new ConcurrentHashMap<WsSession, Boolean>());\n      authenticatedSessions.putIfAbsent(httpSessionId, wsSessions);\n      wsSessions = authenticatedSessions.get(httpSessionId);\n    }\n    wsSessions.add(wsSession);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 75,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 304,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645377425248,
            "program": "  static Object unwrapResourceIfNecessary(Object resource) {\n    Assert.notNull(resource, \"Resource must not be null\");\n    Object resourceRef = resource;\n    // unwrap infrastructure proxy\n    if (resourceRef instanceof InfrastructureProxy) {\n      resourceRef = ((InfrastructureProxy) resourceRef).getWrappedObject();\n    }\n    if (aopAvailable) {\n      // now unwrap scoped proxy\n      resourceRef = ScopedProxyUnwrapper.unwrapIfNecessary(resourceRef);\n    }\n    return resourceRef;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 62,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 305,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": 4,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1645377493820,
            "program": "  private void assertEqualClusterDescriptions(\n      final ClusterDescription expected, final ClusterDescription actual) {\n    assertEquals(expected.getType(), actual.getType());\n    assertEquals(expected.getAll().size(), actual.getAll().size());\n    for (ServerDescription curExpected : actual.getAll()) {\n      ServerDescription curActual = getByServerAddress(curExpected.getAddress(), actual.getAll());\n      assertNotNull(curActual);\n      assertEqualServerDescriptions(curExpected, curActual);\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 95,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 252,
            "lineNumberOfError": -2,
            "attempt": 2,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645377528801,
            "program": "  public void addIterationHead(\n      Integer vertexID, Integer iterationHead, Integer iterationID, long timeOut) {\n\n    addNode(vertexID, StreamIterationHead.class, null, null);\n\n    chaining = false;\n\n    StreamLoop iteration = new StreamLoop(iterationID, getStreamNode(vertexID), timeOut);\n    streamLoops.put(iterationID, iteration);\n    vertexIDtoLoop.put(vertexID, iteration);\n\n    setSerializersFrom(iterationHead, vertexID);\n    getStreamNode(vertexID).setOperatorName(\"IterationHead-\" + iterationHead);\n\n    int outpartitionerIndex = getStreamNode(iterationHead).getInEdgeIndices().get(0);\n    StreamPartitioner<?> outputPartitioner =\n        getStreamNode(outpartitionerIndex).getOutEdges().get(0).getPartitioner();\n\n    addEdge(vertexID, iterationHead, outputPartitioner, 0, new ArrayList<String>());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"ITERATION SOURCE: {}\", vertexID);\n    }\n\n    sources.add(vertexID);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 174,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 244,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645377929104,
            "program": "  public boolean remove(MessageInput input) {\n    final IOState<MessageInput> inputState = this.stop(input);\n    if (inputState != null) inputState.setState(IOState.Type.TERMINATED);\n\n    return super.remove(inputState);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 48,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 294,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645377955783,
            "program": "  default <T> T get(Class<T> key) {\n    T v = get((Object) key);\n    if (key.isInstance(v)) {\n      return v;\n    }\n    return null;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 43,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 268,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645378005487,
            "program": "  private void addInputBindRow(SimpleUri uri, RegisterBindButton bind, ColumnLayout layout) {\n    UIInputBindButton inputBind = new UIInputBindButton();\n    inputBind.setManager(getManager());\n    inputBind.setDescription(bind.description());\n    inputBind.bindInput(new InputConfigBinding(config.getInput().getBinds(), uri));\n    UIInputBindButton secondaryInputBind = new UIInputBindButton();\n    secondaryInputBind.setManager(getManager());\n    secondaryInputBind.setDescription(bind.description());\n    secondaryInputBind.bindInput(new InputConfigBinding(config.getInput().getBinds(), uri, 1));\n    layout.addWidget(\n        new RowLayout(new UILabel(bind.description()), inputBind, secondaryInputBind)\n            .setColumnRatios(0.4f)\n            .setHorizontalSpacing(horizontalSpacing));\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 148,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 254,
            "lineNumberOfError": 7,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1645378128315,
            "program": "  public static MetadataListStructObjectInspector getInstance(List<String> columnNames) {\n    ArrayList<List<String>> key = new ArrayList<List<String>>(1);\n    key.add(columnNames);\n    MetadataListStructObjectInspector result = cached.get(key);\n    if (result == null) {\n      result = new MetadataListStructObjectInspector(columnNames);\n      MetadataListStructObjectInspector prev = cached.putIfAbsent(key, result);\n      if (prev != null) {\n        result = prev;\n      }\n    }\n    return result;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 94,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 306,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645378212052,
            "program": "  protected void processTypeSwitch(AbstractBeginNode beginNode, TypeSwitchNode typeSwitch) {\n    ValueNode hub = typeSwitch.value();\n    if (hub instanceof LoadHubNode) {\n      LoadHubNode loadHub = (LoadHubNode) hub;\n      ValueNode value = loadHub.getValue();\n      if (maybeMultipleUsages(value)) {\n        Stamp stamp = null;\n        for (int i = 0; i < typeSwitch.keyCount(); i++) {\n          if (typeSwitch.keySuccessor(i) == beginNode) {\n            if (stamp == null) {\n              stamp =\n                  StampFactory.objectNonNull(\n                      TypeReference.createExactTrusted(typeSwitch.typeAt(i)));\n            } else {\n              stamp =\n                  stamp.meet(\n                      StampFactory.objectNonNull(\n                          TypeReference.createExactTrusted(typeSwitch.typeAt(i))));\n            }\n          }\n        }\n        if (stamp != null) {\n          registerNewStamp(value, stamp, beginNode);\n        }\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 164,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 271,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645378357389,
            "program": "  private static void registerCustomAnnotators(\n      AnnotatorPool pool, AnnotatorImplementations annotatorImplementation, Properties inputProps) {\n    // add annotators loaded via reflection from class names specified\n    // in the properties\n    for (String property : inputProps.stringPropertyNames()) {\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName = property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        logger.info(\"Registering annotator \" + customName + \" with class \" + customClassName);\n        pool.register(\n            customName,\n            inputProps,\n            Lazy.of(() -> annotatorImplementation.custom(inputProps, property)));\n      }\n    }\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 105,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 258,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": 6,
            "taskSolvedCorrectly": false,
            "correctLineNumber": false,
            "timestamp": 1645378426147,
            "program": "  @Override\n  public void getBounds(RectF outBounds, Matrix parentMatrix) {\n    path.reset();\n    for (int i = 0; i < pathGroups.size(); i++) {\n      PathGroup pathGroup = pathGroups.get(i);\n      for (int j = 0; j < pathGroup.paths.size(); j++) {\n        path.addPath(pathGroup.paths.get(i).getPath(), parentMatrix);\n      }\n    }\n    path.computeBounds(rect, false);\n\n    float width = widthAnimation.getValue();\n    rect.set(\n        rect.left - width / 2f,\n        rect.top - width / 2f,\n        rect.right + width / 2f,\n        rect.bottom + width / 2f);\n    outBounds.set(rect);\n    // Add padding to account for rounding errors.\n    outBounds.set(outBounds.left - 1, outBounds.top - 1, outBounds.right + 1, outBounds.bottom + 1);\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 183,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        },
        {
            "ProgrammID": 241,
            "lineNumberOfError": -2,
            "attempt": 3,
            "expectedAnswer": -1,
            "taskSolvedCorrectly": true,
            "correctLineNumber": false,
            "timestamp": 1645378464443,
            "program": "  public URL getResource(String name) {\n    if (_notFound.contains(name)) {\n      if (LOG.isDebugEnabled()) LOG.debug(\"Not found cache hit resource {}\", name);\n      return null;\n    }\n\n    URL url = _cache.get(name);\n\n    if (url == null) {\n      // Not found in cache, try parent\n      url = super.getResource(name);\n\n      if (url == null) {\n        // Still not found, cache the not-found result\n        if (LOG.isDebugEnabled()) LOG.debug(\"Caching not found resource {}\", name);\n        _notFound.add(name);\n      } else {\n        // Cache the new result\n        _cache.putIfAbsent(name, url);\n      }\n    }\n\n    return url;\n  }\n",
            "exp": "5",
            "age": "30",
            "task": "test,review,develop",
            "token": 114,
            "ctx": "commercial",
            "codebase": "own",
            "team": "small"
        }
    ]
}